{"version":3,"sources":["index.js","lib/cookies.js","lib/helpers.js","request.js","lib/getProxyFromURI.js","lib/querystring.js","lib/har.js","lib/auth.js","lib/oauth.js","lib/hawk.js","lib/multipart.js","lib/redirect.js","lib/tunnel.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,AGTA,AFMA,ACHA;AHUA,ACHA,AGTA,AFMA,ACHA;AHUA,ACHA,AGTA,AFMA,ACHA;AHUA,ACHA,AGTA,AFMA,AGTA,AFMA;AHUA,ACHA,AGTA,AFMA,AGTA,AFMA;AHUA,ACHA,AGTA,AFMA,AGTA,AFMA;AHUA,ACHA,AGTA,AENA,AJYA,AGTA,AFMA;AHUA,ACHA,AGTA,AENA,AJYA,AGTA,AFMA;AHUA,ACHA,AGTA,AENA,AJYA,AGTA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AJYA,AGTA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AJYA,AGTA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AJYA,AGTA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AJYA,AMlBA,AHSA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AJYA,AMlBA,AHSA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AJYA,AMlBA,AHSA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AMlBA,AHSA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AMlBA,AHSA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AMlBA,AHSA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AFMA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ARwBA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ARwBA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ARwBA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,ANkBA,AGTA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AHSA,AMlBA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,APqBA,AQxBA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,AHSA,AENA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AGTA,ACHA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AIZA,AFMA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AHUA,AOrBA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AENA,AGTA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AKfA,ACHA,AT2BA;AIXA,ADGA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AMlBA,AT2BA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// Copyright 2010-2012 Mikeal Rogers\r\n//\r\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n//    you may not use this file except in compliance with the License.\r\n//    You may obtain a copy of the License at\r\n//\r\n//        http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n//    Unless required by applicable law or agreed to in writing, software\r\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n//    See the License for the specific language governing permissions and\r\n//    limitations under the License.\r\n\r\n\r\n\r\nvar extend = require('extend')\r\nvar cookies = require('./lib/cookies')\r\nvar helpers = require('./lib/helpers')\r\n\r\nvar paramsHaveRequestBody = helpers.paramsHaveRequestBody\r\n\r\n// organize params for patch, post, put, head, del\r\nfunction initParams (uri, options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options\r\n  }\r\n\r\n  var params = {}\r\n  if (options !== null && typeof options === 'object') {\r\n    extend(params, options, {uri: uri})\r\n  } else if (typeof uri === 'string') {\r\n    extend(params, {uri: uri})\r\n  } else {\r\n    extend(params, uri)\r\n  }\r\n\r\n  params.callback = callback || params.callback\r\n  return params\r\n}\r\n\r\nfunction request (uri, options, callback) {\r\n  if (typeof uri === 'undefined') {\r\n    throw new Error('undefined is not a valid uri or options object.')\r\n  }\r\n\r\n  var params = initParams(uri, options, callback)\r\n\r\n  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {\r\n    throw new Error('HTTP HEAD requests MUST NOT include a request body.')\r\n  }\r\n\r\n  return new request.Request(params)\r\n}\r\n\r\nfunction verbFunc (verb) {\r\n  var method = verb.toUpperCase()\r\n  return function (uri, options, callback) {\r\n    var params = initParams(uri, options, callback)\r\n    params.method = method\r\n    return request(params, params.callback)\r\n  }\r\n}\r\n\r\n// define like this to please codeintel/intellisense IDEs\r\nrequest.get = verbFunc('get')\r\nrequest.head = verbFunc('head')\r\nrequest.options = verbFunc('options')\r\nrequest.post = verbFunc('post')\r\nrequest.put = verbFunc('put')\r\nrequest.patch = verbFunc('patch')\r\nrequest.del = verbFunc('delete')\r\nrequest['delete'] = verbFunc('delete')\r\n\r\nrequest.jar = function (store) {\r\n  return cookies.jar(store)\r\n}\r\n\r\nrequest.cookie = function (str) {\r\n  return cookies.parse(str)\r\n}\r\n\r\nfunction wrapRequestMethod (method, options, requester, verb) {\r\n  return function (uri, opts, callback) {\r\n    var params = initParams(uri, opts, callback)\r\n\r\n    var target = {}\r\n    extend(true, target, options, params)\r\n\r\n    target.pool = params.pool || options.pool\r\n\r\n    if (verb) {\r\n      target.method = verb.toUpperCase()\r\n    }\r\n\r\n    if (typeof requester === 'function') {\r\n      method = requester\r\n    }\r\n\r\n    return method(target, target.callback)\r\n  }\r\n}\r\n\r\nrequest.defaults = function (options, requester) {\r\n  var self = this\r\n\r\n  options = options || {}\r\n\r\n  if (typeof options === 'function') {\r\n    requester = options\r\n    options = {}\r\n  }\r\n\r\n  var defaults = wrapRequestMethod(self, options, requester)\r\n\r\n  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete']\r\n  verbs.forEach(function (verb) {\r\n    defaults[verb] = wrapRequestMethod(self[verb], options, requester, verb)\r\n  })\r\n\r\n  defaults.cookie = wrapRequestMethod(self.cookie, options, requester)\r\n  defaults.jar = self.jar\r\n  defaults.defaults = self.defaults\r\n  return defaults\r\n}\r\n\r\nrequest.forever = function (agentOptions, optionsArg) {\r\n  var options = {}\r\n  if (optionsArg) {\r\n    extend(options, optionsArg)\r\n  }\r\n  if (agentOptions) {\r\n    options.agentOptions = agentOptions\r\n  }\r\n\r\n  options.forever = true\r\n  return request.defaults(options)\r\n}\r\n\r\n// Exports\r\n\r\nmodule.exports = request\r\nrequest.Request = require('./request')\r\nrequest.initParams = initParams\r\n\r\n// Backwards compatibility for request.debug\r\nObject.defineProperty(request, 'debug', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return request.Request.debug\r\n  },\r\n  set: function (debug) {\r\n    request.Request.debug = debug\r\n  }\r\n})\r\n","\r\n\r\nvar tough = require('tough-cookie')\r\n\r\nvar Cookie = tough.Cookie\r\nvar CookieJar = tough.CookieJar\r\n\r\nexports.parse = function (str) {\r\n  if (str && str.uri) {\r\n    str = str.uri\r\n  }\r\n  if (typeof str !== 'string') {\r\n    throw new Error('The cookie function only accepts STRING as param')\r\n  }\r\n  return Cookie.parse(str, {loose: true})\r\n}\r\n\r\n// Adapt the sometimes-Async api of tough.CookieJar to our requirements\r\nfunction RequestJar (store) {\r\n  var self = this\r\n  self._jar = new CookieJar(store, {looseMode: true})\r\n}\r\nRequestJar.prototype.setCookie = function (cookieOrStr, uri, options) {\r\n  var self = this\r\n  return self._jar.setCookieSync(cookieOrStr, uri, options || {})\r\n}\r\nRequestJar.prototype.getCookieString = function (uri) {\r\n  var self = this\r\n  return self._jar.getCookieStringSync(uri)\r\n}\r\nRequestJar.prototype.getCookies = function (uri) {\r\n  var self = this\r\n  return self._jar.getCookiesSync(uri)\r\n}\r\n\r\nexports.jar = function (store) {\r\n  return new RequestJar(store)\r\n}\r\n","\r\n\r\nvar jsonSafeStringify = require('json-stringify-safe')\r\nvar crypto = require('crypto')\r\nvar Buffer = require('safe-buffer').Buffer\r\n\r\nvar defer = typeof setImmediate === 'undefined'\r\n  ? process.nextTick\r\n  : setImmediate\r\n\r\nfunction paramsHaveRequestBody (params) {\r\n  return (\r\n    params.body ||\r\n    params.requestBodyStream ||\r\n    (params.json && typeof params.json !== 'boolean') ||\r\n    params.multipart\r\n  )\r\n}\r\n\r\nfunction safeStringify (obj, replacer) {\r\n  var ret\r\n  try {\r\n    ret = JSON.stringify(obj, replacer)\r\n  } catch (e) {\r\n    ret = jsonSafeStringify(obj, replacer)\r\n  }\r\n  return ret\r\n}\r\n\r\nfunction md5 (str) {\r\n  return crypto.createHash('md5').update(str).digest('hex')\r\n}\r\n\r\nfunction isReadStream (rs) {\r\n  return rs.readable && rs.path && rs.mode\r\n}\r\n\r\nfunction toBase64 (str) {\r\n  return Buffer.from(str || '', 'utf8').toString('base64')\r\n}\r\n\r\nfunction copy (obj) {\r\n  var o = {}\r\n  Object.keys(obj).forEach(function (i) {\r\n    o[i] = obj[i]\r\n  })\r\n  return o\r\n}\r\n\r\nfunction version () {\r\n  var numbers = process.version.replace('v', '').split('.')\r\n  return {\r\n    major: parseInt(numbers[0], 10),\r\n    minor: parseInt(numbers[1], 10),\r\n    patch: parseInt(numbers[2], 10)\r\n  }\r\n}\r\n\r\nexports.paramsHaveRequestBody = paramsHaveRequestBody\r\nexports.safeStringify = safeStringify\r\nexports.md5 = md5\r\nexports.isReadStream = isReadStream\r\nexports.toBase64 = toBase64\r\nexports.copy = copy\r\nexports.version = version\r\nexports.defer = defer\r\n","\r\n\r\nvar http = require('http')\r\nvar https = require('https')\r\nvar url = require('url')\r\nvar util = require('util')\r\nvar stream = require('stream')\r\nvar zlib = require('zlib')\r\nvar aws2 = require('aws-sign2')\r\nvar aws4 = require('aws4')\r\nvar httpSignature = require('http-signature')\r\nvar mime = require('mime-types')\r\nvar caseless = require('caseless')\r\nvar ForeverAgent = require('forever-agent')\r\nvar FormData = require('form-data')\r\nvar extend = require('extend')\r\nvar isstream = require('isstream')\r\nvar isTypedArray = require('is-typedarray').strict\r\nvar helpers = require('./lib/helpers')\r\nvar cookies = require('./lib/cookies')\r\nvar getProxyFromURI = require('./lib/getProxyFromURI')\r\nvar Querystring = require('./lib/querystring').Querystring\r\nvar Har = require('./lib/har').Har\r\nvar Auth = require('./lib/auth').Auth\r\nvar OAuth = require('./lib/oauth').OAuth\r\nvar hawk = require('./lib/hawk')\r\nvar Multipart = require('./lib/multipart').Multipart\r\nvar Redirect = require('./lib/redirect').Redirect\r\nvar Tunnel = require('./lib/tunnel').Tunnel\r\nvar now = require('performance-now')\r\nvar Buffer = require('safe-buffer').Buffer\r\n\r\nvar safeStringify = helpers.safeStringify\r\nvar isReadStream = helpers.isReadStream\r\nvar toBase64 = helpers.toBase64\r\nvar defer = helpers.defer\r\nvar copy = helpers.copy\r\nvar version = helpers.version\r\nvar globalCookieJar = cookies.jar()\r\n\r\nvar globalPool = {}\r\n\r\nfunction filterForNonReserved (reserved, options) {\r\n  // Filter out properties that are not reserved.\r\n  // Reserved values are passed in at call site.\r\n\r\n  var object = {}\r\n  for (var i in options) {\r\n    var notReserved = (reserved.indexOf(i) === -1)\r\n    if (notReserved) {\r\n      object[i] = options[i]\r\n    }\r\n  }\r\n  return object\r\n}\r\n\r\nfunction filterOutReservedFunctions (reserved, options) {\r\n  // Filter out properties that are functions and are reserved.\r\n  // Reserved values are passed in at call site.\r\n\r\n  var object = {}\r\n  for (var i in options) {\r\n    var isReserved = !(reserved.indexOf(i) === -1)\r\n    var isFunction = (typeof options[i] === 'function')\r\n    if (!(isReserved && isFunction)) {\r\n      object[i] = options[i]\r\n    }\r\n  }\r\n  return object\r\n}\r\n\r\n// Return a simpler request object to allow serialization\r\nfunction requestToJSON () {\r\n  var self = this\r\n  return {\r\n    uri: self.uri,\r\n    method: self.method,\r\n    headers: self.headers\r\n  }\r\n}\r\n\r\n// Return a simpler response object to allow serialization\r\nfunction responseToJSON () {\r\n  var self = this\r\n  return {\r\n    statusCode: self.statusCode,\r\n    body: self.body,\r\n    headers: self.headers,\r\n    request: requestToJSON.call(self.request)\r\n  }\r\n}\r\n\r\nfunction Request (options) {\r\n  // if given the method property in options, set property explicitMethod to true\r\n\r\n  // extend the Request instance with any non-reserved properties\r\n  // remove any reserved functions from the options object\r\n  // set Request instance to be readable and writable\r\n  // call init\r\n\r\n  var self = this\r\n\r\n  // start with HAR, then override with additional options\r\n  if (options.har) {\r\n    self._har = new Har(self)\r\n    options = self._har.options(options)\r\n  }\r\n\r\n  stream.Stream.call(self)\r\n  var reserved = Object.keys(Request.prototype)\r\n  var nonReserved = filterForNonReserved(reserved, options)\r\n\r\n  extend(self, nonReserved)\r\n  options = filterOutReservedFunctions(reserved, options)\r\n\r\n  self.readable = true\r\n  self.writable = true\r\n  if (options.method) {\r\n    self.explicitMethod = true\r\n  }\r\n  self._qs = new Querystring(self)\r\n  self._auth = new Auth(self)\r\n  self._oauth = new OAuth(self)\r\n  self._multipart = new Multipart(self)\r\n  self._redirect = new Redirect(self)\r\n  self._tunnel = new Tunnel(self)\r\n  self.init(options)\r\n}\r\n\r\nutil.inherits(Request, stream.Stream)\r\n\r\n// Debugging\r\nRequest.debug = process.env.NODE_DEBUG && /\\brequest\\b/.test(process.env.NODE_DEBUG)\r\nfunction debug () {\r\n  if (Request.debug) {\r\n    console.error('REQUEST %s', util.format.apply(util, arguments))\r\n  }\r\n}\r\nRequest.prototype.debug = debug\r\n\r\nRequest.prototype.init = function (options) {\r\n  // init() contains all the code to setup the request object.\r\n  // the actual outgoing request is not started until start() is called\r\n  // this function is called from both the constructor and on redirect.\r\n  var self = this\r\n  if (!options) {\r\n    options = {}\r\n  }\r\n  self.headers = self.headers ? copy(self.headers) : {}\r\n\r\n  // Delete headers with value undefined since they break\r\n  // ClientRequest.OutgoingMessage.setHeader in node 0.12\r\n  for (var headerName in self.headers) {\r\n    if (typeof self.headers[headerName] === 'undefined') {\r\n      delete self.headers[headerName]\r\n    }\r\n  }\r\n\r\n  caseless.httpify(self, self.headers)\r\n\r\n  if (!self.method) {\r\n    self.method = options.method || 'GET'\r\n  }\r\n  if (!self.localAddress) {\r\n    self.localAddress = options.localAddress\r\n  }\r\n\r\n  self._qs.init(options)\r\n\r\n  debug(options)\r\n  if (!self.pool && self.pool !== false) {\r\n    self.pool = globalPool\r\n  }\r\n  self.dests = self.dests || []\r\n  self.__isRequestRequest = true\r\n\r\n  // Protect against double callback\r\n  if (!self._callback && self.callback) {\r\n    self._callback = self.callback\r\n    self.callback = function () {\r\n      if (self._callbackCalled) {\r\n        return // Print a warning maybe?\r\n      }\r\n      self._callbackCalled = true\r\n      self._callback.apply(self, arguments)\r\n    }\r\n    self.on('error', self.callback.bind())\r\n    self.on('complete', self.callback.bind(self, null))\r\n  }\r\n\r\n  // People use this property instead all the time, so support it\r\n  if (!self.uri && self.url) {\r\n    self.uri = self.url\r\n    delete self.url\r\n  }\r\n\r\n  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\r\n  // specified as a relative path and is appended to baseUrl).\r\n  if (self.baseUrl) {\r\n    if (typeof self.baseUrl !== 'string') {\r\n      return self.emit('error', new Error('options.baseUrl must be a string'))\r\n    }\r\n\r\n    if (typeof self.uri !== 'string') {\r\n      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))\r\n    }\r\n\r\n    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\r\n      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))\r\n    }\r\n\r\n    // Handle all cases to make sure that there's only one slash between\r\n    // baseUrl and uri.\r\n    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1\r\n    var uriStartsWithSlash = self.uri.indexOf('/') === 0\r\n\r\n    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\r\n      self.uri = self.baseUrl + self.uri.slice(1)\r\n    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\r\n      self.uri = self.baseUrl + self.uri\r\n    } else if (self.uri === '') {\r\n      self.uri = self.baseUrl\r\n    } else {\r\n      self.uri = self.baseUrl + '/' + self.uri\r\n    }\r\n    delete self.baseUrl\r\n  }\r\n\r\n  // A URI is needed by this point, emit error if we haven't been able to get one\r\n  if (!self.uri) {\r\n    return self.emit('error', new Error('options.uri is a required argument'))\r\n  }\r\n\r\n  // If a string URI/URL was given, parse it into a URL object\r\n  if (typeof self.uri === 'string') {\r\n    self.uri = url.parse(self.uri)\r\n  }\r\n\r\n  // Some URL objects are not from a URL parsed string and need href added\r\n  if (!self.uri.href) {\r\n    self.uri.href = url.format(self.uri)\r\n  }\r\n\r\n  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\r\n  if (self.uri.protocol === 'unix:') {\r\n    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))\r\n  }\r\n\r\n  // Support Unix Sockets\r\n  if (self.uri.host === 'unix') {\r\n    self.enableUnixSocket()\r\n  }\r\n\r\n  if (self.strictSSL === false) {\r\n    self.rejectUnauthorized = false\r\n  }\r\n\r\n  if (!self.uri.pathname) { self.uri.pathname = '/' }\r\n\r\n  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {\r\n    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\r\n    // Detect and reject it as soon as possible\r\n    var faultyUri = url.format(self.uri)\r\n    var message = 'Invalid URI \"' + faultyUri + '\"'\r\n    if (Object.keys(options).length === 0) {\r\n      // No option ? This can be the sign of a redirect\r\n      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\r\n      // they should be warned that it can be caused by a redirection (can save some hair)\r\n      message += '. This can be caused by a crappy redirection.'\r\n    }\r\n    // This error was fatal\r\n    self.abort()\r\n    return self.emit('error', new Error(message))\r\n  }\r\n\r\n  if (!self.hasOwnProperty('proxy')) {\r\n    self.proxy = getProxyFromURI(self.uri)\r\n  }\r\n\r\n  self.tunnel = self._tunnel.isEnabled()\r\n  if (self.proxy) {\r\n    self._tunnel.setup(options)\r\n  }\r\n\r\n  self._redirect.onRequest(options)\r\n\r\n  self.setHost = false\r\n  if (!self.hasHeader('host')) {\r\n    var hostHeaderName = self.originalHostHeaderName || 'host'\r\n    self.setHeader(hostHeaderName, self.uri.host)\r\n    // Drop :port suffix from Host header if known protocol.\r\n    if (self.uri.port) {\r\n      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||\r\n          (self.uri.port === '443' && self.uri.protocol === 'https:')) {\r\n        self.setHeader(hostHeaderName, self.uri.hostname)\r\n      }\r\n    }\r\n    self.setHost = true\r\n  }\r\n\r\n  self.jar(self._jar || options.jar)\r\n\r\n  if (!self.uri.port) {\r\n    if (self.uri.protocol === 'http:') { self.uri.port = 80 } else if (self.uri.protocol === 'https:') { self.uri.port = 443 }\r\n  }\r\n\r\n  if (self.proxy && !self.tunnel) {\r\n    self.port = self.proxy.port\r\n    self.host = self.proxy.hostname\r\n  } else {\r\n    self.port = self.uri.port\r\n    self.host = self.uri.hostname\r\n  }\r\n\r\n  if (options.form) {\r\n    self.form(options.form)\r\n  }\r\n\r\n  if (options.formData) {\r\n    var formData = options.formData\r\n    var requestForm = self.form()\r\n    var appendFormValue = function (key, value) {\r\n      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\r\n        requestForm.append(key, value.value, value.options)\r\n      } else {\r\n        requestForm.append(key, value)\r\n      }\r\n    }\r\n    for (var formKey in formData) {\r\n      if (formData.hasOwnProperty(formKey)) {\r\n        var formValue = formData[formKey]\r\n        if (formValue instanceof Array) {\r\n          for (var j = 0; j < formValue.length; j++) {\r\n            appendFormValue(formKey, formValue[j])\r\n          }\r\n        } else {\r\n          appendFormValue(formKey, formValue)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (options.qs) {\r\n    self.qs(options.qs)\r\n  }\r\n\r\n  if (self.uri.path) {\r\n    self.path = self.uri.path\r\n  } else {\r\n    self.path = self.uri.pathname + (self.uri.search || '')\r\n  }\r\n\r\n  if (self.path.length === 0) {\r\n    self.path = '/'\r\n  }\r\n\r\n  // Auth must happen last in case signing is dependent on other headers\r\n  if (options.aws) {\r\n    self.aws(options.aws)\r\n  }\r\n\r\n  if (options.hawk) {\r\n    self.hawk(options.hawk)\r\n  }\r\n\r\n  if (options.httpSignature) {\r\n    self.httpSignature(options.httpSignature)\r\n  }\r\n\r\n  if (options.auth) {\r\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\r\n      options.auth.user = options.auth.username\r\n    }\r\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\r\n      options.auth.pass = options.auth.password\r\n    }\r\n\r\n    self.auth(\r\n      options.auth.user,\r\n      options.auth.pass,\r\n      options.auth.sendImmediately,\r\n      options.auth.bearer\r\n    )\r\n  }\r\n\r\n  if (self.gzip && !self.hasHeader('accept-encoding')) {\r\n    self.setHeader('accept-encoding', 'gzip, deflate')\r\n  }\r\n\r\n  if (self.uri.auth && !self.hasHeader('authorization')) {\r\n    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) })\r\n    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)\r\n  }\r\n\r\n  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\r\n    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) })\r\n    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))\r\n    self.setHeader('proxy-authorization', authHeader)\r\n  }\r\n\r\n  if (self.proxy && !self.tunnel) {\r\n    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\r\n  }\r\n\r\n  if (options.json) {\r\n    self.json(options.json)\r\n  }\r\n  if (options.multipart) {\r\n    self.multipart(options.multipart)\r\n  }\r\n\r\n  if (options.time) {\r\n    self.timing = true\r\n\r\n    // NOTE: elapsedTime is deprecated in favor of .timings\r\n    self.elapsedTime = self.elapsedTime || 0\r\n  }\r\n\r\n  function setContentLength () {\r\n    if (isTypedArray(self.body)) {\r\n      self.body = Buffer.from(self.body)\r\n    }\r\n\r\n    if (!self.hasHeader('content-length')) {\r\n      var length\r\n      if (typeof self.body === 'string') {\r\n        length = Buffer.byteLength(self.body)\r\n      } else if (Array.isArray(self.body)) {\r\n        length = self.body.reduce(function (a, b) { return a + b.length }, 0)\r\n      } else {\r\n        length = self.body.length\r\n      }\r\n\r\n      if (length) {\r\n        self.setHeader('content-length', length)\r\n      } else {\r\n        self.emit('error', new Error('Argument error, options.body.'))\r\n      }\r\n    }\r\n  }\r\n  if (self.body && !isstream(self.body)) {\r\n    setContentLength()\r\n  }\r\n\r\n  if (options.oauth) {\r\n    self.oauth(options.oauth)\r\n  } else if (self._oauth.params && self.hasHeader('authorization')) {\r\n    self.oauth(self._oauth.params)\r\n  }\r\n\r\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\r\n  var defaultModules = {'http:': http, 'https:': https}\r\n  var httpModules = self.httpModules || {}\r\n\r\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\r\n\r\n  if (!self.httpModule) {\r\n    return self.emit('error', new Error('Invalid protocol: ' + protocol))\r\n  }\r\n\r\n  if (options.ca) {\r\n    self.ca = options.ca\r\n  }\r\n\r\n  if (!self.agent) {\r\n    if (options.agentOptions) {\r\n      self.agentOptions = options.agentOptions\r\n    }\r\n\r\n    if (options.agentClass) {\r\n      self.agentClass = options.agentClass\r\n    } else if (options.forever) {\r\n      var v = version()\r\n      // use ForeverAgent in node 0.10- only\r\n      if (v.major === 0 && v.minor <= 10) {\r\n        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\r\n      } else {\r\n        self.agentClass = self.httpModule.Agent\r\n        self.agentOptions = self.agentOptions || {}\r\n        self.agentOptions.keepAlive = true\r\n      }\r\n    } else {\r\n      self.agentClass = self.httpModule.Agent\r\n    }\r\n  }\r\n\r\n  if (self.pool === false) {\r\n    self.agent = false\r\n  } else {\r\n    self.agent = self.agent || self.getNewAgent()\r\n  }\r\n\r\n  self.on('pipe', function (src) {\r\n    if (self.ntick && self._started) {\r\n      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))\r\n    }\r\n    self.src = src\r\n    if (isReadStream(src)) {\r\n      if (!self.hasHeader('content-type')) {\r\n        self.setHeader('content-type', mime.lookup(src.path))\r\n      }\r\n    } else {\r\n      if (src.headers) {\r\n        for (var i in src.headers) {\r\n          if (!self.hasHeader(i)) {\r\n            self.setHeader(i, src.headers[i])\r\n          }\r\n        }\r\n      }\r\n      if (self._json && !self.hasHeader('content-type')) {\r\n        self.setHeader('content-type', 'application/json')\r\n      }\r\n      if (src.method && !self.explicitMethod) {\r\n        self.method = src.method\r\n      }\r\n    }\r\n\r\n  // self.on('pipe', function () {\r\n  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\r\n  // })\r\n  })\r\n\r\n  defer(function () {\r\n    if (self._aborted) {\r\n      return\r\n    }\r\n\r\n    var end = function () {\r\n      if (self._form) {\r\n        if (!self._auth.hasAuth) {\r\n          self._form.pipe(self)\r\n        } else if (self._auth.hasAuth && self._auth.sentAuth) {\r\n          self._form.pipe(self)\r\n        }\r\n      }\r\n      if (self._multipart && self._multipart.chunked) {\r\n        self._multipart.body.pipe(self)\r\n      }\r\n      if (self.body) {\r\n        if (isstream(self.body)) {\r\n          self.body.pipe(self)\r\n        } else {\r\n          setContentLength()\r\n          if (Array.isArray(self.body)) {\r\n            self.body.forEach(function (part) {\r\n              self.write(part)\r\n            })\r\n          } else {\r\n            self.write(self.body)\r\n          }\r\n          self.end()\r\n        }\r\n      } else if (self.requestBodyStream) {\r\n        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')\r\n        self.requestBodyStream.pipe(self)\r\n      } else if (!self.src) {\r\n        if (self._auth.hasAuth && !self._auth.sentAuth) {\r\n          self.end()\r\n          return\r\n        }\r\n        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\r\n          self.setHeader('content-length', 0)\r\n        }\r\n        self.end()\r\n      }\r\n    }\r\n\r\n    if (self._form && !self.hasHeader('content-length')) {\r\n      // Before ending the request, we had to compute the length of the whole form, asyncly\r\n      self.setHeader(self._form.getHeaders(), true)\r\n      self._form.getLength(function (err, length) {\r\n        if (!err && !isNaN(length)) {\r\n          self.setHeader('content-length', length)\r\n        }\r\n        end()\r\n      })\r\n    } else {\r\n      end()\r\n    }\r\n\r\n    self.ntick = true\r\n  })\r\n}\r\n\r\nRequest.prototype.getNewAgent = function () {\r\n  var self = this\r\n  var Agent = self.agentClass\r\n  var options = {}\r\n  if (self.agentOptions) {\r\n    for (var i in self.agentOptions) {\r\n      options[i] = self.agentOptions[i]\r\n    }\r\n  }\r\n  if (self.ca) {\r\n    options.ca = self.ca\r\n  }\r\n  if (self.ciphers) {\r\n    options.ciphers = self.ciphers\r\n  }\r\n  if (self.secureProtocol) {\r\n    options.secureProtocol = self.secureProtocol\r\n  }\r\n  if (self.secureOptions) {\r\n    options.secureOptions = self.secureOptions\r\n  }\r\n  if (typeof self.rejectUnauthorized !== 'undefined') {\r\n    options.rejectUnauthorized = self.rejectUnauthorized\r\n  }\r\n\r\n  if (self.cert && self.key) {\r\n    options.key = self.key\r\n    options.cert = self.cert\r\n  }\r\n\r\n  if (self.pfx) {\r\n    options.pfx = self.pfx\r\n  }\r\n\r\n  if (self.passphrase) {\r\n    options.passphrase = self.passphrase\r\n  }\r\n\r\n  var poolKey = ''\r\n\r\n  // different types of agents are in different pools\r\n  if (Agent !== self.httpModule.Agent) {\r\n    poolKey += Agent.name\r\n  }\r\n\r\n  // ca option is only relevant if proxy or destination are https\r\n  var proxy = self.proxy\r\n  if (typeof proxy === 'string') {\r\n    proxy = url.parse(proxy)\r\n  }\r\n  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\r\n\r\n  if (isHttps) {\r\n    if (options.ca) {\r\n      if (poolKey) {\r\n        poolKey += ':'\r\n      }\r\n      poolKey += options.ca\r\n    }\r\n\r\n    if (typeof options.rejectUnauthorized !== 'undefined') {\r\n      if (poolKey) {\r\n        poolKey += ':'\r\n      }\r\n      poolKey += options.rejectUnauthorized\r\n    }\r\n\r\n    if (options.cert) {\r\n      if (poolKey) {\r\n        poolKey += ':'\r\n      }\r\n      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')\r\n    }\r\n\r\n    if (options.pfx) {\r\n      if (poolKey) {\r\n        poolKey += ':'\r\n      }\r\n      poolKey += options.pfx.toString('ascii')\r\n    }\r\n\r\n    if (options.ciphers) {\r\n      if (poolKey) {\r\n        poolKey += ':'\r\n      }\r\n      poolKey += options.ciphers\r\n    }\r\n\r\n    if (options.secureProtocol) {\r\n      if (poolKey) {\r\n        poolKey += ':'\r\n      }\r\n      poolKey += options.secureProtocol\r\n    }\r\n\r\n    if (options.secureOptions) {\r\n      if (poolKey) {\r\n        poolKey += ':'\r\n      }\r\n      poolKey += options.secureOptions\r\n    }\r\n  }\r\n\r\n  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\r\n    // not doing anything special.  Use the globalAgent\r\n    return self.httpModule.globalAgent\r\n  }\r\n\r\n  // we're using a stored agent.  Make sure it's protocol-specific\r\n  poolKey = self.uri.protocol + poolKey\r\n\r\n  // generate a new agent for this setting if none yet exists\r\n  if (!self.pool[poolKey]) {\r\n    self.pool[poolKey] = new Agent(options)\r\n    // properly set maxSockets on new agents\r\n    if (self.pool.maxSockets) {\r\n      self.pool[poolKey].maxSockets = self.pool.maxSockets\r\n    }\r\n  }\r\n\r\n  return self.pool[poolKey]\r\n}\r\n\r\nRequest.prototype.start = function () {\r\n  // start() is called once we are ready to send the outgoing HTTP request.\r\n  // this is usually called on the first write(), end() or on nextTick()\r\n  var self = this\r\n\r\n  if (self.timing) {\r\n    // All timings will be relative to this request's startTime.  In order to do this,\r\n    // we need to capture the wall-clock start time (via Date), immediately followed\r\n    // by the high-resolution timer (via now()).  While these two won't be set\r\n    // at the _exact_ same time, they should be close enough to be able to calculate\r\n    // high-resolution, monotonically non-decreasing timestamps relative to startTime.\r\n    var startTime = new Date().getTime()\r\n    var startTimeNow = now()\r\n  }\r\n\r\n  if (self._aborted) {\r\n    return\r\n  }\r\n\r\n  self._started = true\r\n  self.method = self.method || 'GET'\r\n  self.href = self.uri.href\r\n\r\n  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\r\n    self.setHeader('content-length', self.src.stat.size)\r\n  }\r\n  if (self._aws) {\r\n    self.aws(self._aws, true)\r\n  }\r\n\r\n  // We have a method named auth, which is completely different from the http.request\r\n  // auth option.  If we don't remove it, we're gonna have a bad time.\r\n  var reqOptions = copy(self)\r\n  delete reqOptions.auth\r\n\r\n  debug('make request', self.uri.href)\r\n\r\n  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we\r\n  // should delete it for now since we handle timeouts manually for better\r\n  // consistency with node versions before v6.8.0\r\n  delete reqOptions.timeout\r\n\r\n  try {\r\n    self.req = self.httpModule.request(reqOptions)\r\n  } catch (err) {\r\n    self.emit('error', err)\r\n    return\r\n  }\r\n\r\n  if (self.timing) {\r\n    self.startTime = startTime\r\n    self.startTimeNow = startTimeNow\r\n\r\n    // Timing values will all be relative to startTime (by comparing to startTimeNow\r\n    // so we have an accurate clock)\r\n    self.timings = {}\r\n  }\r\n\r\n  var timeout\r\n  if (self.timeout && !self.timeoutTimer) {\r\n    if (self.timeout < 0) {\r\n      timeout = 0\r\n    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {\r\n      timeout = self.timeout\r\n    }\r\n  }\r\n\r\n  self.req.on('response', self.onRequestResponse.bind(self))\r\n  self.req.on('error', self.onRequestError.bind(self))\r\n  self.req.on('drain', function () {\r\n    self.emit('drain')\r\n  })\r\n\r\n  self.req.on('socket', function (socket) {\r\n    // `._connecting` was the old property which was made public in node v6.1.0\r\n    var isConnecting = socket._connecting || socket.connecting\r\n    if (self.timing) {\r\n      self.timings.socket = now() - self.startTimeNow\r\n\r\n      if (isConnecting) {\r\n        var onLookupTiming = function () {\r\n          self.timings.lookup = now() - self.startTimeNow\r\n        }\r\n\r\n        var onConnectTiming = function () {\r\n          self.timings.connect = now() - self.startTimeNow\r\n        }\r\n\r\n        socket.once('lookup', onLookupTiming)\r\n        socket.once('connect', onConnectTiming)\r\n\r\n        // clean up timing event listeners if needed on error\r\n        self.req.once('error', function () {\r\n          socket.removeListener('lookup', onLookupTiming)\r\n          socket.removeListener('connect', onConnectTiming)\r\n        })\r\n      }\r\n    }\r\n\r\n    var setReqTimeout = function () {\r\n      // This timeout sets the amount of time to wait *between* bytes sent\r\n      // from the server once connected.\r\n      //\r\n      // In particular, it's useful for erroring if the server fails to send\r\n      // data halfway through streaming a response.\r\n      self.req.setTimeout(timeout, function () {\r\n        if (self.req) {\r\n          self.abort()\r\n          var e = new Error('ESOCKETTIMEDOUT')\r\n          e.code = 'ESOCKETTIMEDOUT'\r\n          e.connect = false\r\n          self.emit('error', e)\r\n        }\r\n      })\r\n    }\r\n    if (timeout !== undefined) {\r\n      // Only start the connection timer if we're actually connecting a new\r\n      // socket, otherwise if we're already connected (because this is a\r\n      // keep-alive connection) do not bother. This is important since we won't\r\n      // get a 'connect' event for an already connected socket.\r\n      if (isConnecting) {\r\n        var onReqSockConnect = function () {\r\n          socket.removeListener('connect', onReqSockConnect)\r\n          self.clearTimeout()\r\n          setReqTimeout()\r\n        }\r\n\r\n        socket.on('connect', onReqSockConnect)\r\n\r\n        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err\r\n          socket.removeListener('connect', onReqSockConnect)\r\n        })\r\n\r\n        // Set a timeout in memory - this block will throw if the server takes more\r\n        // than `timeout` to write the HTTP status and headers (corresponding to\r\n        // the on('response') event on the client). NB: this measures wall-clock\r\n        // time, not the time between bytes sent by the server.\r\n        self.timeoutTimer = setTimeout(function () {\r\n          socket.removeListener('connect', onReqSockConnect)\r\n          self.abort()\r\n          var e = new Error('ETIMEDOUT')\r\n          e.code = 'ETIMEDOUT'\r\n          e.connect = true\r\n          self.emit('error', e)\r\n        }, timeout)\r\n      } else {\r\n        // We're already connected\r\n        setReqTimeout()\r\n      }\r\n    }\r\n    self.emit('socket', socket)\r\n  })\r\n\r\n  self.emit('request', self.req)\r\n}\r\n\r\nRequest.prototype.onRequestError = function (error) {\r\n  var self = this\r\n  if (self._aborted) {\r\n    return\r\n  }\r\n  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&\r\n    self.agent.addRequestNoreuse) {\r\n    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\r\n    self.start()\r\n    self.req.end()\r\n    return\r\n  }\r\n  self.clearTimeout()\r\n  self.emit('error', error)\r\n}\r\n\r\nRequest.prototype.onRequestResponse = function (response) {\r\n  var self = this\r\n\r\n  if (self.timing) {\r\n    self.timings.response = now() - self.startTimeNow\r\n  }\r\n\r\n  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)\r\n  response.on('end', function () {\r\n    if (self.timing) {\r\n      self.timings.end = now() - self.startTimeNow\r\n      response.timingStart = self.startTime\r\n\r\n      // fill in the blanks for any periods that didn't trigger, such as\r\n      // no lookup or connect due to keep alive\r\n      if (!self.timings.socket) {\r\n        self.timings.socket = 0\r\n      }\r\n      if (!self.timings.lookup) {\r\n        self.timings.lookup = self.timings.socket\r\n      }\r\n      if (!self.timings.connect) {\r\n        self.timings.connect = self.timings.lookup\r\n      }\r\n      if (!self.timings.response) {\r\n        self.timings.response = self.timings.connect\r\n      }\r\n\r\n      debug('elapsed time', self.timings.end)\r\n\r\n      // elapsedTime includes all redirects\r\n      self.elapsedTime += Math.round(self.timings.end)\r\n\r\n      // NOTE: elapsedTime is deprecated in favor of .timings\r\n      response.elapsedTime = self.elapsedTime\r\n\r\n      // timings is just for the final fetch\r\n      response.timings = self.timings\r\n\r\n      // pre-calculate phase timings as well\r\n      response.timingPhases = {\r\n        wait: self.timings.socket,\r\n        dns: self.timings.lookup - self.timings.socket,\r\n        tcp: self.timings.connect - self.timings.lookup,\r\n        firstByte: self.timings.response - self.timings.connect,\r\n        download: self.timings.end - self.timings.response,\r\n        total: self.timings.end\r\n      }\r\n    }\r\n    debug('response end', self.uri.href, response.statusCode, response.headers)\r\n  })\r\n\r\n  if (self._aborted) {\r\n    debug('aborted', self.uri.href)\r\n    response.resume()\r\n    return\r\n  }\r\n\r\n  self.response = response\r\n  response.request = self\r\n  response.toJSON = responseToJSON\r\n\r\n  // XXX This is different on 0.10, because SSL is strict by default\r\n  if (self.httpModule === https &&\r\n    self.strictSSL && (!response.hasOwnProperty('socket') ||\r\n    !response.socket.authorized)) {\r\n    debug('strict ssl error', self.uri.href)\r\n    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'\r\n    self.emit('error', new Error('SSL Error: ' + sslErr))\r\n    return\r\n  }\r\n\r\n  // Save the original host before any redirect (if it changes, we need to\r\n  // remove any authorization headers).  Also remember the case of the header\r\n  // name because lots of broken servers expect Host instead of host and we\r\n  // want the caller to be able to specify this.\r\n  self.originalHost = self.getHeader('host')\r\n  if (!self.originalHostHeaderName) {\r\n    self.originalHostHeaderName = self.hasHeader('host')\r\n  }\r\n  if (self.setHost) {\r\n    self.removeHeader('host')\r\n  }\r\n  self.clearTimeout()\r\n\r\n  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar\r\n  var addCookie = function (cookie) {\r\n    // set the cookie if it's domain in the href's domain.\r\n    try {\r\n      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})\r\n    } catch (e) {\r\n      self.emit('error', e)\r\n    }\r\n  }\r\n\r\n  response.caseless = caseless(response.headers)\r\n\r\n  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {\r\n    var headerName = response.caseless.has('set-cookie')\r\n    if (Array.isArray(response.headers[headerName])) {\r\n      response.headers[headerName].forEach(addCookie)\r\n    } else {\r\n      addCookie(response.headers[headerName])\r\n    }\r\n  }\r\n\r\n  if (self._redirect.onResponse(response)) {\r\n    return // Ignore the rest of the response\r\n  } else {\r\n    // Be a good stream and emit end when the response is finished.\r\n    // Hack to emit end on close because of a core bug that never fires end\r\n    response.on('close', function () {\r\n      if (!self._ended) {\r\n        self.response.emit('end')\r\n      }\r\n    })\r\n\r\n    response.once('end', function () {\r\n      self._ended = true\r\n    })\r\n\r\n    var noBody = function (code) {\r\n      return (\r\n        self.method === 'HEAD' ||\r\n        // Informational\r\n        (code >= 100 && code < 200) ||\r\n        // No Content\r\n        code === 204 ||\r\n        // Not Modified\r\n        code === 304\r\n      )\r\n    }\r\n\r\n    var responseContent\r\n    if (self.gzip && !noBody(response.statusCode)) {\r\n      var contentEncoding = response.headers['content-encoding'] || 'identity'\r\n      contentEncoding = contentEncoding.trim().toLowerCase()\r\n\r\n      // Be more lenient with decoding compressed responses, since (very rarely)\r\n      // servers send slightly invalid gzip responses that are still accepted\r\n      // by common browsers.\r\n      // Always using Z_SYNC_FLUSH is what cURL does.\r\n      var zlibOptions = {\r\n        flush: zlib.Z_SYNC_FLUSH,\r\n        finishFlush: zlib.Z_SYNC_FLUSH\r\n      }\r\n\r\n      if (contentEncoding === 'gzip') {\r\n        responseContent = zlib.createGunzip(zlibOptions)\r\n        response.pipe(responseContent)\r\n      } else if (contentEncoding === 'deflate') {\r\n        responseContent = zlib.createInflate(zlibOptions)\r\n        response.pipe(responseContent)\r\n      } else {\r\n        // Since previous versions didn't check for Content-Encoding header,\r\n        // ignore any invalid values to preserve backwards-compatibility\r\n        if (contentEncoding !== 'identity') {\r\n          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)\r\n        }\r\n        responseContent = response\r\n      }\r\n    } else {\r\n      responseContent = response\r\n    }\r\n\r\n    if (self.encoding) {\r\n      if (self.dests.length !== 0) {\r\n        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')\r\n      } else {\r\n        responseContent.setEncoding(self.encoding)\r\n      }\r\n    }\r\n\r\n    if (self._paused) {\r\n      responseContent.pause()\r\n    }\r\n\r\n    self.responseContent = responseContent\r\n\r\n    self.emit('response', response)\r\n\r\n    self.dests.forEach(function (dest) {\r\n      self.pipeDest(dest)\r\n    })\r\n\r\n    responseContent.on('data', function (chunk) {\r\n      if (self.timing && !self.responseStarted) {\r\n        self.responseStartTime = (new Date()).getTime()\r\n\r\n        // NOTE: responseStartTime is deprecated in favor of .timings\r\n        response.responseStartTime = self.responseStartTime\r\n      }\r\n      self._destdata = true\r\n      self.emit('data', chunk)\r\n    })\r\n    responseContent.once('end', function (chunk) {\r\n      self.emit('end', chunk)\r\n    })\r\n    responseContent.on('error', function (error) {\r\n      self.emit('error', error)\r\n    })\r\n    responseContent.on('close', function () { self.emit('close') })\r\n\r\n    if (self.callback) {\r\n      self.readResponseBody(response)\r\n    } else { // if no callback\r\n      self.on('end', function () {\r\n        if (self._aborted) {\r\n          debug('aborted', self.uri.href)\r\n          return\r\n        }\r\n        self.emit('complete', response)\r\n      })\r\n    }\r\n  }\r\n  debug('finish init function', self.uri.href)\r\n}\r\n\r\nRequest.prototype.readResponseBody = function (response) {\r\n  var self = this\r\n  debug(\"reading response's body\")\r\n  var buffers = []\r\n  var bufferLength = 0\r\n  var strings = []\r\n\r\n  self.on('data', function (chunk) {\r\n    if (!Buffer.isBuffer(chunk)) {\r\n      strings.push(chunk)\r\n    } else if (chunk.length) {\r\n      bufferLength += chunk.length\r\n      buffers.push(chunk)\r\n    }\r\n  })\r\n  self.on('end', function () {\r\n    debug('end event', self.uri.href)\r\n    if (self._aborted) {\r\n      debug('aborted', self.uri.href)\r\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\r\n      // This can lead to leaky behavior if the user retains a reference to the request object.\r\n      buffers = []\r\n      bufferLength = 0\r\n      return\r\n    }\r\n\r\n    if (bufferLength) {\r\n      debug('has body', self.uri.href, bufferLength)\r\n      response.body = Buffer.concat(buffers, bufferLength)\r\n      if (self.encoding !== null) {\r\n        response.body = response.body.toString(self.encoding)\r\n      }\r\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\r\n      // This can lead to leaky behavior if the user retains a reference to the request object.\r\n      buffers = []\r\n      bufferLength = 0\r\n    } else if (strings.length) {\r\n      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\r\n      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\r\n      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\r\n        strings[0] = strings[0].substring(1)\r\n      }\r\n      response.body = strings.join('')\r\n    }\r\n\r\n    if (self._json) {\r\n      try {\r\n        response.body = JSON.parse(response.body, self._jsonReviver)\r\n      } catch (e) {\r\n        debug('invalid JSON received', self.uri.href)\r\n      }\r\n    }\r\n    debug('emitting complete', self.uri.href)\r\n    if (typeof response.body === 'undefined' && !self._json) {\r\n      response.body = self.encoding === null ? Buffer.alloc(0) : ''\r\n    }\r\n    self.emit('complete', response, response.body)\r\n  })\r\n}\r\n\r\nRequest.prototype.abort = function () {\r\n  var self = this\r\n  self._aborted = true\r\n\r\n  if (self.req) {\r\n    self.req.abort()\r\n  } else if (self.response) {\r\n    self.response.destroy()\r\n  }\r\n\r\n  self.clearTimeout()\r\n  self.emit('abort')\r\n}\r\n\r\nRequest.prototype.pipeDest = function (dest) {\r\n  var self = this\r\n  var response = self.response\r\n  // Called after the response is received\r\n  if (dest.headers && !dest.headersSent) {\r\n    if (response.caseless.has('content-type')) {\r\n      var ctname = response.caseless.has('content-type')\r\n      if (dest.setHeader) {\r\n        dest.setHeader(ctname, response.headers[ctname])\r\n      } else {\r\n        dest.headers[ctname] = response.headers[ctname]\r\n      }\r\n    }\r\n\r\n    if (response.caseless.has('content-length')) {\r\n      var clname = response.caseless.has('content-length')\r\n      if (dest.setHeader) {\r\n        dest.setHeader(clname, response.headers[clname])\r\n      } else {\r\n        dest.headers[clname] = response.headers[clname]\r\n      }\r\n    }\r\n  }\r\n  if (dest.setHeader && !dest.headersSent) {\r\n    for (var i in response.headers) {\r\n      // If the response content is being decoded, the Content-Encoding header\r\n      // of the response doesn't represent the piped content, so don't pass it.\r\n      if (!self.gzip || i !== 'content-encoding') {\r\n        dest.setHeader(i, response.headers[i])\r\n      }\r\n    }\r\n    dest.statusCode = response.statusCode\r\n  }\r\n  if (self.pipefilter) {\r\n    self.pipefilter(response, dest)\r\n  }\r\n}\r\n\r\nRequest.prototype.qs = function (q, clobber) {\r\n  var self = this\r\n  var base\r\n  if (!clobber && self.uri.query) {\r\n    base = self._qs.parse(self.uri.query)\r\n  } else {\r\n    base = {}\r\n  }\r\n\r\n  for (var i in q) {\r\n    base[i] = q[i]\r\n  }\r\n\r\n  var qs = self._qs.stringify(base)\r\n\r\n  if (qs === '') {\r\n    return self\r\n  }\r\n\r\n  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)\r\n  self.url = self.uri\r\n  self.path = self.uri.path\r\n\r\n  if (self.uri.host === 'unix') {\r\n    self.enableUnixSocket()\r\n  }\r\n\r\n  return self\r\n}\r\nRequest.prototype.form = function (form) {\r\n  var self = this\r\n  if (form) {\r\n    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\r\n      self.setHeader('content-type', 'application/x-www-form-urlencoded')\r\n    }\r\n    self.body = (typeof form === 'string')\r\n      ? self._qs.rfc3986(form.toString('utf8'))\r\n      : self._qs.stringify(form).toString('utf8')\r\n    return self\r\n  }\r\n  // create form-data object\r\n  self._form = new FormData()\r\n  self._form.on('error', function (err) {\r\n    err.message = 'form-data: ' + err.message\r\n    self.emit('error', err)\r\n    self.abort()\r\n  })\r\n  return self._form\r\n}\r\nRequest.prototype.multipart = function (multipart) {\r\n  var self = this\r\n\r\n  self._multipart.onRequest(multipart)\r\n\r\n  if (!self._multipart.chunked) {\r\n    self.body = self._multipart.body\r\n  }\r\n\r\n  return self\r\n}\r\nRequest.prototype.json = function (val) {\r\n  var self = this\r\n\r\n  if (!self.hasHeader('accept')) {\r\n    self.setHeader('accept', 'application/json')\r\n  }\r\n\r\n  if (typeof self.jsonReplacer === 'function') {\r\n    self._jsonReplacer = self.jsonReplacer\r\n  }\r\n\r\n  self._json = true\r\n  if (typeof val === 'boolean') {\r\n    if (self.body !== undefined) {\r\n      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\r\n        self.body = safeStringify(self.body, self._jsonReplacer)\r\n      } else {\r\n        self.body = self._qs.rfc3986(self.body)\r\n      }\r\n      if (!self.hasHeader('content-type')) {\r\n        self.setHeader('content-type', 'application/json')\r\n      }\r\n    }\r\n  } else {\r\n    self.body = safeStringify(val, self._jsonReplacer)\r\n    if (!self.hasHeader('content-type')) {\r\n      self.setHeader('content-type', 'application/json')\r\n    }\r\n  }\r\n\r\n  if (typeof self.jsonReviver === 'function') {\r\n    self._jsonReviver = self.jsonReviver\r\n  }\r\n\r\n  return self\r\n}\r\nRequest.prototype.getHeader = function (name, headers) {\r\n  var self = this\r\n  var result, re, match\r\n  if (!headers) {\r\n    headers = self.headers\r\n  }\r\n  Object.keys(headers).forEach(function (key) {\r\n    if (key.length !== name.length) {\r\n      return\r\n    }\r\n    re = new RegExp(name, 'i')\r\n    match = key.match(re)\r\n    if (match) {\r\n      result = headers[key]\r\n    }\r\n  })\r\n  return result\r\n}\r\nRequest.prototype.enableUnixSocket = function () {\r\n  // Get the socket & request paths from the URL\r\n  var unixParts = this.uri.path.split(':')\r\n  var host = unixParts[0]\r\n  var path = unixParts[1]\r\n  // Apply unix properties to request\r\n  this.socketPath = host\r\n  this.uri.pathname = path\r\n  this.uri.path = path\r\n  this.uri.host = host\r\n  this.uri.hostname = host\r\n  this.uri.isUnix = true\r\n}\r\n\r\nRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\r\n  var self = this\r\n\r\n  self._auth.onRequest(user, pass, sendImmediately, bearer)\r\n\r\n  return self\r\n}\r\nRequest.prototype.aws = function (opts, now) {\r\n  var self = this\r\n\r\n  if (!now) {\r\n    self._aws = opts\r\n    return self\r\n  }\r\n\r\n  if (opts.sign_version === 4 || opts.sign_version === '4') {\r\n    // use aws4\r\n    var options = {\r\n      host: self.uri.host,\r\n      path: self.uri.path,\r\n      method: self.method,\r\n      headers: self.headers,\r\n      body: self.body\r\n    }\r\n    if (opts.service) {\r\n      options.service = opts.service\r\n    }\r\n    var signRes = aws4.sign(options, {\r\n      accessKeyId: opts.key,\r\n      secretAccessKey: opts.secret,\r\n      sessionToken: opts.session\r\n    })\r\n    self.setHeader('authorization', signRes.headers.Authorization)\r\n    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])\r\n    if (signRes.headers['X-Amz-Security-Token']) {\r\n      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token'])\r\n    }\r\n  } else {\r\n    // default: use aws-sign2\r\n    var date = new Date()\r\n    self.setHeader('date', date.toUTCString())\r\n    var auth = {\r\n      key: opts.key,\r\n      secret: opts.secret,\r\n      verb: self.method.toUpperCase(),\r\n      date: date,\r\n      contentType: self.getHeader('content-type') || '',\r\n      md5: self.getHeader('content-md5') || '',\r\n      amazonHeaders: aws2.canonicalizeHeaders(self.headers)\r\n    }\r\n    var path = self.uri.path\r\n    if (opts.bucket && path) {\r\n      auth.resource = '/' + opts.bucket + path\r\n    } else if (opts.bucket && !path) {\r\n      auth.resource = '/' + opts.bucket\r\n    } else if (!opts.bucket && path) {\r\n      auth.resource = path\r\n    } else if (!opts.bucket && !path) {\r\n      auth.resource = '/'\r\n    }\r\n    auth.resource = aws2.canonicalizeResource(auth.resource)\r\n    self.setHeader('authorization', aws2.authorization(auth))\r\n  }\r\n\r\n  return self\r\n}\r\nRequest.prototype.httpSignature = function (opts) {\r\n  var self = this\r\n  httpSignature.signRequest({\r\n    getHeader: function (header) {\r\n      return self.getHeader(header, self.headers)\r\n    },\r\n    setHeader: function (header, value) {\r\n      self.setHeader(header, value)\r\n    },\r\n    method: self.method,\r\n    path: self.path\r\n  }, opts)\r\n  debug('httpSignature authorization', self.getHeader('authorization'))\r\n\r\n  return self\r\n}\r\nRequest.prototype.hawk = function (opts) {\r\n  var self = this\r\n  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts))\r\n}\r\nRequest.prototype.oauth = function (_oauth) {\r\n  var self = this\r\n\r\n  self._oauth.onRequest(_oauth)\r\n\r\n  return self\r\n}\r\n\r\nRequest.prototype.jar = function (jar) {\r\n  var self = this\r\n  var cookies\r\n\r\n  if (self._redirect.redirectsFollowed === 0) {\r\n    self.originalCookieHeader = self.getHeader('cookie')\r\n  }\r\n\r\n  if (!jar) {\r\n    // disable cookies\r\n    cookies = false\r\n    self._disableCookies = true\r\n  } else {\r\n    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar\r\n    var urihref = self.uri.href\r\n    // fetch cookie in the Specified host\r\n    if (targetCookieJar) {\r\n      cookies = targetCookieJar.getCookieString(urihref)\r\n    }\r\n  }\r\n\r\n  // if need cookie and cookie is not empty\r\n  if (cookies && cookies.length) {\r\n    if (self.originalCookieHeader) {\r\n      // Don't overwrite existing Cookie header\r\n      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)\r\n    } else {\r\n      self.setHeader('cookie', cookies)\r\n    }\r\n  }\r\n  self._jar = jar\r\n  return self\r\n}\r\n\r\n// Stream API\r\nRequest.prototype.pipe = function (dest, opts) {\r\n  var self = this\r\n\r\n  if (self.response) {\r\n    if (self._destdata) {\r\n      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))\r\n    } else if (self._ended) {\r\n      self.emit('error', new Error('You cannot pipe after the response has been ended.'))\r\n    } else {\r\n      stream.Stream.prototype.pipe.call(self, dest, opts)\r\n      self.pipeDest(dest)\r\n      return dest\r\n    }\r\n  } else {\r\n    self.dests.push(dest)\r\n    stream.Stream.prototype.pipe.call(self, dest, opts)\r\n    return dest\r\n  }\r\n}\r\nRequest.prototype.write = function () {\r\n  var self = this\r\n  if (self._aborted) { return }\r\n\r\n  if (!self._started) {\r\n    self.start()\r\n  }\r\n  if (self.req) {\r\n    return self.req.write.apply(self.req, arguments)\r\n  }\r\n}\r\nRequest.prototype.end = function (chunk) {\r\n  var self = this\r\n  if (self._aborted) { return }\r\n\r\n  if (chunk) {\r\n    self.write(chunk)\r\n  }\r\n  if (!self._started) {\r\n    self.start()\r\n  }\r\n  if (self.req) {\r\n    self.req.end()\r\n  }\r\n}\r\nRequest.prototype.pause = function () {\r\n  var self = this\r\n  if (!self.responseContent) {\r\n    self._paused = true\r\n  } else {\r\n    self.responseContent.pause.apply(self.responseContent, arguments)\r\n  }\r\n}\r\nRequest.prototype.resume = function () {\r\n  var self = this\r\n  if (!self.responseContent) {\r\n    self._paused = false\r\n  } else {\r\n    self.responseContent.resume.apply(self.responseContent, arguments)\r\n  }\r\n}\r\nRequest.prototype.destroy = function () {\r\n  var self = this\r\n  this.clearTimeout()\r\n  if (!self._ended) {\r\n    self.end()\r\n  } else if (self.response) {\r\n    self.response.destroy()\r\n  }\r\n}\r\n\r\nRequest.prototype.clearTimeout = function () {\r\n  if (this.timeoutTimer) {\r\n    clearTimeout(this.timeoutTimer)\r\n    this.timeoutTimer = null\r\n  }\r\n}\r\n\r\nRequest.defaultProxyHeaderWhiteList =\r\n  Tunnel.defaultProxyHeaderWhiteList.slice()\r\n\r\nRequest.defaultProxyHeaderExclusiveList =\r\n  Tunnel.defaultProxyHeaderExclusiveList.slice()\r\n\r\n// Exports\r\n\r\nRequest.prototype.toJSON = requestToJSON\r\nmodule.exports = Request\r\n","\r\n\r\nfunction formatHostname (hostname) {\r\n  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'\r\n  return hostname.replace(/^\\.*/, '.').toLowerCase()\r\n}\r\n\r\nfunction parseNoProxyZone (zone) {\r\n  zone = zone.trim().toLowerCase()\r\n\r\n  var zoneParts = zone.split(':', 2)\r\n  var zoneHost = formatHostname(zoneParts[0])\r\n  var zonePort = zoneParts[1]\r\n  var hasPort = zone.indexOf(':') > -1\r\n\r\n  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}\r\n}\r\n\r\nfunction uriInNoProxy (uri, noProxy) {\r\n  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\r\n  var hostname = formatHostname(uri.hostname)\r\n  var noProxyList = noProxy.split(',')\r\n\r\n  // iterate through the noProxyList until it finds a match.\r\n  return noProxyList.map(parseNoProxyZone).some(function (noProxyZone) {\r\n    var isMatchedAt = hostname.indexOf(noProxyZone.hostname)\r\n    var hostnameMatched = (\r\n      isMatchedAt > -1 &&\r\n        (isMatchedAt === hostname.length - noProxyZone.hostname.length)\r\n    )\r\n\r\n    if (noProxyZone.hasPort) {\r\n      return (port === noProxyZone.port) && hostnameMatched\r\n    }\r\n\r\n    return hostnameMatched\r\n  })\r\n}\r\n\r\nfunction getProxyFromURI (uri) {\r\n  // Decide the proper request proxy to use based on the request URI object and the\r\n  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)\r\n  // respect NO_PROXY environment variables (see: https://lynx.invisible-island.net/lynx2.8.7/breakout/lynx_help/keystrokes/environments.html)\r\n\r\n  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''\r\n\r\n  // if the noProxy is a wildcard then return null\r\n\r\n  if (noProxy === '*') {\r\n    return null\r\n  }\r\n\r\n  // if the noProxy is not empty and the uri is found return null\r\n\r\n  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {\r\n    return null\r\n  }\r\n\r\n  // Check for HTTP or HTTPS Proxy in environment Else default to null\r\n\r\n  if (uri.protocol === 'http:') {\r\n    return process.env.HTTP_PROXY ||\r\n      process.env.http_proxy || null\r\n  }\r\n\r\n  if (uri.protocol === 'https:') {\r\n    return process.env.HTTPS_PROXY ||\r\n      process.env.https_proxy ||\r\n      process.env.HTTP_PROXY ||\r\n      process.env.http_proxy || null\r\n  }\r\n\r\n  // if none of that works, return null\r\n  // (What uri protocol are you using then?)\r\n\r\n  return null\r\n}\r\n\r\nmodule.exports = getProxyFromURI\r\n","\r\n\r\nvar qs = require('qs')\r\nvar querystring = require('querystring')\r\n\r\nfunction Querystring (request) {\r\n  this.request = request\r\n  this.lib = null\r\n  this.useQuerystring = null\r\n  this.parseOptions = null\r\n  this.stringifyOptions = null\r\n}\r\n\r\nQuerystring.prototype.init = function (options) {\r\n  if (this.lib) { return }\r\n\r\n  this.useQuerystring = options.useQuerystring\r\n  this.lib = (this.useQuerystring ? querystring : qs)\r\n\r\n  this.parseOptions = options.qsParseOptions || {}\r\n  this.stringifyOptions = options.qsStringifyOptions || {}\r\n}\r\n\r\nQuerystring.prototype.stringify = function (obj) {\r\n  return (this.useQuerystring)\r\n    ? this.rfc3986(this.lib.stringify(obj,\r\n      this.stringifyOptions.sep || null,\r\n      this.stringifyOptions.eq || null,\r\n      this.stringifyOptions))\r\n    : this.lib.stringify(obj, this.stringifyOptions)\r\n}\r\n\r\nQuerystring.prototype.parse = function (str) {\r\n  return (this.useQuerystring)\r\n    ? this.lib.parse(str,\r\n      this.parseOptions.sep || null,\r\n      this.parseOptions.eq || null,\r\n      this.parseOptions)\r\n    : this.lib.parse(str, this.parseOptions)\r\n}\r\n\r\nQuerystring.prototype.rfc3986 = function (str) {\r\n  return str.replace(/[!'()*]/g, function (c) {\r\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\r\n  })\r\n}\r\n\r\nQuerystring.prototype.unescape = querystring.unescape\r\n\r\nexports.Querystring = Querystring\r\n","\r\n\r\nvar fs = require('fs')\r\nvar qs = require('querystring')\r\nvar validate = require('har-validator')\r\nvar extend = require('extend')\r\n\r\nfunction Har (request) {\r\n  this.request = request\r\n}\r\n\r\nHar.prototype.reducer = function (obj, pair) {\r\n  // new property ?\r\n  if (obj[pair.name] === undefined) {\r\n    obj[pair.name] = pair.value\r\n    return obj\r\n  }\r\n\r\n  // existing? convert to array\r\n  var arr = [\r\n    obj[pair.name],\r\n    pair.value\r\n  ]\r\n\r\n  obj[pair.name] = arr\r\n\r\n  return obj\r\n}\r\n\r\nHar.prototype.prep = function (data) {\r\n  // construct utility properties\r\n  data.queryObj = {}\r\n  data.headersObj = {}\r\n  data.postData.jsonObj = false\r\n  data.postData.paramsObj = false\r\n\r\n  // construct query objects\r\n  if (data.queryString && data.queryString.length) {\r\n    data.queryObj = data.queryString.reduce(this.reducer, {})\r\n  }\r\n\r\n  // construct headers objects\r\n  if (data.headers && data.headers.length) {\r\n    // loweCase header keys\r\n    data.headersObj = data.headers.reduceRight(function (headers, header) {\r\n      headers[header.name] = header.value\r\n      return headers\r\n    }, {})\r\n  }\r\n\r\n  // construct Cookie header\r\n  if (data.cookies && data.cookies.length) {\r\n    var cookies = data.cookies.map(function (cookie) {\r\n      return cookie.name + '=' + cookie.value\r\n    })\r\n\r\n    if (cookies.length) {\r\n      data.headersObj.cookie = cookies.join('; ')\r\n    }\r\n  }\r\n\r\n  // prep body\r\n  function some (arr) {\r\n    return arr.some(function (type) {\r\n      return data.postData.mimeType.indexOf(type) === 0\r\n    })\r\n  }\r\n\r\n  if (some([\r\n    'multipart/mixed',\r\n    'multipart/related',\r\n    'multipart/form-data',\r\n    'multipart/alternative'])) {\r\n    // reset values\r\n    data.postData.mimeType = 'multipart/form-data'\r\n  } else if (some([\r\n    'application/x-www-form-urlencoded'])) {\r\n    if (!data.postData.params) {\r\n      data.postData.text = ''\r\n    } else {\r\n      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {})\r\n\r\n      // always overwrite\r\n      data.postData.text = qs.stringify(data.postData.paramsObj)\r\n    }\r\n  } else if (some([\r\n    'text/json',\r\n    'text/x-json',\r\n    'application/json',\r\n    'application/x-json'])) {\r\n    data.postData.mimeType = 'application/json'\r\n\r\n    if (data.postData.text) {\r\n      try {\r\n        data.postData.jsonObj = JSON.parse(data.postData.text)\r\n      } catch (e) {\r\n        this.request.debug(e)\r\n\r\n        // force back to text/plain\r\n        data.postData.mimeType = 'text/plain'\r\n      }\r\n    }\r\n  }\r\n\r\n  return data\r\n}\r\n\r\nHar.prototype.options = function (options) {\r\n  // skip if no har property defined\r\n  if (!options.har) {\r\n    return options\r\n  }\r\n\r\n  var har = {}\r\n  extend(har, options.har)\r\n\r\n  // only process the first entry\r\n  if (har.log && har.log.entries) {\r\n    har = har.log.entries[0]\r\n  }\r\n\r\n  // add optional properties to make validation successful\r\n  har.url = har.url || options.url || options.uri || options.baseUrl || '/'\r\n  har.httpVersion = har.httpVersion || 'HTTP/1.1'\r\n  har.queryString = har.queryString || []\r\n  har.headers = har.headers || []\r\n  har.cookies = har.cookies || []\r\n  har.postData = har.postData || {}\r\n  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream'\r\n\r\n  har.bodySize = 0\r\n  har.headersSize = 0\r\n  har.postData.size = 0\r\n\r\n  if (!validate.request(har)) {\r\n    return options\r\n  }\r\n\r\n  // clean up and get some utility properties\r\n  var req = this.prep(har)\r\n\r\n  // construct new options\r\n  if (req.url) {\r\n    options.url = req.url\r\n  }\r\n\r\n  if (req.method) {\r\n    options.method = req.method\r\n  }\r\n\r\n  if (Object.keys(req.queryObj).length) {\r\n    options.qs = req.queryObj\r\n  }\r\n\r\n  if (Object.keys(req.headersObj).length) {\r\n    options.headers = req.headersObj\r\n  }\r\n\r\n  function test (type) {\r\n    return req.postData.mimeType.indexOf(type) === 0\r\n  }\r\n  if (test('application/x-www-form-urlencoded')) {\r\n    options.form = req.postData.paramsObj\r\n  } else if (test('application/json')) {\r\n    if (req.postData.jsonObj) {\r\n      options.body = req.postData.jsonObj\r\n      options.json = true\r\n    }\r\n  } else if (test('multipart/form-data')) {\r\n    options.formData = {}\r\n\r\n    req.postData.params.forEach(function (param) {\r\n      var attachment = {}\r\n\r\n      if (!param.fileName && !param.contentType) {\r\n        options.formData[param.name] = param.value\r\n        return\r\n      }\r\n\r\n      // attempt to read from disk!\r\n      if (param.fileName && !param.value) {\r\n        attachment.value = fs.createReadStream(param.fileName)\r\n      } else if (param.value) {\r\n        attachment.value = param.value\r\n      }\r\n\r\n      if (param.fileName) {\r\n        attachment.options = {\r\n          filename: param.fileName,\r\n          contentType: param.contentType ? param.contentType : null\r\n        }\r\n      }\r\n\r\n      options.formData[param.name] = attachment\r\n    })\r\n  } else {\r\n    if (req.postData.text) {\r\n      options.body = req.postData.text\r\n    }\r\n  }\r\n\r\n  return options\r\n}\r\n\r\nexports.Har = Har\r\n","\r\n\r\nvar caseless = require('caseless')\r\nvar uuid = require('uuid/v4')\r\nvar helpers = require('./helpers')\r\n\r\nvar md5 = helpers.md5\r\nvar toBase64 = helpers.toBase64\r\n\r\nfunction Auth (request) {\r\n  // define all public properties here\r\n  this.request = request\r\n  this.hasAuth = false\r\n  this.sentAuth = false\r\n  this.bearerToken = null\r\n  this.user = null\r\n  this.pass = null\r\n}\r\n\r\nAuth.prototype.basic = function (user, pass, sendImmediately) {\r\n  var self = this\r\n  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {\r\n    self.request.emit('error', new Error('auth() received invalid user or password'))\r\n  }\r\n  self.user = user\r\n  self.pass = pass\r\n  self.hasAuth = true\r\n  var header = user + ':' + (pass || '')\r\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\r\n    var authHeader = 'Basic ' + toBase64(header)\r\n    self.sentAuth = true\r\n    return authHeader\r\n  }\r\n}\r\n\r\nAuth.prototype.bearer = function (bearer, sendImmediately) {\r\n  var self = this\r\n  self.bearerToken = bearer\r\n  self.hasAuth = true\r\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\r\n    if (typeof bearer === 'function') {\r\n      bearer = bearer()\r\n    }\r\n    var authHeader = 'Bearer ' + (bearer || '')\r\n    self.sentAuth = true\r\n    return authHeader\r\n  }\r\n}\r\n\r\nAuth.prototype.digest = function (method, path, authHeader) {\r\n  // TODO: More complete implementation of RFC 2617.\r\n  //   - handle challenge.domain\r\n  //   - support qop=\"auth-int\" only\r\n  //   - handle Authentication-Info (not necessarily?)\r\n  //   - check challenge.stale (not necessarily?)\r\n  //   - increase nc (not necessarily?)\r\n  // For reference:\r\n  // http://tools.ietf.org/html/rfc2617#section-3\r\n  // https://github.com/bagder/curl/blob/master/lib/http_digest.c\r\n\r\n  var self = this\r\n\r\n  var challenge = {}\r\n  var re = /([a-z0-9_-]+)=(?:\"([^\"]+)\"|([a-z0-9_-]+))/gi\r\n  while (true) {\r\n    var match = re.exec(authHeader)\r\n    if (!match) {\r\n      break\r\n    }\r\n    challenge[match[1]] = match[2] || match[3]\r\n  }\r\n\r\n  /**\r\n   * RFC 2617: handle both MD5 and MD5-sess algorithms.\r\n   *\r\n   * If the algorithm directive's value is \"MD5\" or unspecified, then HA1 is\r\n   *   HA1=MD5(username:realm:password)\r\n   * If the algorithm directive's value is \"MD5-sess\", then HA1 is\r\n   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)\r\n   */\r\n  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {\r\n    var ha1 = md5(user + ':' + realm + ':' + pass)\r\n    if (algorithm && algorithm.toLowerCase() === 'md5-sess') {\r\n      return md5(ha1 + ':' + nonce + ':' + cnonce)\r\n    } else {\r\n      return ha1\r\n    }\r\n  }\r\n\r\n  var qop = /(^|,)\\s*auth\\s*($|,)/.test(challenge.qop) && 'auth'\r\n  var nc = qop && '00000001'\r\n  var cnonce = qop && uuid().replace(/-/g, '')\r\n  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce)\r\n  var ha2 = md5(method + ':' + path)\r\n  var digestResponse = qop\r\n    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)\r\n    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)\r\n  var authValues = {\r\n    username: self.user,\r\n    realm: challenge.realm,\r\n    nonce: challenge.nonce,\r\n    uri: path,\r\n    qop: qop,\r\n    response: digestResponse,\r\n    nc: nc,\r\n    cnonce: cnonce,\r\n    algorithm: challenge.algorithm,\r\n    opaque: challenge.opaque\r\n  }\r\n\r\n  authHeader = []\r\n  for (var k in authValues) {\r\n    if (authValues[k]) {\r\n      if (k === 'qop' || k === 'nc' || k === 'algorithm') {\r\n        authHeader.push(k + '=' + authValues[k])\r\n      } else {\r\n        authHeader.push(k + '=\"' + authValues[k] + '\"')\r\n      }\r\n    }\r\n  }\r\n  authHeader = 'Digest ' + authHeader.join(', ')\r\n  self.sentAuth = true\r\n  return authHeader\r\n}\r\n\r\nAuth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {\r\n  var self = this\r\n  var request = self.request\r\n\r\n  var authHeader\r\n  if (bearer === undefined && user === undefined) {\r\n    self.request.emit('error', new Error('no auth mechanism defined'))\r\n  } else if (bearer !== undefined) {\r\n    authHeader = self.bearer(bearer, sendImmediately)\r\n  } else {\r\n    authHeader = self.basic(user, pass, sendImmediately)\r\n  }\r\n  if (authHeader) {\r\n    request.setHeader('authorization', authHeader)\r\n  }\r\n}\r\n\r\nAuth.prototype.onResponse = function (response) {\r\n  var self = this\r\n  var request = self.request\r\n\r\n  if (!self.hasAuth || self.sentAuth) { return null }\r\n\r\n  var c = caseless(response.headers)\r\n\r\n  var authHeader = c.get('www-authenticate')\r\n  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()\r\n  request.debug('reauth', authVerb)\r\n\r\n  switch (authVerb) {\r\n    case 'basic':\r\n      return self.basic(self.user, self.pass, true)\r\n\r\n    case 'bearer':\r\n      return self.bearer(self.bearerToken, true)\r\n\r\n    case 'digest':\r\n      return self.digest(request.method, request.path, authHeader)\r\n  }\r\n}\r\n\r\nexports.Auth = Auth\r\n","\r\n\r\nvar url = require('url')\r\nvar qs = require('qs')\r\nvar caseless = require('caseless')\r\nvar uuid = require('uuid/v4')\r\nvar oauth = require('oauth-sign')\r\nvar crypto = require('crypto')\r\nvar Buffer = require('safe-buffer').Buffer\r\n\r\nfunction OAuth (request) {\r\n  this.request = request\r\n  this.params = null\r\n}\r\n\r\nOAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {\r\n  var oa = {}\r\n  for (var i in _oauth) {\r\n    oa['oauth_' + i] = _oauth[i]\r\n  }\r\n  if (!oa.oauth_version) {\r\n    oa.oauth_version = '1.0'\r\n  }\r\n  if (!oa.oauth_timestamp) {\r\n    oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString()\r\n  }\r\n  if (!oa.oauth_nonce) {\r\n    oa.oauth_nonce = uuid().replace(/-/g, '')\r\n  }\r\n  if (!oa.oauth_signature_method) {\r\n    oa.oauth_signature_method = 'HMAC-SHA1'\r\n  }\r\n\r\n  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key // eslint-disable-line camelcase\r\n  delete oa.oauth_consumer_secret\r\n  delete oa.oauth_private_key\r\n\r\n  var token_secret = oa.oauth_token_secret // eslint-disable-line camelcase\r\n  delete oa.oauth_token_secret\r\n\r\n  var realm = oa.oauth_realm\r\n  delete oa.oauth_realm\r\n  delete oa.oauth_transport_method\r\n\r\n  var baseurl = uri.protocol + '//' + uri.host + uri.pathname\r\n  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))\r\n\r\n  oa.oauth_signature = oauth.sign(\r\n    oa.oauth_signature_method,\r\n    method,\r\n    baseurl,\r\n    params,\r\n    consumer_secret_or_private_key, // eslint-disable-line camelcase\r\n    token_secret // eslint-disable-line camelcase\r\n  )\r\n\r\n  if (realm) {\r\n    oa.realm = realm\r\n  }\r\n\r\n  return oa\r\n}\r\n\r\nOAuth.prototype.buildBodyHash = function (_oauth, body) {\r\n  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {\r\n    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +\r\n      ' signature_method not supported with body_hash signing.'))\r\n  }\r\n\r\n  var shasum = crypto.createHash('sha1')\r\n  shasum.update(body || '')\r\n  var sha1 = shasum.digest('hex')\r\n\r\n  return Buffer.from(sha1, 'hex').toString('base64')\r\n}\r\n\r\nOAuth.prototype.concatParams = function (oa, sep, wrap) {\r\n  wrap = wrap || ''\r\n\r\n  var params = Object.keys(oa).filter(function (i) {\r\n    return i !== 'realm' && i !== 'oauth_signature'\r\n  }).sort()\r\n\r\n  if (oa.realm) {\r\n    params.splice(0, 0, 'realm')\r\n  }\r\n  params.push('oauth_signature')\r\n\r\n  return params.map(function (i) {\r\n    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap\r\n  }).join(sep)\r\n}\r\n\r\nOAuth.prototype.onRequest = function (_oauth) {\r\n  var self = this\r\n  self.params = _oauth\r\n\r\n  var uri = self.request.uri || {}\r\n  var method = self.request.method || ''\r\n  var headers = caseless(self.request.headers)\r\n  var body = self.request.body || ''\r\n  var qsLib = self.request.qsLib || qs\r\n\r\n  var form\r\n  var query\r\n  var contentType = headers.get('content-type') || ''\r\n  var formContentType = 'application/x-www-form-urlencoded'\r\n  var transport = _oauth.transport_method || 'header'\r\n\r\n  if (contentType.slice(0, formContentType.length) === formContentType) {\r\n    contentType = formContentType\r\n    form = body\r\n  }\r\n  if (uri.query) {\r\n    query = uri.query\r\n  }\r\n  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {\r\n    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +\r\n      'and content-type ' + formContentType))\r\n  }\r\n\r\n  if (!form && typeof _oauth.body_hash === 'boolean') {\r\n    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())\r\n  }\r\n\r\n  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)\r\n\r\n  switch (transport) {\r\n    case 'header':\r\n      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '\"'))\r\n      break\r\n\r\n    case 'query':\r\n      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')\r\n      self.request.uri = url.parse(href)\r\n      self.request.path = self.request.uri.path\r\n      break\r\n\r\n    case 'body':\r\n      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')\r\n      break\r\n\r\n    default:\r\n      self.request.emit('error', new Error('oauth: transport_method invalid'))\r\n  }\r\n}\r\n\r\nexports.OAuth = OAuth\r\n","\r\n\r\nvar crypto = require('crypto')\r\n\r\nfunction randomString (size) {\r\n  var bits = (size + 1) * 6\r\n  var buffer = crypto.randomBytes(Math.ceil(bits / 8))\r\n  var string = buffer.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '')\r\n  return string.slice(0, size)\r\n}\r\n\r\nfunction calculatePayloadHash (payload, algorithm, contentType) {\r\n  var hash = crypto.createHash(algorithm)\r\n  hash.update('hawk.1.payload\\n')\r\n  hash.update((contentType ? contentType.split(';')[0].trim().toLowerCase() : '') + '\\n')\r\n  hash.update(payload || '')\r\n  hash.update('\\n')\r\n  return hash.digest('base64')\r\n}\r\n\r\nexports.calculateMac = function (credentials, opts) {\r\n  var normalized = 'hawk.1.header\\n' +\r\n    opts.ts + '\\n' +\r\n    opts.nonce + '\\n' +\r\n    (opts.method || '').toUpperCase() + '\\n' +\r\n    opts.resource + '\\n' +\r\n    opts.host.toLowerCase() + '\\n' +\r\n    opts.port + '\\n' +\r\n    (opts.hash || '') + '\\n'\r\n\r\n  if (opts.ext) {\r\n    normalized = normalized + opts.ext.replace('\\\\', '\\\\\\\\').replace('\\n', '\\\\n')\r\n  }\r\n\r\n  normalized = normalized + '\\n'\r\n\r\n  if (opts.app) {\r\n    normalized = normalized + opts.app + '\\n' + (opts.dlg || '') + '\\n'\r\n  }\r\n\r\n  var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized)\r\n  var digest = hmac.digest('base64')\r\n  return digest\r\n}\r\n\r\nexports.header = function (uri, method, opts) {\r\n  var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1000)\r\n  var credentials = opts.credentials\r\n  if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {\r\n    return ''\r\n  }\r\n\r\n  if (['sha1', 'sha256'].indexOf(credentials.algorithm) === -1) {\r\n    return ''\r\n  }\r\n\r\n  var artifacts = {\r\n    ts: timestamp,\r\n    nonce: opts.nonce || randomString(6),\r\n    method: method,\r\n    resource: uri.pathname + (uri.search || ''),\r\n    host: uri.hostname,\r\n    port: uri.port || (uri.protocol === 'http:' ? 80 : 443),\r\n    hash: opts.hash,\r\n    ext: opts.ext,\r\n    app: opts.app,\r\n    dlg: opts.dlg\r\n  }\r\n\r\n  if (!artifacts.hash && (opts.payload || opts.payload === '')) {\r\n    artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType)\r\n  }\r\n\r\n  var mac = exports.calculateMac(credentials, artifacts)\r\n\r\n  var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== ''\r\n  var header = 'Hawk id=\"' + credentials.id +\r\n    '\", ts=\"' + artifacts.ts +\r\n    '\", nonce=\"' + artifacts.nonce +\r\n    (artifacts.hash ? '\", hash=\"' + artifacts.hash : '') +\r\n    (hasExt ? '\", ext=\"' + artifacts.ext.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"') : '') +\r\n    '\", mac=\"' + mac + '\"'\r\n\r\n  if (artifacts.app) {\r\n    header = header + ', app=\"' + artifacts.app + (artifacts.dlg ? '\", dlg=\"' + artifacts.dlg : '') + '\"'\r\n  }\r\n\r\n  return header\r\n}\r\n","\r\n\r\nvar uuid = require('uuid/v4')\r\nvar CombinedStream = require('combined-stream')\r\nvar isstream = require('isstream')\r\nvar Buffer = require('safe-buffer').Buffer\r\n\r\nfunction Multipart (request) {\r\n  this.request = request\r\n  this.boundary = uuid()\r\n  this.chunked = false\r\n  this.body = null\r\n}\r\n\r\nMultipart.prototype.isChunked = function (options) {\r\n  var self = this\r\n  var chunked = false\r\n  var parts = options.data || options\r\n\r\n  if (!parts.forEach) {\r\n    self.request.emit('error', new Error('Argument error, options.multipart.'))\r\n  }\r\n\r\n  if (options.chunked !== undefined) {\r\n    chunked = options.chunked\r\n  }\r\n\r\n  if (self.request.getHeader('transfer-encoding') === 'chunked') {\r\n    chunked = true\r\n  }\r\n\r\n  if (!chunked) {\r\n    parts.forEach(function (part) {\r\n      if (typeof part.body === 'undefined') {\r\n        self.request.emit('error', new Error('Body attribute missing in multipart.'))\r\n      }\r\n      if (isstream(part.body)) {\r\n        chunked = true\r\n      }\r\n    })\r\n  }\r\n\r\n  return chunked\r\n}\r\n\r\nMultipart.prototype.setHeaders = function (chunked) {\r\n  var self = this\r\n\r\n  if (chunked && !self.request.hasHeader('transfer-encoding')) {\r\n    self.request.setHeader('transfer-encoding', 'chunked')\r\n  }\r\n\r\n  var header = self.request.getHeader('content-type')\r\n\r\n  if (!header || header.indexOf('multipart') === -1) {\r\n    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)\r\n  } else {\r\n    if (header.indexOf('boundary') !== -1) {\r\n      self.boundary = header.replace(/.*boundary=([^\\s;]+).*/, '$1')\r\n    } else {\r\n      self.request.setHeader('content-type', header + '; boundary=' + self.boundary)\r\n    }\r\n  }\r\n}\r\n\r\nMultipart.prototype.build = function (parts, chunked) {\r\n  var self = this\r\n  var body = chunked ? new CombinedStream() : []\r\n\r\n  function add (part) {\r\n    if (typeof part === 'number') {\r\n      part = part.toString()\r\n    }\r\n    return chunked ? body.append(part) : body.push(Buffer.from(part))\r\n  }\r\n\r\n  if (self.request.preambleCRLF) {\r\n    add('\\r\\n')\r\n  }\r\n\r\n  parts.forEach(function (part) {\r\n    var preamble = '--' + self.boundary + '\\r\\n'\r\n    Object.keys(part).forEach(function (key) {\r\n      if (key === 'body') { return }\r\n      preamble += key + ': ' + part[key] + '\\r\\n'\r\n    })\r\n    preamble += '\\r\\n'\r\n    add(preamble)\r\n    add(part.body)\r\n    add('\\r\\n')\r\n  })\r\n  add('--' + self.boundary + '--')\r\n\r\n  if (self.request.postambleCRLF) {\r\n    add('\\r\\n')\r\n  }\r\n\r\n  return body\r\n}\r\n\r\nMultipart.prototype.onRequest = function (options) {\r\n  var self = this\r\n\r\n  var chunked = self.isChunked(options)\r\n  var parts = options.data || options\r\n\r\n  self.setHeaders(chunked)\r\n  self.chunked = chunked\r\n  self.body = self.build(parts, chunked)\r\n}\r\n\r\nexports.Multipart = Multipart\r\n","\r\n\r\nvar url = require('url')\r\nvar isUrl = /^https?:/\r\n\r\nfunction Redirect (request) {\r\n  this.request = request\r\n  this.followRedirect = true\r\n  this.followRedirects = true\r\n  this.followAllRedirects = false\r\n  this.followOriginalHttpMethod = false\r\n  this.allowRedirect = function () { return true }\r\n  this.maxRedirects = 10\r\n  this.redirects = []\r\n  this.redirectsFollowed = 0\r\n  this.removeRefererHeader = false\r\n}\r\n\r\nRedirect.prototype.onRequest = function (options) {\r\n  var self = this\r\n\r\n  if (options.maxRedirects !== undefined) {\r\n    self.maxRedirects = options.maxRedirects\r\n  }\r\n  if (typeof options.followRedirect === 'function') {\r\n    self.allowRedirect = options.followRedirect\r\n  }\r\n  if (options.followRedirect !== undefined) {\r\n    self.followRedirects = !!options.followRedirect\r\n  }\r\n  if (options.followAllRedirects !== undefined) {\r\n    self.followAllRedirects = options.followAllRedirects\r\n  }\r\n  if (self.followRedirects || self.followAllRedirects) {\r\n    self.redirects = self.redirects || []\r\n  }\r\n  if (options.removeRefererHeader !== undefined) {\r\n    self.removeRefererHeader = options.removeRefererHeader\r\n  }\r\n  if (options.followOriginalHttpMethod !== undefined) {\r\n    self.followOriginalHttpMethod = options.followOriginalHttpMethod\r\n  }\r\n}\r\n\r\nRedirect.prototype.redirectTo = function (response) {\r\n  var self = this\r\n  var request = self.request\r\n\r\n  var redirectTo = null\r\n  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {\r\n    var location = response.caseless.get('location')\r\n    request.debug('redirect', location)\r\n\r\n    if (self.followAllRedirects) {\r\n      redirectTo = location\r\n    } else if (self.followRedirects) {\r\n      switch (request.method) {\r\n        case 'PATCH':\r\n        case 'PUT':\r\n        case 'POST':\r\n        case 'DELETE':\r\n          // Do not follow redirects\r\n          break\r\n        default:\r\n          redirectTo = location\r\n          break\r\n      }\r\n    }\r\n  } else if (response.statusCode === 401) {\r\n    var authHeader = request._auth.onResponse(response)\r\n    if (authHeader) {\r\n      request.setHeader('authorization', authHeader)\r\n      redirectTo = request.uri\r\n    }\r\n  }\r\n  return redirectTo\r\n}\r\n\r\nRedirect.prototype.onResponse = function (response) {\r\n  var self = this\r\n  var request = self.request\r\n\r\n  var redirectTo = self.redirectTo(response)\r\n  if (!redirectTo || !self.allowRedirect.call(request, response)) {\r\n    return false\r\n  }\r\n\r\n  request.debug('redirect to', redirectTo)\r\n\r\n  // ignore any potential response body.  it cannot possibly be useful\r\n  // to us at this point.\r\n  // response.resume should be defined, but check anyway before calling. Workaround for browserify.\r\n  if (response.resume) {\r\n    response.resume()\r\n  }\r\n\r\n  if (self.redirectsFollowed >= self.maxRedirects) {\r\n    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href))\r\n    return false\r\n  }\r\n  self.redirectsFollowed += 1\r\n\r\n  if (!isUrl.test(redirectTo)) {\r\n    redirectTo = url.resolve(request.uri.href, redirectTo)\r\n  }\r\n\r\n  var uriPrev = request.uri\r\n  request.uri = url.parse(redirectTo)\r\n\r\n  // handle the case where we change protocol from https to http or vice versa\r\n  if (request.uri.protocol !== uriPrev.protocol) {\r\n    delete request.agent\r\n  }\r\n\r\n  self.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo })\r\n\r\n  if (self.followAllRedirects && request.method !== 'HEAD' &&\r\n    response.statusCode !== 401 && response.statusCode !== 307) {\r\n    request.method = self.followOriginalHttpMethod ? request.method : 'GET'\r\n  }\r\n  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215\r\n  delete request.src\r\n  delete request.req\r\n  delete request._started\r\n  if (response.statusCode !== 401 && response.statusCode !== 307) {\r\n    // Remove parameters from the previous response, unless this is the second request\r\n    // for a server that requires digest authentication.\r\n    delete request.body\r\n    delete request._form\r\n    if (request.headers) {\r\n      request.removeHeader('host')\r\n      request.removeHeader('content-type')\r\n      request.removeHeader('content-length')\r\n      if (request.uri.hostname !== request.originalHost.split(':')[0]) {\r\n        // Remove authorization if changing hostnames (but not if just\r\n        // changing ports or protocols).  This matches the behavior of curl:\r\n        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710\r\n        request.removeHeader('authorization')\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!self.removeRefererHeader) {\r\n    request.setHeader('referer', uriPrev.href)\r\n  }\r\n\r\n  request.emit('redirect')\r\n\r\n  request.init()\r\n\r\n  return true\r\n}\r\n\r\nexports.Redirect = Redirect\r\n","\r\n\r\nvar url = require('url')\r\nvar tunnel = require('tunnel-agent')\r\n\r\nvar defaultProxyHeaderWhiteList = [\r\n  'accept',\r\n  'accept-charset',\r\n  'accept-encoding',\r\n  'accept-language',\r\n  'accept-ranges',\r\n  'cache-control',\r\n  'content-encoding',\r\n  'content-language',\r\n  'content-location',\r\n  'content-md5',\r\n  'content-range',\r\n  'content-type',\r\n  'connection',\r\n  'date',\r\n  'expect',\r\n  'max-forwards',\r\n  'pragma',\r\n  'referer',\r\n  'te',\r\n  'user-agent',\r\n  'via'\r\n]\r\n\r\nvar defaultProxyHeaderExclusiveList = [\r\n  'proxy-authorization'\r\n]\r\n\r\nfunction constructProxyHost (uriObject) {\r\n  var port = uriObject.port\r\n  var protocol = uriObject.protocol\r\n  var proxyHost = uriObject.hostname + ':'\r\n\r\n  if (port) {\r\n    proxyHost += port\r\n  } else if (protocol === 'https:') {\r\n    proxyHost += '443'\r\n  } else {\r\n    proxyHost += '80'\r\n  }\r\n\r\n  return proxyHost\r\n}\r\n\r\nfunction constructProxyHeaderWhiteList (headers, proxyHeaderWhiteList) {\r\n  var whiteList = proxyHeaderWhiteList\r\n    .reduce(function (set, header) {\r\n      set[header.toLowerCase()] = true\r\n      return set\r\n    }, {})\r\n\r\n  return Object.keys(headers)\r\n    .filter(function (header) {\r\n      return whiteList[header.toLowerCase()]\r\n    })\r\n    .reduce(function (set, header) {\r\n      set[header] = headers[header]\r\n      return set\r\n    }, {})\r\n}\r\n\r\nfunction constructTunnelOptions (request, proxyHeaders) {\r\n  var proxy = request.proxy\r\n\r\n  var tunnelOptions = {\r\n    proxy: {\r\n      host: proxy.hostname,\r\n      port: +proxy.port,\r\n      proxyAuth: proxy.auth,\r\n      headers: proxyHeaders\r\n    },\r\n    headers: request.headers,\r\n    ca: request.ca,\r\n    cert: request.cert,\r\n    key: request.key,\r\n    passphrase: request.passphrase,\r\n    pfx: request.pfx,\r\n    ciphers: request.ciphers,\r\n    rejectUnauthorized: request.rejectUnauthorized,\r\n    secureOptions: request.secureOptions,\r\n    secureProtocol: request.secureProtocol\r\n  }\r\n\r\n  return tunnelOptions\r\n}\r\n\r\nfunction constructTunnelFnName (uri, proxy) {\r\n  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')\r\n  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http')\r\n  return [uriProtocol, proxyProtocol].join('Over')\r\n}\r\n\r\nfunction getTunnelFn (request) {\r\n  var uri = request.uri\r\n  var proxy = request.proxy\r\n  var tunnelFnName = constructTunnelFnName(uri, proxy)\r\n  return tunnel[tunnelFnName]\r\n}\r\n\r\nfunction Tunnel (request) {\r\n  this.request = request\r\n  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList\r\n  this.proxyHeaderExclusiveList = []\r\n  if (typeof request.tunnel !== 'undefined') {\r\n    this.tunnelOverride = request.tunnel\r\n  }\r\n}\r\n\r\nTunnel.prototype.isEnabled = function () {\r\n  var self = this\r\n  var request = self.request\r\n    // Tunnel HTTPS by default. Allow the user to override this setting.\r\n\r\n  // If self.tunnelOverride is set (the user specified a value), use it.\r\n  if (typeof self.tunnelOverride !== 'undefined') {\r\n    return self.tunnelOverride\r\n  }\r\n\r\n  // If the destination is HTTPS, tunnel.\r\n  if (request.uri.protocol === 'https:') {\r\n    return true\r\n  }\r\n\r\n  // Otherwise, do not use tunnel.\r\n  return false\r\n}\r\n\r\nTunnel.prototype.setup = function (options) {\r\n  var self = this\r\n  var request = self.request\r\n\r\n  options = options || {}\r\n\r\n  if (typeof request.proxy === 'string') {\r\n    request.proxy = url.parse(request.proxy)\r\n  }\r\n\r\n  if (!request.proxy || !request.tunnel) {\r\n    return false\r\n  }\r\n\r\n  // Setup Proxy Header Exclusive List and White List\r\n  if (options.proxyHeaderWhiteList) {\r\n    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList\r\n  }\r\n  if (options.proxyHeaderExclusiveList) {\r\n    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList\r\n  }\r\n\r\n  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)\r\n  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)\r\n\r\n  // Setup Proxy Headers and Proxy Headers Host\r\n  // Only send the Proxy White Listed Header names\r\n  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)\r\n  proxyHeaders.host = constructProxyHost(request.uri)\r\n\r\n  proxyHeaderExclusiveList.forEach(request.removeHeader, request)\r\n\r\n  // Set Agent from Tunnel Data\r\n  var tunnelFn = getTunnelFn(request)\r\n  var tunnelOptions = constructTunnelOptions(request, proxyHeaders)\r\n  request.agent = tunnelFn(tunnelOptions)\r\n\r\n  return true\r\n}\r\n\r\nTunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList\r\nTunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList\r\nexports.Tunnel = Tunnel\r\n"]}