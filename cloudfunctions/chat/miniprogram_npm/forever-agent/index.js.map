{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = ForeverAgent\r\nForeverAgent.SSL = ForeverAgentSSL\r\n\r\nvar util = require('util')\r\n  , Agent = require('http').Agent\r\n  , net = require('net')\r\n  , tls = require('tls')\r\n  , AgentSSL = require('https').Agent\r\n  \r\nfunction getConnectionName(host, port) {  \r\n  var name = ''\r\n  if (typeof host === 'string') {\r\n    name = host + ':' + port\r\n  } else {\r\n    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.\r\n    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')\r\n  }\r\n  return name\r\n}    \r\n\r\nfunction ForeverAgent(options) {\r\n  var self = this\r\n  self.options = options || {}\r\n  self.requests = {}\r\n  self.sockets = {}\r\n  self.freeSockets = {}\r\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets\r\n  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets\r\n  self.on('free', function(socket, host, port) {\r\n    var name = getConnectionName(host, port)\r\n\r\n    if (self.requests[name] && self.requests[name].length) {\r\n      self.requests[name].shift().onSocket(socket)\r\n    } else if (self.sockets[name].length < self.minSockets) {\r\n      if (!self.freeSockets[name]) self.freeSockets[name] = []\r\n      self.freeSockets[name].push(socket)\r\n      \r\n      // if an error happens while we don't use the socket anyway, meh, throw the socket away\r\n      var onIdleError = function() {\r\n        socket.destroy()\r\n      }\r\n      socket._onIdleError = onIdleError\r\n      socket.on('error', onIdleError)\r\n    } else {\r\n      // If there are no pending requests just destroy the\r\n      // socket and it will get removed from the pool. This\r\n      // gets us out of timeout issues and allows us to\r\n      // default to Connection:keep-alive.\r\n      socket.destroy()\r\n    }\r\n  })\r\n\r\n}\r\nutil.inherits(ForeverAgent, Agent)\r\n\r\nForeverAgent.defaultMinSockets = 5\r\n\r\n\r\nForeverAgent.prototype.createConnection = net.createConnection\r\nForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest\r\nForeverAgent.prototype.addRequest = function(req, host, port) {\r\n  var name = getConnectionName(host, port)\r\n  \r\n  if (typeof host !== 'string') {\r\n    var options = host\r\n    port = options.port\r\n    host = options.host\r\n  }\r\n\r\n  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\r\n    var idleSocket = this.freeSockets[name].pop()\r\n    idleSocket.removeListener('error', idleSocket._onIdleError)\r\n    delete idleSocket._onIdleError\r\n    req._reusedSocket = true\r\n    req.onSocket(idleSocket)\r\n  } else {\r\n    this.addRequestNoreuse(req, host, port)\r\n  }\r\n}\r\n\r\nForeverAgent.prototype.removeSocket = function(s, name, host, port) {\r\n  if (this.sockets[name]) {\r\n    var index = this.sockets[name].indexOf(s)\r\n    if (index !== -1) {\r\n      this.sockets[name].splice(index, 1)\r\n    }\r\n  } else if (this.sockets[name] && this.sockets[name].length === 0) {\r\n    // don't leak\r\n    delete this.sockets[name]\r\n    delete this.requests[name]\r\n  }\r\n  \r\n  if (this.freeSockets[name]) {\r\n    var index = this.freeSockets[name].indexOf(s)\r\n    if (index !== -1) {\r\n      this.freeSockets[name].splice(index, 1)\r\n      if (this.freeSockets[name].length === 0) {\r\n        delete this.freeSockets[name]\r\n      }\r\n    }\r\n  }\r\n\r\n  if (this.requests[name] && this.requests[name].length) {\r\n    // If we have pending requests and a socket gets closed a new one\r\n    // needs to be created to take over in the pool for the one that closed.\r\n    this.createSocket(name, host, port).emit('free')\r\n  }\r\n}\r\n\r\nfunction ForeverAgentSSL (options) {\r\n  ForeverAgent.call(this, options)\r\n}\r\nutil.inherits(ForeverAgentSSL, ForeverAgent)\r\n\r\nForeverAgentSSL.prototype.createConnection = createConnectionSSL\r\nForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest\r\n\r\nfunction createConnectionSSL (port, host, options) {\r\n  if (typeof port === 'object') {\r\n    options = port;\r\n  } else if (typeof host === 'object') {\r\n    options = host;\r\n  } else if (typeof options === 'object') {\r\n    options = options;\r\n  } else {\r\n    options = {};\r\n  }\r\n\r\n  if (typeof port === 'number') {\r\n    options.port = port;\r\n  }\r\n\r\n  if (typeof host === 'string') {\r\n    options.host = host;\r\n  }\r\n\r\n  return tls.connect(options);\r\n}\r\n"]}