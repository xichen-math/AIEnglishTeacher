{"version":3,"sources":["plumbing.js","errors.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nvar errors = require('./errors.js'),\r\n    isFunction = require('lodash/isFunction'),\r\n    isObjectLike = require('lodash/isObjectLike'),\r\n    isString = require('lodash/isString'),\r\n    isUndefined = require('lodash/isUndefined');\r\n\r\n\r\nmodule.exports = function (options) {\r\n\r\n    var errorText = 'Please verify options'; // For better minification because this string is repeating\r\n\r\n    if (!isObjectLike(options)) {\r\n        throw new TypeError(errorText);\r\n    }\r\n\r\n    if (!isFunction(options.PromiseImpl)) {\r\n        throw new TypeError(errorText + '.PromiseImpl');\r\n    }\r\n\r\n    if (!isUndefined(options.constructorMixin) && !isFunction(options.constructorMixin)) {\r\n        throw new TypeError(errorText + '.PromiseImpl');\r\n    }\r\n\r\n    var PromiseImpl = options.PromiseImpl;\r\n    var constructorMixin = options.constructorMixin;\r\n\r\n\r\n    var plumbing = {};\r\n\r\n    plumbing.init = function (requestOptions) {\r\n\r\n        var self = this;\r\n\r\n        self._rp_promise = new PromiseImpl(function (resolve, reject) {\r\n            self._rp_resolve = resolve;\r\n            self._rp_reject = reject;\r\n            if (constructorMixin) {\r\n                constructorMixin.apply(self, arguments); // Using arguments since specific Promise libraries may pass additional parameters\r\n            }\r\n        });\r\n\r\n        self._rp_callbackOrig = requestOptions.callback;\r\n        requestOptions.callback = self.callback = function RP$callback(err, response, body) {\r\n            plumbing.callback.call(self, err, response, body);\r\n        };\r\n\r\n        if (isString(requestOptions.method)) {\r\n            requestOptions.method = requestOptions.method.toUpperCase();\r\n        }\r\n\r\n        requestOptions.transform = requestOptions.transform || plumbing.defaultTransformations[requestOptions.method];\r\n\r\n        self._rp_options = requestOptions;\r\n        self._rp_options.simple = requestOptions.simple !== false;\r\n        self._rp_options.resolveWithFullResponse = requestOptions.resolveWithFullResponse === true;\r\n        self._rp_options.transform2xxOnly = requestOptions.transform2xxOnly === true;\r\n\r\n    };\r\n\r\n    plumbing.defaultTransformations = {\r\n        HEAD: function (body, response, resolveWithFullResponse) {\r\n            return resolveWithFullResponse ? response : response.headers;\r\n        }\r\n    };\r\n\r\n    plumbing.callback = function (err, response, body) {\r\n\r\n        var self = this;\r\n\r\n        var origCallbackThrewException = false, thrownException = null;\r\n\r\n        if (isFunction(self._rp_callbackOrig)) {\r\n            try {\r\n                self._rp_callbackOrig.apply(self, arguments); // TODO: Apply to self mimics behavior of request@2. Is that also right for request@next?\r\n            } catch (e) {\r\n                origCallbackThrewException = true;\r\n                thrownException = e;\r\n            }\r\n        }\r\n\r\n        var is2xx = !err && /^2/.test('' + response.statusCode);\r\n\r\n        if (err) {\r\n\r\n            self._rp_reject(new errors.RequestError(err, self._rp_options, response));\r\n\r\n        } else if (self._rp_options.simple && !is2xx) {\r\n\r\n            if (isFunction(self._rp_options.transform) && self._rp_options.transform2xxOnly === false) {\r\n\r\n                (new PromiseImpl(function (resolve) {\r\n                    resolve(self._rp_options.transform(body, response, self._rp_options.resolveWithFullResponse)); // transform may return a Promise\r\n                }))\r\n                    .then(function (transformedResponse) {\r\n                        self._rp_reject(new errors.StatusCodeError(response.statusCode, body, self._rp_options, transformedResponse));\r\n                    })\r\n                    .catch(function (transformErr) {\r\n                        self._rp_reject(new errors.TransformError(transformErr, self._rp_options, response));\r\n                    });\r\n\r\n            } else {\r\n                self._rp_reject(new errors.StatusCodeError(response.statusCode, body, self._rp_options, response));\r\n            }\r\n\r\n        } else {\r\n\r\n            if (isFunction(self._rp_options.transform) && (is2xx || self._rp_options.transform2xxOnly === false)) {\r\n\r\n                (new PromiseImpl(function (resolve) {\r\n                    resolve(self._rp_options.transform(body, response, self._rp_options.resolveWithFullResponse)); // transform may return a Promise\r\n                }))\r\n                    .then(function (transformedResponse) {\r\n                        self._rp_resolve(transformedResponse);\r\n                    })\r\n                    .catch(function (transformErr) {\r\n                        self._rp_reject(new errors.TransformError(transformErr, self._rp_options, response));\r\n                    });\r\n\r\n            } else if (self._rp_options.resolveWithFullResponse) {\r\n                self._rp_resolve(response);\r\n            } else {\r\n                self._rp_resolve(body);\r\n            }\r\n\r\n        }\r\n\r\n        if (origCallbackThrewException) {\r\n            throw thrownException;\r\n        }\r\n\r\n    };\r\n\r\n    plumbing.exposePromiseMethod = function (exposeTo, bindTo, promisePropertyKey, methodToExpose, exposeAs) {\r\n\r\n        exposeAs = exposeAs || methodToExpose;\r\n\r\n        if (exposeAs in exposeTo) {\r\n            throw new Error('Unable to expose method \"' + exposeAs + '\"');\r\n        }\r\n\r\n        exposeTo[exposeAs] = function RP$exposed() {\r\n            var self = bindTo || this;\r\n            return self[promisePropertyKey][methodToExpose].apply(self[promisePropertyKey], arguments);\r\n        };\r\n\r\n    };\r\n\r\n    plumbing.exposePromise = function (exposeTo, bindTo, promisePropertyKey, exposeAs) {\r\n\r\n        exposeAs = exposeAs || 'promise';\r\n\r\n        if (exposeAs in exposeTo) {\r\n            throw new Error('Unable to expose method \"' + exposeAs + '\"');\r\n        }\r\n\r\n        exposeTo[exposeAs] = function RP$promise() {\r\n            var self = bindTo || this;\r\n            return self[promisePropertyKey];\r\n        };\r\n\r\n    };\r\n\r\n    return plumbing;\r\n\r\n};\r\n","\r\n\r\n\r\nfunction RequestError(cause, options, response) {\r\n\r\n    this.name = 'RequestError';\r\n    this.message = String(cause);\r\n    this.cause = cause;\r\n    this.error = cause; // legacy attribute\r\n    this.options = options;\r\n    this.response = response;\r\n\r\n    if (Error.captureStackTrace) { // required for non-V8 environments\r\n        Error.captureStackTrace(this);\r\n    }\r\n\r\n}\r\nRequestError.prototype = Object.create(Error.prototype);\r\nRequestError.prototype.constructor = RequestError;\r\n\r\n\r\nfunction StatusCodeError(statusCode, body, options, response) {\r\n\r\n    this.name = 'StatusCodeError';\r\n    this.statusCode = statusCode;\r\n    this.message = statusCode + ' - ' + (JSON && JSON.stringify ? JSON.stringify(body) : body);\r\n    this.error = body; // legacy attribute\r\n    this.options = options;\r\n    this.response = response;\r\n\r\n    if (Error.captureStackTrace) { // required for non-V8 environments\r\n        Error.captureStackTrace(this);\r\n    }\r\n\r\n}\r\nStatusCodeError.prototype = Object.create(Error.prototype);\r\nStatusCodeError.prototype.constructor = StatusCodeError;\r\n\r\n\r\nfunction TransformError(cause, options, response) {\r\n\r\n    this.name = 'TransformError';\r\n    this.message = String(cause);\r\n    this.cause = cause;\r\n    this.error = cause; // legacy attribute\r\n    this.options = options;\r\n    this.response = response;\r\n\r\n    if (Error.captureStackTrace) { // required for non-V8 environments\r\n        Error.captureStackTrace(this);\r\n    }\r\n\r\n}\r\nTransformError.prototype = Object.create(Error.prototype);\r\nTransformError.prototype.constructor = TransformError;\r\n\r\n\r\nmodule.exports = {\r\n    RequestError: RequestError,\r\n    StatusCodeError: StatusCodeError,\r\n    TransformError: TransformError\r\n};\r\n"]}