{"version":3,"sources":["index.js","promisify.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nconst events_1 = require(\"events\");\r\nconst promisify_1 = __importDefault(require(\"./promisify\"));\r\nfunction isAgentBase(v) {\r\n    return Boolean(v) && typeof v.addRequest === 'function';\r\n}\r\nfunction isHttpAgent(v) {\r\n    return Boolean(v) && typeof v.addRequest === 'function';\r\n}\r\nfunction isSecureEndpoint() {\r\n    const { stack } = new Error();\r\n    if (typeof stack !== 'string')\r\n        return false;\r\n    return stack.split('\\n').some(l => l.indexOf('(https.js:') !== -1);\r\n}\r\nfunction createAgent(callback, opts) {\r\n    return new createAgent.Agent(callback, opts);\r\n}\r\n(function (createAgent) {\r\n    /**\r\n     * Base `http.Agent` implementation.\r\n     * No pooling/keep-alive is implemented by default.\r\n     *\r\n     * @param {Function} callback\r\n     * @api public\r\n     */\r\n    class Agent extends events_1.EventEmitter {\r\n        constructor(callback, _opts) {\r\n            super();\r\n            // The callback gets promisified lazily\r\n            this.promisifiedCallback = undefined;\r\n            let opts = _opts;\r\n            if (typeof callback === 'function') {\r\n                this.callback = callback;\r\n            }\r\n            else if (callback) {\r\n                opts = callback;\r\n            }\r\n            // timeout for the socket to be returned from the callback\r\n            this.timeout = null;\r\n            if (opts && typeof opts.timeout === 'number') {\r\n                this.timeout = opts.timeout;\r\n            }\r\n            this.options = opts || {};\r\n            this.maxFreeSockets = 1;\r\n            this.maxSockets = 1;\r\n            this.sockets = [];\r\n            this.requests = [];\r\n        }\r\n        get defaultPort() {\r\n            if (typeof this.explicitDefaultPort === 'number') {\r\n                return this.explicitDefaultPort;\r\n            }\r\n            else {\r\n                return isSecureEndpoint() ? 443 : 80;\r\n            }\r\n        }\r\n        set defaultPort(v) {\r\n            this.explicitDefaultPort = v;\r\n        }\r\n        get protocol() {\r\n            if (typeof this.explicitProtocol === 'string') {\r\n                return this.explicitProtocol;\r\n            }\r\n            else {\r\n                return isSecureEndpoint() ? 'https:' : 'http:';\r\n            }\r\n        }\r\n        set protocol(v) {\r\n            this.explicitProtocol = v;\r\n        }\r\n        callback(req, opts, fn) {\r\n            throw new Error('\"agent-base\" has no default implementation, you must subclass and override `callback()`');\r\n        }\r\n        /**\r\n         * Called by node-core's \"_http_client.js\" module when creating\r\n         * a new HTTP request with this Agent instance.\r\n         *\r\n         * @api public\r\n         */\r\n        addRequest(req, _opts) {\r\n            const ownOpts = Object.assign({}, _opts);\r\n            if (typeof ownOpts.secureEndpoint !== 'boolean') {\r\n                ownOpts.secureEndpoint = isSecureEndpoint();\r\n            }\r\n            // Set default `host` for HTTP to localhost\r\n            if (ownOpts.host == null) {\r\n                ownOpts.host = 'localhost';\r\n            }\r\n            // Set default `port` for HTTP if none was explicitly specified\r\n            if (ownOpts.port == null) {\r\n                ownOpts.port = ownOpts.secureEndpoint ? 443 : 80;\r\n            }\r\n            const opts = Object.assign(Object.assign({}, this.options), ownOpts);\r\n            if (opts.host && opts.path) {\r\n                // If both a `host` and `path` are specified then it's most likely the\r\n                // result of a `url.parse()` call... we need to remove the `path` portion so\r\n                // that `net.connect()` doesn't attempt to open that as a unix socket file.\r\n                delete opts.path;\r\n            }\r\n            delete opts.agent;\r\n            delete opts.hostname;\r\n            delete opts._defaultAgent;\r\n            delete opts.defaultPort;\r\n            delete opts.createConnection;\r\n            // Hint to use \"Connection: close\"\r\n            // XXX: non-documented `http` module API :(\r\n            req._last = true;\r\n            req.shouldKeepAlive = false;\r\n            // Create the `stream.Duplex` instance\r\n            let timedOut = false;\r\n            let timeout = null;\r\n            const timeoutMs = this.timeout;\r\n            const freeSocket = this.freeSocket;\r\n            function onerror(err) {\r\n                if (req._hadError)\r\n                    return;\r\n                req.emit('error', err);\r\n                // For Safety. Some additional errors might fire later on\r\n                // and we need to make sure we don't double-fire the error event.\r\n                req._hadError = true;\r\n            }\r\n            function ontimeout() {\r\n                timeout = null;\r\n                timedOut = true;\r\n                const err = new Error(`A \"socket\" was not created for HTTP request before ${timeoutMs}ms`);\r\n                err.code = 'ETIMEOUT';\r\n                onerror(err);\r\n            }\r\n            function callbackError(err) {\r\n                if (timedOut)\r\n                    return;\r\n                if (timeout !== null) {\r\n                    clearTimeout(timeout);\r\n                    timeout = null;\r\n                }\r\n                onerror(err);\r\n            }\r\n            function onsocket(socket) {\r\n                let sock;\r\n                function onfree() {\r\n                    freeSocket(sock, opts);\r\n                }\r\n                if (timedOut)\r\n                    return;\r\n                if (timeout != null) {\r\n                    clearTimeout(timeout);\r\n                    timeout = null;\r\n                }\r\n                if (isAgentBase(socket) || isHttpAgent(socket)) {\r\n                    // `socket` is actually an `http.Agent` instance, so\r\n                    // relinquish responsibility for this `req` to the Agent\r\n                    // from here on\r\n                    socket.addRequest(req, opts);\r\n                    return;\r\n                }\r\n                if (socket) {\r\n                    sock = socket;\r\n                    sock.on('free', onfree);\r\n                    req.onSocket(sock);\r\n                    return;\r\n                }\r\n                const err = new Error(`no Duplex stream was returned to agent-base for \\`${req.method} ${req.path}\\``);\r\n                onerror(err);\r\n            }\r\n            if (typeof this.callback !== 'function') {\r\n                onerror(new Error('`callback` is not defined'));\r\n                return;\r\n            }\r\n            if (!this.promisifiedCallback) {\r\n                if (this.callback.length >= 3) {\r\n                    // Legacy callback function - convert to a Promise\r\n                    this.promisifiedCallback = promisify_1.default(this.callback);\r\n                }\r\n                else {\r\n                    this.promisifiedCallback = this.callback;\r\n                }\r\n            }\r\n            if (typeof timeoutMs === 'number' && timeoutMs > 0) {\r\n                timeout = setTimeout(ontimeout, timeoutMs);\r\n            }\r\n            if ('port' in opts && typeof opts.port !== 'number') {\r\n                opts.port = Number(opts.port);\r\n            }\r\n            try {\r\n                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);\r\n            }\r\n            catch (err) {\r\n                Promise.reject(err).catch(callbackError);\r\n            }\r\n        }\r\n        freeSocket(socket, opts) {\r\n            // TODO reuse sockets\r\n            socket.destroy();\r\n        }\r\n        destroy() { }\r\n    }\r\n    createAgent.Agent = Agent;\r\n})(createAgent || (createAgent = {}));\r\n// So that `instanceof` works correctly\r\ncreateAgent.prototype = createAgent.Agent.prototype;\r\nmodule.exports = createAgent;\r\n//# sourceMappingURL=index.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction promisify(fn) {\r\n    return function (req, opts) {\r\n        return new Promise((resolve, reject) => {\r\n            fn.call(this, req, opts, (err, rtn) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve(rtn);\r\n                }\r\n            });\r\n        });\r\n    };\r\n}\r\nexports.default = promisify;\r\n//# sourceMappingURL=promisify.js.map"]}