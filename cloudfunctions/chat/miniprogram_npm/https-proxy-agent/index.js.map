{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\r\n * Module dependencies.\r\n */\r\n\r\nvar net = require('net');\r\nvar tls = require('tls');\r\nvar url = require('url');\r\nvar assert = require('assert');\r\nvar Agent = require('agent-base');\r\nvar inherits = require('util').inherits;\r\nvar debug = require('debug')('https-proxy-agent');\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = HttpsProxyAgent;\r\n\r\n/**\r\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the\r\n * specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction HttpsProxyAgent(opts) {\r\n\tif (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);\r\n\tif ('string' == typeof opts) opts = url.parse(opts);\r\n\tif (!opts)\r\n\t\tthrow new Error(\r\n\t\t\t'an HTTP(S) proxy server `host` and `port` must be specified!'\r\n\t\t);\r\n\tdebug('creating new HttpsProxyAgent instance: %o', opts);\r\n\tAgent.call(this, opts);\r\n\r\n\tvar proxy = Object.assign({}, opts);\r\n\r\n\t// if `true`, then connect to the proxy server over TLS. defaults to `false`.\r\n\tthis.secureProxy = proxy.protocol\r\n\t\t? /^https:?$/i.test(proxy.protocol)\r\n\t\t: false;\r\n\r\n\t// prefer `hostname` over `host`, and set the `port` if needed\r\n\tproxy.host = proxy.hostname || proxy.host;\r\n\tproxy.port = +proxy.port || (this.secureProxy ? 443 : 80);\r\n\r\n\t// ALPN is supported by Node.js >= v5.\r\n\t// attempt to negotiate http/1.1 for proxy servers that support http/2\r\n\tif (this.secureProxy && !('ALPNProtocols' in proxy)) {\r\n\t\tproxy.ALPNProtocols = ['http 1.1'];\r\n\t}\r\n\r\n\tif (proxy.host && proxy.path) {\r\n\t\t// if both a `host` and `path` are specified then it's most likely the\r\n\t\t// result of a `url.parse()` call... we need to remove the `path` portion so\r\n\t\t// that `net.connect()` doesn't attempt to open that as a unix socket file.\r\n\t\tdelete proxy.path;\r\n\t\tdelete proxy.pathname;\r\n\t}\r\n\r\n\tthis.proxy = proxy;\r\n}\r\ninherits(HttpsProxyAgent, Agent);\r\n\r\n/**\r\n * Called when the node-core HTTP client library is creating a new HTTP request.\r\n *\r\n * @api public\r\n */\r\n\r\nHttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {\r\n\tvar proxy = this.proxy;\r\n\r\n\t// create a socket connection to the proxy server\r\n\tvar socket;\r\n\tif (this.secureProxy) {\r\n\t\tsocket = tls.connect(proxy);\r\n\t} else {\r\n\t\tsocket = net.connect(proxy);\r\n\t}\r\n\r\n\t// we need to buffer any HTTP traffic that happens with the proxy before we get\r\n\t// the CONNECT response, so that if the response is anything other than an \"200\"\r\n\t// response code, then we can re-play the \"data\" events on the socket once the\r\n\t// HTTP parser is hooked up...\r\n\tvar buffers = [];\r\n\tvar buffersLength = 0;\r\n\r\n\tfunction read() {\r\n\t\tvar b = socket.read();\r\n\t\tif (b) ondata(b);\r\n\t\telse socket.once('readable', read);\r\n\t}\r\n\r\n\tfunction cleanup() {\r\n\t\tsocket.removeListener('end', onend);\r\n\t\tsocket.removeListener('error', onerror);\r\n\t\tsocket.removeListener('close', onclose);\r\n\t\tsocket.removeListener('readable', read);\r\n\t}\r\n\r\n\tfunction onclose(err) {\r\n\t\tdebug('onclose had error %o', err);\r\n\t}\r\n\r\n\tfunction onend() {\r\n\t\tdebug('onend');\r\n\t}\r\n\r\n\tfunction onerror(err) {\r\n\t\tcleanup();\r\n\t\tfn(err);\r\n\t}\r\n\r\n\tfunction ondata(b) {\r\n\t\tbuffers.push(b);\r\n\t\tbuffersLength += b.length;\r\n\t\tvar buffered = Buffer.concat(buffers, buffersLength);\r\n\t\tvar str = buffered.toString('ascii');\r\n\r\n\t\tif (!~str.indexOf('\\r\\n\\r\\n')) {\r\n\t\t\t// keep buffering\r\n\t\t\tdebug('have not received end of HTTP headers yet...');\r\n\t\t\tread();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar firstLine = str.substring(0, str.indexOf('\\r\\n'));\r\n\t\tvar statusCode = +firstLine.split(' ')[1];\r\n\t\tdebug('got proxy server response: %o', firstLine);\r\n\r\n\t\tif (200 == statusCode) {\r\n\t\t\t// 200 Connected status code!\r\n\t\t\tvar sock = socket;\r\n\r\n\t\t\t// nullify the buffered data since we won't be needing it\r\n\t\t\tbuffers = buffered = null;\r\n\r\n\t\t\tif (opts.secureEndpoint) {\r\n\t\t\t\t// since the proxy is connecting to an SSL server, we have\r\n\t\t\t\t// to upgrade this socket connection to an SSL connection\r\n\t\t\t\tdebug(\r\n\t\t\t\t\t'upgrading proxy-connected socket to TLS connection: %o',\r\n\t\t\t\t\topts.host\r\n\t\t\t\t);\r\n\t\t\t\topts.socket = socket;\r\n\t\t\t\topts.servername = opts.servername || opts.host;\r\n\t\t\t\topts.host = null;\r\n\t\t\t\topts.hostname = null;\r\n\t\t\t\topts.port = null;\r\n\t\t\t\tsock = tls.connect(opts);\r\n\t\t\t}\r\n\r\n\t\t\tcleanup();\r\n\t\t\treq.once('socket', resume);\r\n\t\t\tfn(null, sock);\r\n\t\t} else {\r\n\t\t\t// some other status code that's not 200... need to re-play the HTTP header\r\n\t\t\t// \"data\" events onto the socket once the HTTP machinery is attached so\r\n\t\t\t// that the node core `http` can parse and handle the error status code\r\n\t\t\tcleanup();\r\n\r\n\t\t\t// the original socket is closed, and a new closed socket is\r\n\t\t\t// returned instead, so that the proxy doesn't get the HTTP request\r\n\t\t\t// written to it (which may contain `Authorization` headers or other\r\n\t\t\t// sensitive data).\r\n\t\t\t//\r\n\t\t\t// See: https://hackerone.com/reports/541502\r\n\t\t\tsocket.destroy();\r\n\t\t\tsocket = new net.Socket();\r\n\t\t\tsocket.readable = true;\r\n\r\n\t\t\t// save a reference to the concat'd Buffer for the `onsocket` callback\r\n\t\t\tbuffers = buffered;\r\n\r\n\t\t\t// need to wait for the \"socket\" event to re-play the \"data\" events\r\n\t\t\treq.once('socket', onsocket);\r\n\r\n\t\t\tfn(null, socket);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction onsocket(socket) {\r\n\t\tdebug('replaying proxy buffer for failed request');\r\n\t\tassert(socket.listenerCount('data') > 0);\r\n\r\n\t\t// replay the \"buffers\" Buffer onto the `socket`, since at this point\r\n\t\t// the HTTP module machinery has been hooked up for the user\r\n\t\tsocket.push(buffers);\r\n\r\n\t\t// nullify the cached Buffer instance\r\n\t\tbuffers = null;\r\n\t}\r\n\r\n\tsocket.on('error', onerror);\r\n\tsocket.on('close', onclose);\r\n\tsocket.on('end', onend);\r\n\r\n\tread();\r\n\r\n\tvar hostname = opts.host + ':' + opts.port;\r\n\tvar msg = 'CONNECT ' + hostname + ' HTTP/1.1\\r\\n';\r\n\r\n\tvar headers = Object.assign({}, proxy.headers);\r\n\tif (proxy.auth) {\r\n\t\theaders['Proxy-Authorization'] =\r\n\t\t\t'Basic ' + Buffer.from(proxy.auth).toString('base64');\r\n\t}\r\n\r\n\t// the Host header should only include the port\r\n\t// number when it is a non-standard port\r\n\tvar host = opts.host;\r\n\tif (!isDefaultPort(opts.port, opts.secureEndpoint)) {\r\n\t\thost += ':' + opts.port;\r\n\t}\r\n\theaders['Host'] = host;\r\n\r\n\theaders['Connection'] = 'close';\r\n\tObject.keys(headers).forEach(function(name) {\r\n\t\tmsg += name + ': ' + headers[name] + '\\r\\n';\r\n\t});\r\n\r\n\tsocket.write(msg + '\\r\\n');\r\n};\r\n\r\n/**\r\n * Resumes a socket.\r\n *\r\n * @param {(net.Socket|tls.Socket)} socket The socket to resume\r\n * @api public\r\n */\r\n\r\nfunction resume(socket) {\r\n\tsocket.resume();\r\n}\r\n\r\nfunction isDefaultPort(port, secure) {\r\n\treturn Boolean((!secure && port === 80) || (secure && port === 443));\r\n}\r\n"]}