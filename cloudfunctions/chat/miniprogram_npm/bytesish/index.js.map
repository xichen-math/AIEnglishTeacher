{"version":3,"sources":["node.js","browser.js","core.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nconst crypto = require('crypto')\r\nconst fallback = require('./browser').from\r\nconst bytes = require('./core')\r\n\r\nbytes.from = (_from, encoding) => {\r\n  if (_from instanceof DataView) return _from\r\n  if (_from instanceof ArrayBuffer) return new DataView(_from)\r\n  if (typeof _from === 'string') {\r\n    _from = Buffer.from(_from, encoding)\r\n  }\r\n  if (Buffer.isBuffer(_from)) {\r\n    return new DataView(_from.buffer, _from.byteOffset, _from.byteLength)\r\n  }\r\n  return fallback(_from, encoding)\r\n}\r\nbytes.toString = (_from, encoding) => {\r\n  _from = bytes(_from)\r\n  return Buffer.from(_from.buffer, _from.byteOffset, _from.byteLength).toString(encoding)\r\n}\r\n\r\nbytes.native = (_from, encoding) => {\r\n  if (Buffer.isBuffer(_from)) return _from\r\n  _from = bytes(_from, encoding)\r\n  return Buffer.from(_from.buffer, _from.byteOffset, _from.byteLength)\r\n}\r\n\r\nbytes._randomFill = crypto.randomFillSync\r\n\r\nmodule.exports = bytes\r\n","/* globals atob, btoa, crypto */\r\n/* istanbul ignore file */\r\n\r\nconst bytes = require('./core')\r\n\r\nbytes.from = (_from, _encoding) => {\r\n  if (_from instanceof DataView) return _from\r\n  if (_from instanceof ArrayBuffer) return new DataView(_from)\r\n  let buffer\r\n  if (typeof _from === 'string') {\r\n    if (!_encoding) {\r\n      _encoding = 'utf-8'\r\n    } else if (_encoding === 'base64') {\r\n      buffer = Uint8Array.from(atob(_from), c => c.charCodeAt(0)).buffer\r\n      return new DataView(buffer)\r\n    }\r\n    if (_encoding !== 'utf-8') throw new Error('Browser support for encodings other than utf-8 not implemented')\r\n    return new DataView((new TextEncoder()).encode(_from).buffer)\r\n  } else if (typeof _from === 'object') {\r\n    if (ArrayBuffer.isView(_from)) {\r\n      if (_from.byteLength === _from.buffer.byteLength) return new DataView(_from.buffer)\r\n      else return new DataView(_from.buffer, _from.byteOffset, _from.byteLength)\r\n    }\r\n  }\r\n  throw new Error('Unkown type. Cannot convert to ArrayBuffer')\r\n}\r\n\r\nbytes.toString = (_from, encoding) => {\r\n  _from = bytes(_from, encoding)\r\n  const uint = new Uint8Array(_from.buffer, _from.byteOffset, _from.byteLength)\r\n  const str = String.fromCharCode(...uint)\r\n  if (encoding === 'base64') {\r\n    /* would be nice to find a way to do this directly from a buffer\r\n     * instead of doing two string conversions\r\n     */\r\n    return btoa(str)\r\n  } else {\r\n    return str\r\n  }\r\n}\r\n\r\nbytes.native = (_from, encoding) => {\r\n  if (_from instanceof Uint8Array) return _from\r\n  _from = bytes.from(_from, encoding)\r\n  return new Uint8Array(_from.buffer, _from.byteOffset, _from.byteLength)\r\n}\r\n\r\nif (process.browser) bytes._randomFill = (...args) => crypto.getRandomValues(...args)\r\n\r\nmodule.exports = bytes\r\n","\r\n\r\nconst length = (a, b) => {\r\n  if (a.byteLength === b.byteLength) return a.byteLength\r\n  else if (a.byteLength > b.byteLength) return a.byteLength\r\n  return b.byteLength\r\n}\r\n\r\nconst bytes = (_from, encoding) => bytes.from(_from, encoding)\r\n\r\nbytes.sorter = (a, b) => {\r\n  a = bytes(a)\r\n  b = bytes(b)\r\n  const len = length(a, b)\r\n  let i = 0\r\n  while (i < (len - 1)) {\r\n    if (i >= a.byteLength) return 1\r\n    else if (i >= b.byteLength) return -1\r\n\r\n    if (a.getUint8(i) < b.getUint8(i)) return -1\r\n    else if (a.getUint8(i) > b.getUint8(i)) return 1\r\n    i++\r\n  }\r\n  return 0\r\n}\r\n\r\nbytes.compare = (a, b) => !bytes.sorter(a, b)\r\nbytes.memcopy = (_from, encoding) => {\r\n  const b = bytes(_from, encoding)\r\n  return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength)\r\n}\r\nbytes.arrayBuffer = (_from, encoding) => {\r\n  _from = bytes(_from, encoding)\r\n  if (_from.buffer.byteLength === _from.byteLength) return _from.buffer\r\n  return _from.buffer.slice(_from.byteOffset, _from.byteOffset + _from.byteLength)\r\n}\r\nconst sliceOptions = (_from, start = 0, end = null) => {\r\n  _from = bytes(_from)\r\n  end = (end === null ? _from.byteLength : end) - start\r\n  return [_from.buffer, _from.byteOffset + start, end]\r\n}\r\nbytes.slice = (_from, start, end) => new DataView(...sliceOptions(_from, start, end))\r\n\r\nbytes.memcopySlice = (_from, start, end) => {\r\n  const [buffer, offset, length] = sliceOptions(_from, start, end)\r\n  return buffer.slice(offset, length + offset)\r\n}\r\nbytes.typedArray = (_from, _Class = Uint8Array) => {\r\n  _from = bytes(_from)\r\n  return new _Class(_from.buffer, _from.byteOffset, _from.byteLength / _Class.BYTES_PER_ELEMENT)\r\n}\r\n\r\nbytes.concat = (_from) => {\r\n  _from = Array.from(_from)\r\n  _from = _from.map(b => bytes(b))\r\n  const length = _from.reduce((x, y) => x + y.byteLength, 0)\r\n  const ret = new Uint8Array(length)\r\n  let i = 0\r\n  for (const part of _from) {\r\n    const view = bytes.typedArray(part)\r\n    ret.set(view, i)\r\n    i += view.byteLength\r\n  }\r\n  return ret.buffer\r\n}\r\n\r\nconst maxEntropy = 65536\r\n\r\nbytes.random = length => {\r\n  const ab = new ArrayBuffer(length)\r\n  if (length > maxEntropy) {\r\n    let i = 0\r\n    while (i < ab.byteLength) {\r\n      let len\r\n      if (i + maxEntropy > ab.byteLength) len = ab.byteLength - i\r\n      else len = maxEntropy\r\n      const view = new Uint8Array(ab, i, len)\r\n      i += maxEntropy\r\n      bytes._randomFill(view)\r\n    }\r\n  } else {\r\n    const view = new Uint8Array(ab)\r\n    bytes._randomFill(view)\r\n  }\r\n  return ab\r\n}\r\n\r\nmodule.exports = bytes\r\n"]}