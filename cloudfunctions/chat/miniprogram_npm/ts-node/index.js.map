{"version":3,"sources":["index.js","../package.json"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path_1 = require(\"path\");\r\nconst sourceMapSupport = require(\"source-map-support\");\r\nconst ynModule = require(\"yn\");\r\nconst make_error_1 = require(\"make-error\");\r\nconst util = require(\"util\");\r\n/**\r\n * Registered `ts-node` instance information.\r\n */\r\nexports.REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\r\n/**\r\n * @internal\r\n */\r\nexports.INSPECT_CUSTOM = util.inspect.custom || 'inspect';\r\n/**\r\n * Wrapper around yn module that returns `undefined` instead of `null`.\r\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\r\n */\r\nfunction yn(value) {\r\n    var _a;\r\n    return (_a = ynModule(value)) !== null && _a !== void 0 ? _a : undefined;\r\n}\r\n/**\r\n * Debugging `ts-node`.\r\n */\r\nconst shouldDebug = yn(process.env.TS_NODE_DEBUG);\r\n/** @internal */\r\nexports.debug = shouldDebug ?\r\n    (...args) => console.log(`[ts-node ${new Date().toISOString()}]`, ...args)\r\n    : () => undefined;\r\nconst debugFn = shouldDebug ?\r\n    (key, fn) => {\r\n        let i = 0;\r\n        return (x) => {\r\n            exports.debug(key, x, ++i);\r\n            return fn(x);\r\n        };\r\n    } :\r\n    (_, fn) => fn;\r\n/**\r\n * Export the current version.\r\n */\r\nexports.VERSION = require('../package.json').version;\r\n/**\r\n * Like `Object.assign`, but ignores `undefined` properties.\r\n */\r\nfunction assign(initialValue, ...sources) {\r\n    for (const source of sources) {\r\n        for (const key of Object.keys(source)) {\r\n            const value = source[key];\r\n            if (value !== undefined)\r\n                initialValue[key] = value;\r\n        }\r\n    }\r\n    return initialValue;\r\n}\r\n/**\r\n * Default register options, including values specified via environment\r\n * variables.\r\n */\r\nexports.DEFAULTS = {\r\n    dir: process.env.TS_NODE_DIR,\r\n    emit: yn(process.env.TS_NODE_EMIT),\r\n    scope: yn(process.env.TS_NODE_SCOPE),\r\n    files: yn(process.env.TS_NODE_FILES),\r\n    pretty: yn(process.env.TS_NODE_PRETTY),\r\n    compiler: process.env.TS_NODE_COMPILER,\r\n    compilerOptions: parse(process.env.TS_NODE_COMPILER_OPTIONS),\r\n    ignore: split(process.env.TS_NODE_IGNORE),\r\n    project: process.env.TS_NODE_PROJECT,\r\n    skipProject: yn(process.env.TS_NODE_SKIP_PROJECT),\r\n    skipIgnore: yn(process.env.TS_NODE_SKIP_IGNORE),\r\n    preferTsExts: yn(process.env.TS_NODE_PREFER_TS_EXTS),\r\n    ignoreDiagnostics: split(process.env.TS_NODE_IGNORE_DIAGNOSTICS),\r\n    transpileOnly: yn(process.env.TS_NODE_TRANSPILE_ONLY),\r\n    typeCheck: yn(process.env.TS_NODE_TYPE_CHECK),\r\n    compilerHost: yn(process.env.TS_NODE_COMPILER_HOST),\r\n    logError: yn(process.env.TS_NODE_LOG_ERROR)\r\n};\r\n/**\r\n * Default TypeScript compiler options required by `ts-node`.\r\n */\r\nconst TS_NODE_COMPILER_OPTIONS = {\r\n    sourceMap: true,\r\n    inlineSourceMap: false,\r\n    inlineSources: true,\r\n    declaration: false,\r\n    noEmit: false,\r\n    outDir: '.ts-node'\r\n};\r\n/**\r\n * Split a string array of values.\r\n */\r\nfunction split(value) {\r\n    return typeof value === 'string' ? value.split(/ *, */g) : undefined;\r\n}\r\nexports.split = split;\r\n/**\r\n * Parse a string as JSON.\r\n */\r\nfunction parse(value) {\r\n    return typeof value === 'string' ? JSON.parse(value) : undefined;\r\n}\r\nexports.parse = parse;\r\n/**\r\n * Replace backslashes with forward slashes.\r\n */\r\nfunction normalizeSlashes(value) {\r\n    return value.replace(/\\\\/g, '/');\r\n}\r\nexports.normalizeSlashes = normalizeSlashes;\r\n/**\r\n * TypeScript diagnostics error.\r\n */\r\nclass TSError extends make_error_1.BaseError {\r\n    constructor(diagnosticText, diagnosticCodes) {\r\n        super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\r\n        this.diagnosticText = diagnosticText;\r\n        this.diagnosticCodes = diagnosticCodes;\r\n        this.name = 'TSError';\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    [exports.INSPECT_CUSTOM]() {\r\n        return this.diagnosticText;\r\n    }\r\n}\r\nexports.TSError = TSError;\r\n/**\r\n * Cached fs operation wrapper.\r\n */\r\nfunction cachedLookup(fn) {\r\n    const cache = new Map();\r\n    return (arg) => {\r\n        if (!cache.has(arg)) {\r\n            cache.set(arg, fn(arg));\r\n        }\r\n        return cache.get(arg);\r\n    };\r\n}\r\n/** @internal */\r\nfunction getExtensions(config) {\r\n    const tsExtensions = ['.ts'];\r\n    const jsExtensions = [];\r\n    // Enable additional extensions when JSX or `allowJs` is enabled.\r\n    if (config.options.jsx)\r\n        tsExtensions.push('.tsx');\r\n    if (config.options.allowJs)\r\n        jsExtensions.push('.js');\r\n    if (config.options.jsx && config.options.allowJs)\r\n        jsExtensions.push('.jsx');\r\n    return { tsExtensions, jsExtensions };\r\n}\r\nexports.getExtensions = getExtensions;\r\n/**\r\n * Register TypeScript compiler instance onto node.js\r\n */\r\nfunction register(opts = {}) {\r\n    const originalJsHandler = require.extensions['.js']; // tslint:disable-line\r\n    const service = create(opts);\r\n    const { tsExtensions, jsExtensions } = getExtensions(service.config);\r\n    const extensions = [...tsExtensions, ...jsExtensions];\r\n    // Expose registered instance globally.\r\n    process[exports.REGISTER_INSTANCE] = service;\r\n    // Register the extensions.\r\n    registerExtensions(service.options.preferTsExts, extensions, service, originalJsHandler);\r\n    return service;\r\n}\r\nexports.register = register;\r\n/**\r\n * Create TypeScript compiler instance.\r\n */\r\nfunction create(rawOptions = {}) {\r\n    var _a, _b;\r\n    const dir = (_a = rawOptions.dir) !== null && _a !== void 0 ? _a : exports.DEFAULTS.dir;\r\n    const compilerName = (_b = rawOptions.compiler) !== null && _b !== void 0 ? _b : exports.DEFAULTS.compiler;\r\n    const cwd = dir ? path_1.resolve(dir) : process.cwd();\r\n    /**\r\n     * Load the typescript compiler. It is required to load the tsconfig but might\r\n     * be changed by the tsconfig, so we sometimes have to do this twice.\r\n     */\r\n    function loadCompiler(name) {\r\n        const compiler = require.resolve(name || 'typescript', { paths: [cwd, __dirname] });\r\n        const ts = require(compiler);\r\n        return { compiler, ts };\r\n    }\r\n    // Compute minimum options to read the config file.\r\n    let { compiler, ts } = loadCompiler(compilerName);\r\n    // Read config file and merge new options between env and CLI options.\r\n    const { config, options: tsconfigOptions } = readConfig(cwd, ts, rawOptions);\r\n    const options = assign({}, exports.DEFAULTS, tsconfigOptions || {}, rawOptions);\r\n    // If `compiler` option changed based on tsconfig, re-load the compiler.\r\n    if (options.compiler !== compilerName) {\r\n        ({ compiler, ts } = loadCompiler(options.compiler));\r\n    }\r\n    const readFile = options.readFile || ts.sys.readFile;\r\n    const fileExists = options.fileExists || ts.sys.fileExists;\r\n    const transpileOnly = options.transpileOnly === true || options.typeCheck === false;\r\n    const transformers = options.transformers || undefined;\r\n    const ignoreDiagnostics = [\r\n        6059,\r\n        18002,\r\n        18003,\r\n        ...(options.ignoreDiagnostics || [])\r\n    ].map(Number);\r\n    const configDiagnosticList = filterDiagnostics(config.errors, ignoreDiagnostics);\r\n    const outputCache = new Map();\r\n    const isScoped = options.scope ? (relname) => relname.charAt(0) !== '.' : () => true;\r\n    const shouldIgnore = createIgnore(options.skipIgnore ? [] : (options.ignore || ['(?:^|/)node_modules/']).map(str => new RegExp(str)));\r\n    const diagnosticHost = {\r\n        getNewLine: () => ts.sys.newLine,\r\n        getCurrentDirectory: () => cwd,\r\n        getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? x => x : x => x.toLowerCase()\r\n    };\r\n    // Install source map support and read from memory cache.\r\n    sourceMapSupport.install({\r\n        environment: 'node',\r\n        retrieveFile(path) {\r\n            var _a;\r\n            return ((_a = outputCache.get(normalizeSlashes(path))) === null || _a === void 0 ? void 0 : _a.content) || '';\r\n        }\r\n    });\r\n    const formatDiagnostics = process.stdout.isTTY || options.pretty\r\n        ? (ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics)\r\n        : ts.formatDiagnostics;\r\n    function createTSError(diagnostics) {\r\n        const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\r\n        const diagnosticCodes = diagnostics.map(x => x.code);\r\n        return new TSError(diagnosticText, diagnosticCodes);\r\n    }\r\n    function reportTSError(configDiagnosticList) {\r\n        const error = createTSError(configDiagnosticList);\r\n        if (options.logError) {\r\n            // Print error in red color and continue execution.\r\n            console.error('\\x1b[31m%s\\x1b[0m', error);\r\n        }\r\n        else {\r\n            // Throw error and exit the script.\r\n            throw error;\r\n        }\r\n    }\r\n    // Render the configuration errors.\r\n    if (configDiagnosticList.length)\r\n        reportTSError(configDiagnosticList);\r\n    /**\r\n     * Get the extension for a transpiled file.\r\n     */\r\n    const getExtension = config.options.jsx === ts.JsxEmit.Preserve ?\r\n        ((path) => /\\.[tj]sx$/.test(path) ? '.jsx' : '.js') :\r\n        ((_) => '.js');\r\n    /**\r\n     * Create the basic required function using transpile mode.\r\n     */\r\n    let getOutput;\r\n    let getTypeInfo;\r\n    const getOutputTranspileOnly = (code, fileName, overrideCompilerOptions) => {\r\n        const result = ts.transpileModule(code, {\r\n            fileName,\r\n            compilerOptions: overrideCompilerOptions ? Object.assign(Object.assign({}, config.options), overrideCompilerOptions) : config.options,\r\n            reportDiagnostics: true\r\n        });\r\n        const diagnosticList = filterDiagnostics(result.diagnostics || [], ignoreDiagnostics);\r\n        if (diagnosticList.length)\r\n            reportTSError(diagnosticList);\r\n        return [result.outputText, result.sourceMapText];\r\n    };\r\n    // Use full language services when the fast option is disabled.\r\n    if (!transpileOnly) {\r\n        const fileContents = new Map();\r\n        const rootFileNames = config.fileNames.slice();\r\n        const cachedReadFile = cachedLookup(debugFn('readFile', readFile));\r\n        // Use language services by default (TODO: invert next major version).\r\n        if (!options.compilerHost) {\r\n            let projectVersion = 1;\r\n            const fileVersions = new Map(rootFileNames.map(fileName => [fileName, 0]));\r\n            const getCustomTransformers = () => {\r\n                if (typeof transformers === 'function') {\r\n                    const program = service.getProgram();\r\n                    return program ? transformers(program) : undefined;\r\n                }\r\n                return transformers;\r\n            };\r\n            // Create the compiler host for type checking.\r\n            const serviceHost = {\r\n                getProjectVersion: () => String(projectVersion),\r\n                getScriptFileNames: () => Array.from(fileVersions.keys()),\r\n                getScriptVersion: (fileName) => {\r\n                    const version = fileVersions.get(fileName);\r\n                    return version ? version.toString() : '';\r\n                },\r\n                getScriptSnapshot(fileName) {\r\n                    let contents = fileContents.get(fileName);\r\n                    // Read contents into TypeScript memory cache.\r\n                    if (contents === undefined) {\r\n                        contents = cachedReadFile(fileName);\r\n                        if (contents === undefined)\r\n                            return;\r\n                        fileVersions.set(fileName, 1);\r\n                        fileContents.set(fileName, contents);\r\n                    }\r\n                    return ts.ScriptSnapshot.fromString(contents);\r\n                },\r\n                readFile: cachedReadFile,\r\n                readDirectory: ts.sys.readDirectory,\r\n                getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),\r\n                fileExists: cachedLookup(debugFn('fileExists', fileExists)),\r\n                directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),\r\n                getNewLine: () => ts.sys.newLine,\r\n                useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\r\n                getCurrentDirectory: () => cwd,\r\n                getCompilationSettings: () => config.options,\r\n                getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\r\n                getCustomTransformers: getCustomTransformers\r\n            };\r\n            const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);\r\n            const service = ts.createLanguageService(serviceHost, registry);\r\n            const updateMemoryCache = (contents, fileName) => {\r\n                // Add to `rootFiles` when discovered for the first time.\r\n                if (!fileVersions.has(fileName)) {\r\n                    rootFileNames.push(fileName);\r\n                }\r\n                const previousVersion = fileVersions.get(fileName) || 0;\r\n                const previousContents = fileContents.get(fileName);\r\n                // Avoid incrementing cache when nothing has changed.\r\n                if (contents !== previousContents) {\r\n                    fileVersions.set(fileName, previousVersion + 1);\r\n                    fileContents.set(fileName, contents);\r\n                    // Increment project version for every file change.\r\n                    projectVersion++;\r\n                }\r\n            };\r\n            let previousProgram = undefined;\r\n            getOutput = (code, fileName) => {\r\n                updateMemoryCache(code, fileName);\r\n                const programBefore = service.getProgram();\r\n                if (programBefore !== previousProgram) {\r\n                    exports.debug(`compiler rebuilt Program instance when getting output for ${fileName}`);\r\n                }\r\n                const output = service.getEmitOutput(fileName);\r\n                // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\r\n                const diagnostics = service.getSemanticDiagnostics(fileName)\r\n                    .concat(service.getSyntacticDiagnostics(fileName));\r\n                const programAfter = service.getProgram();\r\n                exports.debug('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ', programBefore === programAfter);\r\n                previousProgram = programAfter;\r\n                const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics);\r\n                if (diagnosticList.length)\r\n                    reportTSError(diagnosticList);\r\n                if (output.emitSkipped) {\r\n                    throw new TypeError(`${path_1.relative(cwd, fileName)}: Emit skipped`);\r\n                }\r\n                // Throw an error when requiring `.d.ts` files.\r\n                if (output.outputFiles.length === 0) {\r\n                    throw new TypeError(`Unable to require file: ${path_1.relative(cwd, fileName)}\\n` +\r\n                        'This is usually the result of a faulty configuration or import. ' +\r\n                        'Make sure there is a `.js`, `.json` or other executable extension with ' +\r\n                        'loader attached before `ts-node` available.');\r\n                }\r\n                return [output.outputFiles[1].text, output.outputFiles[0].text];\r\n            };\r\n            getTypeInfo = (code, fileName, position) => {\r\n                updateMemoryCache(code, fileName);\r\n                const info = service.getQuickInfoAtPosition(fileName, position);\r\n                const name = ts.displayPartsToString(info ? info.displayParts : []);\r\n                const comment = ts.displayPartsToString(info ? info.documentation : []);\r\n                return { name, comment };\r\n            };\r\n        }\r\n        else {\r\n            const sys = Object.assign(Object.assign(Object.assign({}, ts.sys), diagnosticHost), { readFile: (fileName) => {\r\n                    const cacheContents = fileContents.get(fileName);\r\n                    if (cacheContents !== undefined)\r\n                        return cacheContents;\r\n                    return cachedReadFile(fileName);\r\n                }, readDirectory: ts.sys.readDirectory, getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)), fileExists: cachedLookup(debugFn('fileExists', fileExists)), directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)), resolvePath: cachedLookup(debugFn('resolvePath', ts.sys.resolvePath)), realpath: ts.sys.realpath ? cachedLookup(debugFn('realpath', ts.sys.realpath)) : undefined });\r\n            const host = ts.createIncrementalCompilerHost\r\n                ? ts.createIncrementalCompilerHost(config.options, sys)\r\n                : Object.assign(Object.assign({}, sys), { getSourceFile: (fileName, languageVersion) => {\r\n                        const contents = sys.readFile(fileName);\r\n                        if (contents === undefined)\r\n                            return;\r\n                        return ts.createSourceFile(fileName, contents, languageVersion);\r\n                    }, getDefaultLibLocation: () => normalizeSlashes(path_1.dirname(compiler)), getDefaultLibFileName: () => normalizeSlashes(path_1.join(path_1.dirname(compiler), ts.getDefaultLibFileName(config.options))), useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames });\r\n            // Fallback for older TypeScript releases without incremental API.\r\n            let builderProgram = ts.createIncrementalProgram\r\n                ? ts.createIncrementalProgram({\r\n                    rootNames: rootFileNames.slice(),\r\n                    options: config.options,\r\n                    host: host,\r\n                    configFileParsingDiagnostics: config.errors,\r\n                    projectReferences: config.projectReferences\r\n                })\r\n                : ts.createEmitAndSemanticDiagnosticsBuilderProgram(rootFileNames.slice(), config.options, host, undefined, config.errors, config.projectReferences);\r\n            // Read and cache custom transformers.\r\n            const customTransformers = typeof transformers === 'function'\r\n                ? transformers(builderProgram.getProgram())\r\n                : transformers;\r\n            // Set the file contents into cache manually.\r\n            const updateMemoryCache = (contents, fileName) => {\r\n                const sourceFile = builderProgram.getSourceFile(fileName);\r\n                fileContents.set(fileName, contents);\r\n                // Add to `rootFiles` when discovered by compiler for the first time.\r\n                if (sourceFile === undefined) {\r\n                    rootFileNames.push(fileName);\r\n                }\r\n                // Update program when file changes.\r\n                if (sourceFile === undefined || sourceFile.text !== contents) {\r\n                    builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(rootFileNames.slice(), config.options, host, builderProgram, config.errors, config.projectReferences);\r\n                }\r\n            };\r\n            getOutput = (code, fileName) => {\r\n                const output = ['', ''];\r\n                updateMemoryCache(code, fileName);\r\n                const sourceFile = builderProgram.getSourceFile(fileName);\r\n                if (!sourceFile)\r\n                    throw new TypeError(`Unable to read file: ${fileName}`);\r\n                const program = builderProgram.getProgram();\r\n                const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\r\n                const diagnosticList = filterDiagnostics(diagnostics, ignoreDiagnostics);\r\n                if (diagnosticList.length)\r\n                    reportTSError(diagnosticList);\r\n                const result = builderProgram.emit(sourceFile, (path, file, writeByteOrderMark) => {\r\n                    if (path.endsWith('.map')) {\r\n                        output[1] = file;\r\n                    }\r\n                    else {\r\n                        output[0] = file;\r\n                    }\r\n                    if (options.emit)\r\n                        sys.writeFile(path, file, writeByteOrderMark);\r\n                }, undefined, undefined, customTransformers);\r\n                if (result.emitSkipped) {\r\n                    throw new TypeError(`${path_1.relative(cwd, fileName)}: Emit skipped`);\r\n                }\r\n                // Throw an error when requiring files that cannot be compiled.\r\n                if (output[0] === '') {\r\n                    if (program.isSourceFileFromExternalLibrary(sourceFile)) {\r\n                        throw new TypeError(`Unable to compile file from external library: ${path_1.relative(cwd, fileName)}`);\r\n                    }\r\n                    throw new TypeError(`Unable to require file: ${path_1.relative(cwd, fileName)}\\n` +\r\n                        'This is usually the result of a faulty configuration or import. ' +\r\n                        'Make sure there is a `.js`, `.json` or other executable extension with ' +\r\n                        'loader attached before `ts-node` available.');\r\n                }\r\n                return output;\r\n            };\r\n            getTypeInfo = (code, fileName, position) => {\r\n                updateMemoryCache(code, fileName);\r\n                const sourceFile = builderProgram.getSourceFile(fileName);\r\n                if (!sourceFile)\r\n                    throw new TypeError(`Unable to read file: ${fileName}`);\r\n                const node = getTokenAtPosition(ts, sourceFile, position);\r\n                const checker = builderProgram.getProgram().getTypeChecker();\r\n                const symbol = checker.getSymbolAtLocation(node);\r\n                if (!symbol)\r\n                    return { name: '', comment: '' };\r\n                const type = checker.getTypeOfSymbolAtLocation(symbol, node);\r\n                const signatures = [...type.getConstructSignatures(), ...type.getCallSignatures()];\r\n                return {\r\n                    name: signatures.length ? signatures.map(x => checker.signatureToString(x)).join('\\n') : checker.typeToString(type),\r\n                    comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])\r\n                };\r\n            };\r\n            // Write `.tsbuildinfo` when `--build` is enabled.\r\n            if (options.emit && config.options.incremental) {\r\n                process.on('exit', () => {\r\n                    // Emits `.tsbuildinfo` to filesystem.\r\n                    builderProgram.getProgram().emitBuildInfo();\r\n                });\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (typeof transformers === 'function') {\r\n            throw new TypeError('Transformers function is unavailable in \"--transpile-only\"');\r\n        }\r\n        getOutput = getOutputTranspileOnly;\r\n        getTypeInfo = () => {\r\n            throw new TypeError('Type information is unavailable in \"--transpile-only\"');\r\n        };\r\n    }\r\n    const cannotCompileViaBothCodepathsErrorMessage = 'Cannot compile the same file via both `require()` and ESM hooks codepaths. ' +\r\n        'This breaks source-map-support, which cannot tell the difference between the two sourcemaps. ' +\r\n        'To avoid this problem, load each .ts file as only ESM or only CommonJS.';\r\n    // Create a simple TypeScript compiler proxy.\r\n    function compile(code, fileName, lineOffset = 0) {\r\n        const normalizedFileName = normalizeSlashes(fileName);\r\n        const [value, sourceMap] = getOutput(code, normalizedFileName);\r\n        const output = updateOutput(value, normalizedFileName, sourceMap, getExtension);\r\n        outputCache.set(normalizedFileName, { content: output });\r\n        return output;\r\n    }\r\n    let active = true;\r\n    const enabled = (enabled) => enabled === undefined ? active : (active = !!enabled);\r\n    const ignored = (fileName) => {\r\n        if (!active)\r\n            return true;\r\n        const relname = path_1.relative(cwd, fileName);\r\n        if (!config.options.allowJs) {\r\n            const ext = path_1.extname(fileName);\r\n            if (ext === '.js' || ext === '.jsx')\r\n                return true;\r\n        }\r\n        return !isScoped(relname) || shouldIgnore(relname);\r\n    };\r\n    return { ts, config, compile, getTypeInfo, ignored, enabled, options };\r\n}\r\nexports.create = create;\r\n/**\r\n * Check if the filename should be ignored.\r\n */\r\nfunction createIgnore(ignore) {\r\n    return (relname) => {\r\n        const path = normalizeSlashes(relname);\r\n        return ignore.some(x => x.test(path));\r\n    };\r\n}\r\n/**\r\n * \"Refreshes\" an extension on `require.extensions`.\r\n *\r\n * @param {string} ext\r\n */\r\nfunction reorderRequireExtension(ext) {\r\n    const old = require.extensions[ext]; // tslint:disable-line\r\n    delete require.extensions[ext]; // tslint:disable-line\r\n    require.extensions[ext] = old; // tslint:disable-line\r\n}\r\n/**\r\n * Register the extensions to support when importing files.\r\n */\r\nfunction registerExtensions(preferTsExts, extensions, register, originalJsHandler) {\r\n    // Register new extensions.\r\n    for (const ext of extensions) {\r\n        registerExtension(ext, register, originalJsHandler);\r\n    }\r\n    if (preferTsExts) {\r\n        // tslint:disable-next-line\r\n        const preferredExtensions = new Set([...extensions, ...Object.keys(require.extensions)]);\r\n        for (const ext of preferredExtensions)\r\n            reorderRequireExtension(ext);\r\n    }\r\n}\r\n/**\r\n * Register the extension for node.\r\n */\r\nfunction registerExtension(ext, register, originalHandler) {\r\n    const old = require.extensions[ext] || originalHandler; // tslint:disable-line\r\n    require.extensions[ext] = function (m, filename) {\r\n        if (register.ignored(filename))\r\n            return old(m, filename);\r\n        const _compile = m._compile;\r\n        m._compile = function (code, fileName) {\r\n            exports.debug('module._compile', fileName);\r\n            return _compile.call(this, register.compile(code, fileName), fileName);\r\n        };\r\n        return old(m, filename);\r\n    };\r\n}\r\n/**\r\n * Do post-processing on config options to support `ts-node`.\r\n */\r\nfunction fixConfig(ts, config) {\r\n    // Delete options that *should not* be passed through.\r\n    delete config.options.out;\r\n    delete config.options.outFile;\r\n    delete config.options.composite;\r\n    delete config.options.declarationDir;\r\n    delete config.options.declarationMap;\r\n    delete config.options.emitDeclarationOnly;\r\n    // Target ES5 output by default (instead of ES3).\r\n    if (config.options.target === undefined) {\r\n        config.options.target = ts.ScriptTarget.ES5;\r\n    }\r\n    // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\r\n    if (config.options.module === undefined) {\r\n        config.options.module = ts.ModuleKind.CommonJS;\r\n    }\r\n    return config;\r\n}\r\n/**\r\n * Load TypeScript configuration. Returns the parsed TypeScript config and\r\n * any `ts-node` options specified in the config file.\r\n */\r\nfunction readConfig(cwd, ts, rawOptions) {\r\n    var _a, _b;\r\n    let config = { compilerOptions: {} };\r\n    let basePath = cwd;\r\n    let configFileName = undefined;\r\n    const { fileExists = ts.sys.fileExists, readFile = ts.sys.readFile, skipProject = exports.DEFAULTS.skipProject, project = exports.DEFAULTS.project } = rawOptions;\r\n    // Read project configuration when available.\r\n    if (!skipProject) {\r\n        configFileName = project\r\n            ? path_1.resolve(cwd, project)\r\n            : ts.findConfigFile(cwd, fileExists);\r\n        if (configFileName) {\r\n            const result = ts.readConfigFile(configFileName, readFile);\r\n            // Return diagnostics.\r\n            if (result.error) {\r\n                return {\r\n                    config: { errors: [result.error], fileNames: [], options: {} },\r\n                    options: {}\r\n                };\r\n            }\r\n            config = result.config;\r\n            basePath = path_1.dirname(configFileName);\r\n        }\r\n    }\r\n    // Fix ts-node options that come from tsconfig.json\r\n    const tsconfigOptions = Object.assign({}, config['ts-node']);\r\n    // Remove resolution of \"files\".\r\n    const files = (_b = (_a = rawOptions.files) !== null && _a !== void 0 ? _a : tsconfigOptions.files) !== null && _b !== void 0 ? _b : exports.DEFAULTS.files;\r\n    if (!files) {\r\n        config.files = [];\r\n        config.include = [];\r\n    }\r\n    // Override default configuration options `ts-node` requires.\r\n    config.compilerOptions = Object.assign({}, config.compilerOptions, exports.DEFAULTS.compilerOptions, tsconfigOptions.compilerOptions, rawOptions.compilerOptions, TS_NODE_COMPILER_OPTIONS);\r\n    const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\r\n        fileExists,\r\n        readFile,\r\n        readDirectory: ts.sys.readDirectory,\r\n        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames\r\n    }, basePath, undefined, configFileName));\r\n    return { config: fixedConfig, options: tsconfigOptions };\r\n}\r\n/**\r\n * Update the output remapping the source map.\r\n */\r\nfunction updateOutput(outputText, fileName, sourceMap, getExtension) {\r\n    const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');\r\n    const sourceMapContent = `data:application/json;charset=utf-8;base64,${base64Map}`;\r\n    const sourceMapLength = `${path_1.basename(fileName)}.map`.length + (getExtension(fileName).length - path_1.extname(fileName).length);\r\n    return outputText.slice(0, -sourceMapLength) + sourceMapContent;\r\n}\r\n/**\r\n * Update the source map contents for improved output.\r\n */\r\nfunction updateSourceMap(sourceMapText, fileName) {\r\n    const sourceMap = JSON.parse(sourceMapText);\r\n    sourceMap.file = fileName;\r\n    sourceMap.sources = [fileName];\r\n    delete sourceMap.sourceRoot;\r\n    return JSON.stringify(sourceMap);\r\n}\r\n/**\r\n * Filter diagnostics.\r\n */\r\nfunction filterDiagnostics(diagnostics, ignore) {\r\n    return diagnostics.filter(x => ignore.indexOf(x.code) === -1);\r\n}\r\n/**\r\n * Get token at file position.\r\n *\r\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\r\n */\r\nfunction getTokenAtPosition(ts, sourceFile, position) {\r\n    let current = sourceFile;\r\n    outer: while (true) {\r\n        for (const child of current.getChildren(sourceFile)) {\r\n            const start = child.getFullStart();\r\n            if (start > position)\r\n                break;\r\n            const end = child.getEnd();\r\n            if (position <= end) {\r\n                current = child;\r\n                continue outer;\r\n            }\r\n        }\r\n        return current;\r\n    }\r\n}\r\n//# sourceMappingURL=index.js.map","module.exports = {\r\n  \"name\": \"ts-node\",\r\n  \"version\": \"8.10.2\",\r\n  \"description\": \"TypeScript execution environment and REPL for node.js, with source map support\",\r\n  \"main\": \"dist/index.js\",\r\n  \"types\": \"dist/index.d.ts\",\r\n  \"bin\": {\r\n    \"ts-node\": \"dist/bin.js\",\r\n    \"ts-script\": \"dist/bin-script-deprecated.js\",\r\n    \"ts-node-script\": \"dist/bin-script.js\",\r\n    \"ts-node-transpile-only\": \"dist/bin-transpile.js\"\r\n  },\r\n  \"files\": [\r\n    \"dist/\",\r\n    \"dist-raw/\",\r\n    \"register/\",\r\n    \"esm.mjs\",\r\n    \"LICENSE\",\r\n    \"tsconfig.schema.json\",\r\n    \"tsconfig.schemastore-schema.json\"\r\n  ],\r\n  \"scripts\": {\r\n    \"lint\": \"tslint \\\"src/**/*.ts\\\" --project tsconfig.json\",\r\n    \"lint-fix\": \"tslint \\\"src/**/*.ts\\\" --project tsconfig.json --fix\",\r\n    \"clean\": \"rimraf dist && rimraf tsconfig.schema.json && rimraf tsconfig.schemastore-schema.json && rimraf tests/ts-node-packed.tgz\",\r\n    \"build\": \"npm run build-nopack && npm run build-pack\",\r\n    \"build-nopack\": \"npm run clean && npm run build-tsc && npm run build-configSchema\",\r\n    \"build-tsc\": \"tsc\",\r\n    \"build-configSchema\": \"typescript-json-schema --topRef --refs --validationKeywords allOf --out tsconfig.schema.json tsconfig.json TsConfigSchema && node --require ./register ./scripts/create-merged-schema\",\r\n    \"build-pack\": \"node ./scripts/build-pack.js\",\r\n    \"test-spec\": \"mocha dist/**/*.spec.js -R spec --bail\",\r\n    \"test-cov\": \"istanbul cover node_modules/mocha/bin/_mocha -- \\\"dist/**/*.spec.js\\\" -R spec --bail\",\r\n    \"test\": \"npm run build && npm run lint && npm run test-cov\",\r\n    \"prepare\": \"npm run build-nopack\"\r\n  },\r\n  \"engines\": {\r\n    \"node\": \">=6.0.0\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git://github.com/TypeStrong/ts-node.git\"\r\n  },\r\n  \"keywords\": [\r\n    \"typescript\",\r\n    \"node\",\r\n    \"runtime\",\r\n    \"environment\",\r\n    \"ts\",\r\n    \"compiler\"\r\n  ],\r\n  \"author\": {\r\n    \"name\": \"Blake Embrey\",\r\n    \"email\": \"hello@blakeembrey.com\",\r\n    \"url\": \"http://blakeembrey.me\"\r\n  },\r\n  \"license\": \"MIT\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/TypeStrong/ts-node/issues\"\r\n  },\r\n  \"homepage\": \"https://github.com/TypeStrong/ts-node\",\r\n  \"devDependencies\": {\r\n    \"@types/chai\": \"^4.0.4\",\r\n    \"@types/diff\": \"^4.0.2\",\r\n    \"@types/mocha\": \"^5.2.7\",\r\n    \"@types/node\": \"13.13.5\",\r\n    \"@types/proxyquire\": \"^1.3.28\",\r\n    \"@types/react\": \"^16.0.2\",\r\n    \"@types/semver\": \"^7.1.0\",\r\n    \"@types/source-map-support\": \"^0.5.0\",\r\n    \"axios\": \"^0.19.0\",\r\n    \"chai\": \"^4.0.1\",\r\n    \"istanbul\": \"^0.4.0\",\r\n    \"mocha\": \"^6.2.2\",\r\n    \"ntypescript\": \"^1.201507091536.1\",\r\n    \"proxyquire\": \"^2.0.0\",\r\n    \"react\": \"^16.0.0\",\r\n    \"rimraf\": \"^3.0.0\",\r\n    \"semver\": \"^7.1.3\",\r\n    \"tslint\": \"^6.1.0\",\r\n    \"tslint-config-standard\": \"^9.0.0\",\r\n    \"typescript\": \"3.8.3\",\r\n    \"typescript-json-schema\": \"^0.42.0\",\r\n    \"util.promisify\": \"^1.0.1\"\r\n  },\r\n  \"peerDependencies\": {\r\n    \"typescript\": \">=2.7\"\r\n  },\r\n  \"dependencies\": {\r\n    \"arg\": \"^4.1.0\",\r\n    \"diff\": \"^4.0.1\",\r\n    \"make-error\": \"^1.1.1\",\r\n    \"source-map-support\": \"^0.5.17\",\r\n    \"yn\": \"3.1.1\"\r\n  }\r\n}\r\n"]}