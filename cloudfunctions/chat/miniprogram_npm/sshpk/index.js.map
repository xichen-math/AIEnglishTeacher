{"version":3,"sources":["index.js","key.js","algs.js","fingerprint.js","errors.js","private-key.js","signature.js","utils.js","ssh-buffer.js","dhe.js","ed-compat.js","formats/auto.js","formats/pem.js","formats/pkcs1.js","formats/pkcs8.js","formats/ssh-private.js","formats/rfc4253.js","formats/ssh.js","formats/dnssec.js","formats/putty.js","certificate.js","identity.js","formats/openssh-cert.js","formats/x509.js","formats/x509-pem.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,AENA,ADGA,AHSA,ACHA;ACFA,AENA,ADGA,AHSA,ACHA;ACFA,AENA,ADGA,AHSA,ACHA;ACFA,AENA,ADGA,AHSA,ACHA,AIZA;AHUA,AENA,ADGA,AHSA,ACHA,AIZA;AHUA,AENA,ADGA,AHSA,ACHA,AIZA;AHUA,AENA,ADGA,AHSA,ACHA,AIZA,ACHA;AJaA,AENA,ADGA,AHSA,ACHA,AIZA,ACHA;AJaA,AENA,ADGA,AHSA,ACHA,AIZA,ACHA;AJaA,AENA,ADGA,AHSA,ACHA,AIZA,ACHA,ACHA;ALgBA,AENA,ADGA,AHSA,ACHA,AIZA,ACHA,ACHA;ALgBA,AENA,ADGA,AHSA,ACHA,AIZA,ACHA,ACHA;ALgBA,AENA,ADGA,AHSA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AENA,ADGA,AHSA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AENA,ADGA,AHSA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ALeA,ADGA,AHSA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ALeA,ADGA,AHSA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ALeA,ADGA,AHSA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AHSA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AHSA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AHSA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,AXiCA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,AXiCA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,AXiCA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,AZoCA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,AZoCA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,AZoCA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,AbuCA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,AbuCA,ACHA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,AZoCA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,AbuCA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,AbuCA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,AbuCA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,ACHA,Ad0CA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,AENA,ADGA,Ad0CA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,AENA,ADGA,Ad0CA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,AENA,ADGA,Ad0CA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AENA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AENA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AENA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AOrBA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AhBgDA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AIZA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AIZA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,ANkBA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AIZA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AIZA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AIZA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AIZA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AMlBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AMlBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AMlBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,ANkBA,ADGA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ACHA,APqBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,AQxBA,AOrBA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AOrBA,ADGA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AMlBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AMlBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AMlBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AMlBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AMlBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AENA,AMlBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,AENA,ADGA;ALgBA,AkBtDA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AHSA,ADGA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,ANkBA,Ae7CA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AKfA,AJYA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AIZA,ACHA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,ApB4DA,AKfA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,ACHA,AQxBA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AV8BA,ACHA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Af6CA,ACHA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AS3BA,AIZA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,AT2BA,ACHA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,ARwBA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,ARwBA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,ARwBA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,ARwBA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,ARwBA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AavCA,ARwBA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AKfA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AKfA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AKfA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AKfA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AKfA,AS3BA,AFMA,Ad0CA;AatCA,AXiCA,AKfA,AS3BA,AFMA,Ad0CA;AatCA,ANkBA,AS3BA,AFMA,Ad0CA;AatCA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA,AFMA;ADIA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AHUA,ANkBA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AT4BA,AS3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// Copyright 2015 Joyent, Inc.\r\n\r\nvar Key = require('./key');\r\nvar Fingerprint = require('./fingerprint');\r\nvar Signature = require('./signature');\r\nvar PrivateKey = require('./private-key');\r\nvar Certificate = require('./certificate');\r\nvar Identity = require('./identity');\r\nvar errs = require('./errors');\r\n\r\nmodule.exports = {\r\n\t/* top-level classes */\r\n\tKey: Key,\r\n\tparseKey: Key.parse,\r\n\tFingerprint: Fingerprint,\r\n\tparseFingerprint: Fingerprint.parse,\r\n\tSignature: Signature,\r\n\tparseSignature: Signature.parse,\r\n\tPrivateKey: PrivateKey,\r\n\tparsePrivateKey: PrivateKey.parse,\r\n\tgeneratePrivateKey: PrivateKey.generate,\r\n\tCertificate: Certificate,\r\n\tparseCertificate: Certificate.parse,\r\n\tcreateSelfSignedCertificate: Certificate.createSelfSigned,\r\n\tcreateCertificate: Certificate.create,\r\n\tIdentity: Identity,\r\n\tidentityFromDN: Identity.parseDN,\r\n\tidentityForHost: Identity.forHost,\r\n\tidentityForUser: Identity.forUser,\r\n\tidentityForEmail: Identity.forEmail,\r\n\tidentityFromArray: Identity.fromArray,\r\n\r\n\t/* errors */\r\n\tFingerprintFormatError: errs.FingerprintFormatError,\r\n\tInvalidAlgorithmError: errs.InvalidAlgorithmError,\r\n\tKeyParseError: errs.KeyParseError,\r\n\tSignatureParseError: errs.SignatureParseError,\r\n\tKeyEncryptedError: errs.KeyEncryptedError,\r\n\tCertificateParseError: errs.CertificateParseError\r\n};\r\n","// Copyright 2018 Joyent, Inc.\r\n\r\nmodule.exports = Key;\r\n\r\nvar assert = require('assert-plus');\r\nvar algs = require('./algs');\r\nvar crypto = require('crypto');\r\nvar Fingerprint = require('./fingerprint');\r\nvar Signature = require('./signature');\r\nvar DiffieHellman = require('./dhe').DiffieHellman;\r\nvar errs = require('./errors');\r\nvar utils = require('./utils');\r\nvar PrivateKey = require('./private-key');\r\nvar edCompat;\r\n\r\ntry {\r\n\tedCompat = require('./ed-compat');\r\n} catch (e) {\r\n\t/* Just continue through, and bail out if we try to use it. */\r\n}\r\n\r\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\r\nvar KeyParseError = errs.KeyParseError;\r\n\r\nvar formats = {};\r\nformats['auto'] = require('./formats/auto');\r\nformats['pem'] = require('./formats/pem');\r\nformats['pkcs1'] = require('./formats/pkcs1');\r\nformats['pkcs8'] = require('./formats/pkcs8');\r\nformats['rfc4253'] = require('./formats/rfc4253');\r\nformats['ssh'] = require('./formats/ssh');\r\nformats['ssh-private'] = require('./formats/ssh-private');\r\nformats['openssh'] = formats['ssh-private'];\r\nformats['dnssec'] = require('./formats/dnssec');\r\nformats['putty'] = require('./formats/putty');\r\nformats['ppk'] = formats['putty'];\r\n\r\nfunction Key(opts) {\r\n\tassert.object(opts, 'options');\r\n\tassert.arrayOfObject(opts.parts, 'options.parts');\r\n\tassert.string(opts.type, 'options.type');\r\n\tassert.optionalString(opts.comment, 'options.comment');\r\n\r\n\tvar algInfo = algs.info[opts.type];\r\n\tif (typeof (algInfo) !== 'object')\r\n\t\tthrow (new InvalidAlgorithmError(opts.type));\r\n\r\n\tvar partLookup = {};\r\n\tfor (var i = 0; i < opts.parts.length; ++i) {\r\n\t\tvar part = opts.parts[i];\r\n\t\tpartLookup[part.name] = part;\r\n\t}\r\n\r\n\tthis.type = opts.type;\r\n\tthis.parts = opts.parts;\r\n\tthis.part = partLookup;\r\n\tthis.comment = undefined;\r\n\tthis.source = opts.source;\r\n\r\n\t/* for speeding up hashing/fingerprint operations */\r\n\tthis._rfc4253Cache = opts._rfc4253Cache;\r\n\tthis._hashCache = {};\r\n\r\n\tvar sz;\r\n\tthis.curve = undefined;\r\n\tif (this.type === 'ecdsa') {\r\n\t\tvar curve = this.part.curve.data.toString();\r\n\t\tthis.curve = curve;\r\n\t\tsz = algs.curves[curve].size;\r\n\t} else if (this.type === 'ed25519' || this.type === 'curve25519') {\r\n\t\tsz = 256;\r\n\t\tthis.curve = 'curve25519';\r\n\t} else {\r\n\t\tvar szPart = this.part[algInfo.sizePart];\r\n\t\tsz = szPart.data.length;\r\n\t\tsz = sz * 8 - utils.countZeros(szPart.data);\r\n\t}\r\n\tthis.size = sz;\r\n}\r\n\r\nKey.formats = formats;\r\n\r\nKey.prototype.toBuffer = function (format, options) {\r\n\tif (format === undefined)\r\n\t\tformat = 'ssh';\r\n\tassert.string(format, 'format');\r\n\tassert.object(formats[format], 'formats[format]');\r\n\tassert.optionalObject(options, 'options');\r\n\r\n\tif (format === 'rfc4253') {\r\n\t\tif (this._rfc4253Cache === undefined)\r\n\t\t\tthis._rfc4253Cache = formats['rfc4253'].write(this);\r\n\t\treturn (this._rfc4253Cache);\r\n\t}\r\n\r\n\treturn (formats[format].write(this, options));\r\n};\r\n\r\nKey.prototype.toString = function (format, options) {\r\n\treturn (this.toBuffer(format, options).toString());\r\n};\r\n\r\nKey.prototype.hash = function (algo, type) {\r\n\tassert.string(algo, 'algorithm');\r\n\tassert.optionalString(type, 'type');\r\n\tif (type === undefined)\r\n\t\ttype = 'ssh';\r\n\talgo = algo.toLowerCase();\r\n\tif (algs.hashAlgs[algo] === undefined)\r\n\t\tthrow (new InvalidAlgorithmError(algo));\r\n\r\n\tvar cacheKey = algo + '||' + type;\r\n\tif (this._hashCache[cacheKey])\r\n\t\treturn (this._hashCache[cacheKey]);\r\n\r\n\tvar buf;\r\n\tif (type === 'ssh') {\r\n\t\tbuf = this.toBuffer('rfc4253');\r\n\t} else if (type === 'spki') {\r\n\t\tbuf = formats.pkcs8.pkcs8ToBuffer(this);\r\n\t} else {\r\n\t\tthrow (new Error('Hash type ' + type + ' not supported'));\r\n\t}\r\n\tvar hash = crypto.createHash(algo).update(buf).digest();\r\n\tthis._hashCache[cacheKey] = hash;\r\n\treturn (hash);\r\n};\r\n\r\nKey.prototype.fingerprint = function (algo, type) {\r\n\tif (algo === undefined)\r\n\t\talgo = 'sha256';\r\n\tif (type === undefined)\r\n\t\ttype = 'ssh';\r\n\tassert.string(algo, 'algorithm');\r\n\tassert.string(type, 'type');\r\n\tvar opts = {\r\n\t\ttype: 'key',\r\n\t\thash: this.hash(algo, type),\r\n\t\talgorithm: algo,\r\n\t\thashType: type\r\n\t};\r\n\treturn (new Fingerprint(opts));\r\n};\r\n\r\nKey.prototype.defaultHashAlgorithm = function () {\r\n\tvar hashAlgo = 'sha1';\r\n\tif (this.type === 'rsa')\r\n\t\thashAlgo = 'sha256';\r\n\tif (this.type === 'dsa' && this.size > 1024)\r\n\t\thashAlgo = 'sha256';\r\n\tif (this.type === 'ed25519')\r\n\t\thashAlgo = 'sha512';\r\n\tif (this.type === 'ecdsa') {\r\n\t\tif (this.size <= 256)\r\n\t\t\thashAlgo = 'sha256';\r\n\t\telse if (this.size <= 384)\r\n\t\t\thashAlgo = 'sha384';\r\n\t\telse\r\n\t\t\thashAlgo = 'sha512';\r\n\t}\r\n\treturn (hashAlgo);\r\n};\r\n\r\nKey.prototype.createVerify = function (hashAlgo) {\r\n\tif (hashAlgo === undefined)\r\n\t\thashAlgo = this.defaultHashAlgorithm();\r\n\tassert.string(hashAlgo, 'hash algorithm');\r\n\r\n\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\r\n\tif (this.type === 'ed25519' && edCompat !== undefined)\r\n\t\treturn (new edCompat.Verifier(this, hashAlgo));\r\n\tif (this.type === 'curve25519')\r\n\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\r\n\t\t    'signing or verification'));\r\n\r\n\tvar v, nm, err;\r\n\ttry {\r\n\t\tnm = hashAlgo.toUpperCase();\r\n\t\tv = crypto.createVerify(nm);\r\n\t} catch (e) {\r\n\t\terr = e;\r\n\t}\r\n\tif (v === undefined || (err instanceof Error &&\r\n\t    err.message.match(/Unknown message digest/))) {\r\n\t\tnm = 'RSA-';\r\n\t\tnm += hashAlgo.toUpperCase();\r\n\t\tv = crypto.createVerify(nm);\r\n\t}\r\n\tassert.ok(v, 'failed to create verifier');\r\n\tvar oldVerify = v.verify.bind(v);\r\n\tvar key = this.toBuffer('pkcs8');\r\n\tvar curve = this.curve;\r\n\tvar self = this;\r\n\tv.verify = function (signature, fmt) {\r\n\t\tif (Signature.isSignature(signature, [2, 0])) {\r\n\t\t\tif (signature.type !== self.type)\r\n\t\t\t\treturn (false);\r\n\t\t\tif (signature.hashAlgorithm &&\r\n\t\t\t    signature.hashAlgorithm !== hashAlgo)\r\n\t\t\t\treturn (false);\r\n\t\t\tif (signature.curve && self.type === 'ecdsa' &&\r\n\t\t\t    signature.curve !== curve)\r\n\t\t\t\treturn (false);\r\n\t\t\treturn (oldVerify(key, signature.toBuffer('asn1')));\r\n\r\n\t\t} else if (typeof (signature) === 'string' ||\r\n\t\t    Buffer.isBuffer(signature)) {\r\n\t\t\treturn (oldVerify(key, signature, fmt));\r\n\r\n\t\t/*\r\n\t\t * Avoid doing this on valid arguments, walking the prototype\r\n\t\t * chain can be quite slow.\r\n\t\t */\r\n\t\t} else if (Signature.isSignature(signature, [1, 0])) {\r\n\t\t\tthrow (new Error('signature was created by too old ' +\r\n\t\t\t    'a version of sshpk and cannot be verified'));\r\n\r\n\t\t} else {\r\n\t\t\tthrow (new TypeError('signature must be a string, ' +\r\n\t\t\t    'Buffer, or Signature object'));\r\n\t\t}\r\n\t};\r\n\treturn (v);\r\n};\r\n\r\nKey.prototype.createDiffieHellman = function () {\r\n\tif (this.type === 'rsa')\r\n\t\tthrow (new Error('RSA keys do not support Diffie-Hellman'));\r\n\r\n\treturn (new DiffieHellman(this));\r\n};\r\nKey.prototype.createDH = Key.prototype.createDiffieHellman;\r\n\r\nKey.parse = function (data, format, options) {\r\n\tif (typeof (data) !== 'string')\r\n\t\tassert.buffer(data, 'data');\r\n\tif (format === undefined)\r\n\t\tformat = 'auto';\r\n\tassert.string(format, 'format');\r\n\tif (typeof (options) === 'string')\r\n\t\toptions = { filename: options };\r\n\tassert.optionalObject(options, 'options');\r\n\tif (options === undefined)\r\n\t\toptions = {};\r\n\tassert.optionalString(options.filename, 'options.filename');\r\n\tif (options.filename === undefined)\r\n\t\toptions.filename = '(unnamed)';\r\n\r\n\tassert.object(formats[format], 'formats[format]');\r\n\r\n\ttry {\r\n\t\tvar k = formats[format].read(data, options);\r\n\t\tif (k instanceof PrivateKey)\r\n\t\t\tk = k.toPublic();\r\n\t\tif (!k.comment)\r\n\t\t\tk.comment = options.filename;\r\n\t\treturn (k);\r\n\t} catch (e) {\r\n\t\tif (e.name === 'KeyEncryptedError')\r\n\t\t\tthrow (e);\r\n\t\tthrow (new KeyParseError(options.filename, format, e));\r\n\t}\r\n};\r\n\r\nKey.isKey = function (obj, ver) {\r\n\treturn (utils.isCompatible(obj, Key, ver));\r\n};\r\n\r\n/*\r\n * API versions for Key:\r\n * [1,0] -- initial ver, may take Signature for createVerify or may not\r\n * [1,1] -- added pkcs1, pkcs8 formats\r\n * [1,2] -- added auto, ssh-private, openssh formats\r\n * [1,3] -- added defaultHashAlgorithm\r\n * [1,4] -- added ed support, createDH\r\n * [1,5] -- first explicitly tagged version\r\n * [1,6] -- changed ed25519 part names\r\n * [1,7] -- spki hash types\r\n */\r\nKey.prototype._sshpkApiVersion = [1, 7];\r\n\r\nKey._oldVersionDetect = function (obj) {\r\n\tassert.func(obj.toBuffer);\r\n\tassert.func(obj.fingerprint);\r\n\tif (obj.createDH)\r\n\t\treturn ([1, 4]);\r\n\tif (obj.defaultHashAlgorithm)\r\n\t\treturn ([1, 3]);\r\n\tif (obj.formats['auto'])\r\n\t\treturn ([1, 2]);\r\n\tif (obj.formats['pkcs1'])\r\n\t\treturn ([1, 1]);\r\n\treturn ([1, 0]);\r\n};\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nvar Buffer = require('safer-buffer').Buffer;\r\n\r\nvar algInfo = {\r\n\t'dsa': {\r\n\t\tparts: ['p', 'q', 'g', 'y'],\r\n\t\tsizePart: 'p'\r\n\t},\r\n\t'rsa': {\r\n\t\tparts: ['e', 'n'],\r\n\t\tsizePart: 'n'\r\n\t},\r\n\t'ecdsa': {\r\n\t\tparts: ['curve', 'Q'],\r\n\t\tsizePart: 'Q'\r\n\t},\r\n\t'ed25519': {\r\n\t\tparts: ['A'],\r\n\t\tsizePart: 'A'\r\n\t}\r\n};\r\nalgInfo['curve25519'] = algInfo['ed25519'];\r\n\r\nvar algPrivInfo = {\r\n\t'dsa': {\r\n\t\tparts: ['p', 'q', 'g', 'y', 'x']\r\n\t},\r\n\t'rsa': {\r\n\t\tparts: ['n', 'e', 'd', 'iqmp', 'p', 'q']\r\n\t},\r\n\t'ecdsa': {\r\n\t\tparts: ['curve', 'Q', 'd']\r\n\t},\r\n\t'ed25519': {\r\n\t\tparts: ['A', 'k']\r\n\t}\r\n};\r\nalgPrivInfo['curve25519'] = algPrivInfo['ed25519'];\r\n\r\nvar hashAlgs = {\r\n\t'md5': true,\r\n\t'sha1': true,\r\n\t'sha256': true,\r\n\t'sha384': true,\r\n\t'sha512': true\r\n};\r\n\r\n/*\r\n * Taken from\r\n * http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf\r\n */\r\nvar curves = {\r\n\t'nistp256': {\r\n\t\tsize: 256,\r\n\t\tpkcs8oid: '1.2.840.10045.3.1.7',\r\n\t\tp: Buffer.from(('00' +\r\n\t\t    'ffffffff 00000001 00000000 00000000' +\r\n\t\t    '00000000 ffffffff ffffffff ffffffff').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\ta: Buffer.from(('00' +\r\n\t\t    'FFFFFFFF 00000001 00000000 00000000' +\r\n\t\t    '00000000 FFFFFFFF FFFFFFFF FFFFFFFC').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\tb: Buffer.from((\r\n\t\t    '5ac635d8 aa3a93e7 b3ebbd55 769886bc' +\r\n\t\t    '651d06b0 cc53b0f6 3bce3c3e 27d2604b').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\ts: Buffer.from(('00' +\r\n\t\t    'c49d3608 86e70493 6a6678e1 139d26b7' +\r\n\t\t    '819f7e90').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\tn: Buffer.from(('00' +\r\n\t\t    'ffffffff 00000000 ffffffff ffffffff' +\r\n\t\t    'bce6faad a7179e84 f3b9cac2 fc632551').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\tG: Buffer.from(('04' +\r\n\t\t    '6b17d1f2 e12c4247 f8bce6e5 63a440f2' +\r\n\t\t    '77037d81 2deb33a0 f4a13945 d898c296' +\r\n\t\t    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16' +\r\n\t\t    '2bce3357 6b315ece cbb64068 37bf51f5').\r\n\t\t    replace(/ /g, ''), 'hex')\r\n\t},\r\n\t'nistp384': {\r\n\t\tsize: 384,\r\n\t\tpkcs8oid: '1.3.132.0.34',\r\n\t\tp: Buffer.from(('00' +\r\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\r\n\t\t    'ffffffff ffffffff ffffffff fffffffe' +\r\n\t\t    'ffffffff 00000000 00000000 ffffffff').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\ta: Buffer.from(('00' +\r\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\r\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE' +\r\n\t\t    'FFFFFFFF 00000000 00000000 FFFFFFFC').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\tb: Buffer.from((\r\n\t\t    'b3312fa7 e23ee7e4 988e056b e3f82d19' +\r\n\t\t    '181d9c6e fe814112 0314088f 5013875a' +\r\n\t\t    'c656398d 8a2ed19d 2a85c8ed d3ec2aef').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\ts: Buffer.from(('00' +\r\n\t\t    'a335926a a319a27a 1d00896a 6773a482' +\r\n\t\t    '7acdac73').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\tn: Buffer.from(('00' +\r\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\r\n\t\t    'ffffffff ffffffff c7634d81 f4372ddf' +\r\n\t\t    '581a0db2 48b0a77a ecec196a ccc52973').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\tG: Buffer.from(('04' +\r\n\t\t    'aa87ca22 be8b0537 8eb1c71e f320ad74' +\r\n\t\t    '6e1d3b62 8ba79b98 59f741e0 82542a38' +\r\n\t\t    '5502f25d bf55296c 3a545e38 72760ab7' +\r\n\t\t    '3617de4a 96262c6f 5d9e98bf 9292dc29' +\r\n\t\t    'f8f41dbd 289a147c e9da3113 b5f0b8c0' +\r\n\t\t    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f').\r\n\t\t    replace(/ /g, ''), 'hex')\r\n\t},\r\n\t'nistp521': {\r\n\t\tsize: 521,\r\n\t\tpkcs8oid: '1.3.132.0.35',\r\n\t\tp: Buffer.from((\r\n\t\t    '01ffffff ffffffff ffffffff ffffffff' +\r\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\r\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\r\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\r\n\t\t    'ffff').replace(/ /g, ''), 'hex'),\r\n\t\ta: Buffer.from(('01FF' +\r\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\r\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\r\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +\r\n\t\t    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\tb: Buffer.from(('51' +\r\n\t\t    '953eb961 8e1c9a1f 929a21a0 b68540ee' +\r\n\t\t    'a2da725b 99b315f3 b8b48991 8ef109e1' +\r\n\t\t    '56193951 ec7e937b 1652c0bd 3bb1bf07' +\r\n\t\t    '3573df88 3d2c34f1 ef451fd4 6b503f00').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\ts: Buffer.from(('00' +\r\n\t\t    'd09e8800 291cb853 96cc6717 393284aa' +\r\n\t\t    'a0da64ba').replace(/ /g, ''), 'hex'),\r\n\t\tn: Buffer.from(('01ff' +\r\n\t\t    'ffffffff ffffffff ffffffff ffffffff' +\r\n\t\t    'ffffffff ffffffff ffffffff fffffffa' +\r\n\t\t    '51868783 bf2f966b 7fcc0148 f709a5d0' +\r\n\t\t    '3bb5c9b8 899c47ae bb6fb71e 91386409').\r\n\t\t    replace(/ /g, ''), 'hex'),\r\n\t\tG: Buffer.from(('04' +\r\n\t\t    '00c6 858e06b7 0404e9cd 9e3ecb66 2395b442' +\r\n\t\t         '9c648139 053fb521 f828af60 6b4d3dba' +\r\n\t\t         'a14b5e77 efe75928 fe1dc127 a2ffa8de' +\r\n\t\t         '3348b3c1 856a429b f97e7e31 c2e5bd66' +\r\n\t\t    '0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9' +\r\n\t\t         '98f54449 579b4468 17afbd17 273e662c' +\r\n\t\t         '97ee7299 5ef42640 c550b901 3fad0761' +\r\n\t\t         '353c7086 a272c240 88be9476 9fd16650').\r\n\t\t    replace(/ /g, ''), 'hex')\r\n\t}\r\n};\r\n\r\nmodule.exports = {\r\n\tinfo: algInfo,\r\n\tprivInfo: algPrivInfo,\r\n\thashAlgs: hashAlgs,\r\n\tcurves: curves\r\n};\r\n","// Copyright 2018 Joyent, Inc.\r\n\r\nmodule.exports = Fingerprint;\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('./algs');\r\nvar crypto = require('crypto');\r\nvar errs = require('./errors');\r\nvar Key = require('./key');\r\nvar PrivateKey = require('./private-key');\r\nvar Certificate = require('./certificate');\r\nvar utils = require('./utils');\r\n\r\nvar FingerprintFormatError = errs.FingerprintFormatError;\r\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\r\n\r\nfunction Fingerprint(opts) {\r\n\tassert.object(opts, 'options');\r\n\tassert.string(opts.type, 'options.type');\r\n\tassert.buffer(opts.hash, 'options.hash');\r\n\tassert.string(opts.algorithm, 'options.algorithm');\r\n\r\n\tthis.algorithm = opts.algorithm.toLowerCase();\r\n\tif (algs.hashAlgs[this.algorithm] !== true)\r\n\t\tthrow (new InvalidAlgorithmError(this.algorithm));\r\n\r\n\tthis.hash = opts.hash;\r\n\tthis.type = opts.type;\r\n\tthis.hashType = opts.hashType;\r\n}\r\n\r\nFingerprint.prototype.toString = function (format) {\r\n\tif (format === undefined) {\r\n\t\tif (this.algorithm === 'md5' || this.hashType === 'spki')\r\n\t\t\tformat = 'hex';\r\n\t\telse\r\n\t\t\tformat = 'base64';\r\n\t}\r\n\tassert.string(format);\r\n\r\n\tswitch (format) {\r\n\tcase 'hex':\r\n\t\tif (this.hashType === 'spki')\r\n\t\t\treturn (this.hash.toString('hex'));\r\n\t\treturn (addColons(this.hash.toString('hex')));\r\n\tcase 'base64':\r\n\t\tif (this.hashType === 'spki')\r\n\t\t\treturn (this.hash.toString('base64'));\r\n\t\treturn (sshBase64Format(this.algorithm,\r\n\t\t    this.hash.toString('base64')));\r\n\tdefault:\r\n\t\tthrow (new FingerprintFormatError(undefined, format));\r\n\t}\r\n};\r\n\r\nFingerprint.prototype.matches = function (other) {\r\n\tassert.object(other, 'key or certificate');\r\n\tif (this.type === 'key' && this.hashType !== 'ssh') {\r\n\t\tutils.assertCompatible(other, Key, [1, 7], 'key with spki');\r\n\t\tif (PrivateKey.isPrivateKey(other)) {\r\n\t\t\tutils.assertCompatible(other, PrivateKey, [1, 6],\r\n\t\t\t    'privatekey with spki support');\r\n\t\t}\r\n\t} else if (this.type === 'key') {\r\n\t\tutils.assertCompatible(other, Key, [1, 0], 'key');\r\n\t} else {\r\n\t\tutils.assertCompatible(other, Certificate, [1, 0],\r\n\t\t    'certificate');\r\n\t}\r\n\r\n\tvar theirHash = other.hash(this.algorithm, this.hashType);\r\n\tvar theirHash2 = crypto.createHash(this.algorithm).\r\n\t    update(theirHash).digest('base64');\r\n\r\n\tif (this.hash2 === undefined)\r\n\t\tthis.hash2 = crypto.createHash(this.algorithm).\r\n\t\t    update(this.hash).digest('base64');\r\n\r\n\treturn (this.hash2 === theirHash2);\r\n};\r\n\r\n/*JSSTYLED*/\r\nvar base64RE = /^[A-Za-z0-9+\\/=]+$/;\r\n/*JSSTYLED*/\r\nvar hexRE = /^[a-fA-F0-9]+$/;\r\n\r\nFingerprint.parse = function (fp, options) {\r\n\tassert.string(fp, 'fingerprint');\r\n\r\n\tvar alg, hash, enAlgs;\r\n\tif (Array.isArray(options)) {\r\n\t\tenAlgs = options;\r\n\t\toptions = {};\r\n\t}\r\n\tassert.optionalObject(options, 'options');\r\n\tif (options === undefined)\r\n\t\toptions = {};\r\n\tif (options.enAlgs !== undefined)\r\n\t\tenAlgs = options.enAlgs;\r\n\tif (options.algorithms !== undefined)\r\n\t\tenAlgs = options.algorithms;\r\n\tassert.optionalArrayOfString(enAlgs, 'algorithms');\r\n\r\n\tvar hashType = 'ssh';\r\n\tif (options.hashType !== undefined)\r\n\t\thashType = options.hashType;\r\n\tassert.string(hashType, 'options.hashType');\r\n\r\n\tvar parts = fp.split(':');\r\n\tif (parts.length == 2) {\r\n\t\talg = parts[0].toLowerCase();\r\n\t\tif (!base64RE.test(parts[1]))\r\n\t\t\tthrow (new FingerprintFormatError(fp));\r\n\t\ttry {\r\n\t\t\thash = Buffer.from(parts[1], 'base64');\r\n\t\t} catch (e) {\r\n\t\t\tthrow (new FingerprintFormatError(fp));\r\n\t\t}\r\n\t} else if (parts.length > 2) {\r\n\t\talg = 'md5';\r\n\t\tif (parts[0].toLowerCase() === 'md5')\r\n\t\t\tparts = parts.slice(1);\r\n\t\tparts = parts.map(function (p) {\r\n\t\t\twhile (p.length < 2)\r\n\t\t\t\tp = '0' + p;\r\n\t\t\tif (p.length > 2)\r\n\t\t\t\tthrow (new FingerprintFormatError(fp));\r\n\t\t\treturn (p);\r\n\t\t});\r\n\t\tparts = parts.join('');\r\n\t\tif (!hexRE.test(parts) || parts.length % 2 !== 0)\r\n\t\t\tthrow (new FingerprintFormatError(fp));\r\n\t\ttry {\r\n\t\t\thash = Buffer.from(parts, 'hex');\r\n\t\t} catch (e) {\r\n\t\t\tthrow (new FingerprintFormatError(fp));\r\n\t\t}\r\n\t} else {\r\n\t\tif (hexRE.test(fp)) {\r\n\t\t\thash = Buffer.from(fp, 'hex');\r\n\t\t} else if (base64RE.test(fp)) {\r\n\t\t\thash = Buffer.from(fp, 'base64');\r\n\t\t} else {\r\n\t\t\tthrow (new FingerprintFormatError(fp));\r\n\t\t}\r\n\r\n\t\tswitch (hash.length) {\r\n\t\tcase 32:\r\n\t\t\talg = 'sha256';\r\n\t\t\tbreak;\r\n\t\tcase 16:\r\n\t\t\talg = 'md5';\r\n\t\t\tbreak;\r\n\t\tcase 20:\r\n\t\t\talg = 'sha1';\r\n\t\t\tbreak;\r\n\t\tcase 64:\r\n\t\t\talg = 'sha512';\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow (new FingerprintFormatError(fp));\r\n\t\t}\r\n\r\n\t\t/* Plain hex/base64: guess it's probably SPKI unless told. */\r\n\t\tif (options.hashType === undefined)\r\n\t\t\thashType = 'spki';\r\n\t}\r\n\r\n\tif (alg === undefined)\r\n\t\tthrow (new FingerprintFormatError(fp));\r\n\r\n\tif (algs.hashAlgs[alg] === undefined)\r\n\t\tthrow (new InvalidAlgorithmError(alg));\r\n\r\n\tif (enAlgs !== undefined) {\r\n\t\tenAlgs = enAlgs.map(function (a) { return a.toLowerCase(); });\r\n\t\tif (enAlgs.indexOf(alg) === -1)\r\n\t\t\tthrow (new InvalidAlgorithmError(alg));\r\n\t}\r\n\r\n\treturn (new Fingerprint({\r\n\t\talgorithm: alg,\r\n\t\thash: hash,\r\n\t\ttype: options.type || 'key',\r\n\t\thashType: hashType\r\n\t}));\r\n};\r\n\r\nfunction addColons(s) {\r\n\t/*JSSTYLED*/\r\n\treturn (s.replace(/(.{2})(?=.)/g, '$1:'));\r\n}\r\n\r\nfunction base64Strip(s) {\r\n\t/*JSSTYLED*/\r\n\treturn (s.replace(/=*$/, ''));\r\n}\r\n\r\nfunction sshBase64Format(alg, h) {\r\n\treturn (alg.toUpperCase() + ':' + base64Strip(h));\r\n}\r\n\r\nFingerprint.isFingerprint = function (obj, ver) {\r\n\treturn (utils.isCompatible(obj, Fingerprint, ver));\r\n};\r\n\r\n/*\r\n * API versions for Fingerprint:\r\n * [1,0] -- initial ver\r\n * [1,1] -- first tagged ver\r\n * [1,2] -- hashType and spki support\r\n */\r\nFingerprint.prototype._sshpkApiVersion = [1, 2];\r\n\r\nFingerprint._oldVersionDetect = function (obj) {\r\n\tassert.func(obj.toString);\r\n\tassert.func(obj.matches);\r\n\treturn ([1, 0]);\r\n};\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nvar assert = require('assert-plus');\r\nvar util = require('util');\r\n\r\nfunction FingerprintFormatError(fp, format) {\r\n\tif (Error.captureStackTrace)\r\n\t\tError.captureStackTrace(this, FingerprintFormatError);\r\n\tthis.name = 'FingerprintFormatError';\r\n\tthis.fingerprint = fp;\r\n\tthis.format = format;\r\n\tthis.message = 'Fingerprint format is not supported, or is invalid: ';\r\n\tif (fp !== undefined)\r\n\t\tthis.message += ' fingerprint = ' + fp;\r\n\tif (format !== undefined)\r\n\t\tthis.message += ' format = ' + format;\r\n}\r\nutil.inherits(FingerprintFormatError, Error);\r\n\r\nfunction InvalidAlgorithmError(alg) {\r\n\tif (Error.captureStackTrace)\r\n\t\tError.captureStackTrace(this, InvalidAlgorithmError);\r\n\tthis.name = 'InvalidAlgorithmError';\r\n\tthis.algorithm = alg;\r\n\tthis.message = 'Algorithm \"' + alg + '\" is not supported';\r\n}\r\nutil.inherits(InvalidAlgorithmError, Error);\r\n\r\nfunction KeyParseError(name, format, innerErr) {\r\n\tif (Error.captureStackTrace)\r\n\t\tError.captureStackTrace(this, KeyParseError);\r\n\tthis.name = 'KeyParseError';\r\n\tthis.format = format;\r\n\tthis.keyName = name;\r\n\tthis.innerErr = innerErr;\r\n\tthis.message = 'Failed to parse ' + name + ' as a valid ' + format +\r\n\t    ' format key: ' + innerErr.message;\r\n}\r\nutil.inherits(KeyParseError, Error);\r\n\r\nfunction SignatureParseError(type, format, innerErr) {\r\n\tif (Error.captureStackTrace)\r\n\t\tError.captureStackTrace(this, SignatureParseError);\r\n\tthis.name = 'SignatureParseError';\r\n\tthis.type = type;\r\n\tthis.format = format;\r\n\tthis.innerErr = innerErr;\r\n\tthis.message = 'Failed to parse the given data as a ' + type +\r\n\t    ' signature in ' + format + ' format: ' + innerErr.message;\r\n}\r\nutil.inherits(SignatureParseError, Error);\r\n\r\nfunction CertificateParseError(name, format, innerErr) {\r\n\tif (Error.captureStackTrace)\r\n\t\tError.captureStackTrace(this, CertificateParseError);\r\n\tthis.name = 'CertificateParseError';\r\n\tthis.format = format;\r\n\tthis.certName = name;\r\n\tthis.innerErr = innerErr;\r\n\tthis.message = 'Failed to parse ' + name + ' as a valid ' + format +\r\n\t    ' format certificate: ' + innerErr.message;\r\n}\r\nutil.inherits(CertificateParseError, Error);\r\n\r\nfunction KeyEncryptedError(name, format) {\r\n\tif (Error.captureStackTrace)\r\n\t\tError.captureStackTrace(this, KeyEncryptedError);\r\n\tthis.name = 'KeyEncryptedError';\r\n\tthis.format = format;\r\n\tthis.keyName = name;\r\n\tthis.message = 'The ' + format + ' format key ' + name + ' is ' +\r\n\t    'encrypted (password-protected), and no passphrase was ' +\r\n\t    'provided in `options`';\r\n}\r\nutil.inherits(KeyEncryptedError, Error);\r\n\r\nmodule.exports = {\r\n\tFingerprintFormatError: FingerprintFormatError,\r\n\tInvalidAlgorithmError: InvalidAlgorithmError,\r\n\tKeyParseError: KeyParseError,\r\n\tSignatureParseError: SignatureParseError,\r\n\tKeyEncryptedError: KeyEncryptedError,\r\n\tCertificateParseError: CertificateParseError\r\n};\r\n","// Copyright 2017 Joyent, Inc.\r\n\r\nmodule.exports = PrivateKey;\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('./algs');\r\nvar crypto = require('crypto');\r\nvar Fingerprint = require('./fingerprint');\r\nvar Signature = require('./signature');\r\nvar errs = require('./errors');\r\nvar util = require('util');\r\nvar utils = require('./utils');\r\nvar dhe = require('./dhe');\r\nvar generateECDSA = dhe.generateECDSA;\r\nvar generateED25519 = dhe.generateED25519;\r\nvar edCompat = require('./ed-compat');\r\nvar nacl = require('tweetnacl');\r\n\r\nvar Key = require('./key');\r\n\r\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\r\nvar KeyParseError = errs.KeyParseError;\r\nvar KeyEncryptedError = errs.KeyEncryptedError;\r\n\r\nvar formats = {};\r\nformats['auto'] = require('./formats/auto');\r\nformats['pem'] = require('./formats/pem');\r\nformats['pkcs1'] = require('./formats/pkcs1');\r\nformats['pkcs8'] = require('./formats/pkcs8');\r\nformats['rfc4253'] = require('./formats/rfc4253');\r\nformats['ssh-private'] = require('./formats/ssh-private');\r\nformats['openssh'] = formats['ssh-private'];\r\nformats['ssh'] = formats['ssh-private'];\r\nformats['dnssec'] = require('./formats/dnssec');\r\nformats['putty'] = require('./formats/putty');\r\n\r\nfunction PrivateKey(opts) {\r\n\tassert.object(opts, 'options');\r\n\tKey.call(this, opts);\r\n\r\n\tthis._pubCache = undefined;\r\n}\r\nutil.inherits(PrivateKey, Key);\r\n\r\nPrivateKey.formats = formats;\r\n\r\nPrivateKey.prototype.toBuffer = function (format, options) {\r\n\tif (format === undefined)\r\n\t\tformat = 'pkcs1';\r\n\tassert.string(format, 'format');\r\n\tassert.object(formats[format], 'formats[format]');\r\n\tassert.optionalObject(options, 'options');\r\n\r\n\treturn (formats[format].write(this, options));\r\n};\r\n\r\nPrivateKey.prototype.hash = function (algo, type) {\r\n\treturn (this.toPublic().hash(algo, type));\r\n};\r\n\r\nPrivateKey.prototype.fingerprint = function (algo, type) {\r\n\treturn (this.toPublic().fingerprint(algo, type));\r\n};\r\n\r\nPrivateKey.prototype.toPublic = function () {\r\n\tif (this._pubCache)\r\n\t\treturn (this._pubCache);\r\n\r\n\tvar algInfo = algs.info[this.type];\r\n\tvar pubParts = [];\r\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\r\n\t\tvar p = algInfo.parts[i];\r\n\t\tpubParts.push(this.part[p]);\r\n\t}\r\n\r\n\tthis._pubCache = new Key({\r\n\t\ttype: this.type,\r\n\t\tsource: this,\r\n\t\tparts: pubParts\r\n\t});\r\n\tif (this.comment)\r\n\t\tthis._pubCache.comment = this.comment;\r\n\treturn (this._pubCache);\r\n};\r\n\r\nPrivateKey.prototype.derive = function (newType) {\r\n\tassert.string(newType, 'type');\r\n\tvar priv, pub, pair;\r\n\r\n\tif (this.type === 'ed25519' && newType === 'curve25519') {\r\n\t\tpriv = this.part.k.data;\r\n\t\tif (priv[0] === 0x00)\r\n\t\t\tpriv = priv.slice(1);\r\n\r\n\t\tpair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));\r\n\t\tpub = Buffer.from(pair.publicKey);\r\n\r\n\t\treturn (new PrivateKey({\r\n\t\t\ttype: 'curve25519',\r\n\t\t\tparts: [\r\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\r\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\r\n\t\t\t]\r\n\t\t}));\r\n\t} else if (this.type === 'curve25519' && newType === 'ed25519') {\r\n\t\tpriv = this.part.k.data;\r\n\t\tif (priv[0] === 0x00)\r\n\t\t\tpriv = priv.slice(1);\r\n\r\n\t\tpair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));\r\n\t\tpub = Buffer.from(pair.publicKey);\r\n\r\n\t\treturn (new PrivateKey({\r\n\t\t\ttype: 'ed25519',\r\n\t\t\tparts: [\r\n\t\t\t\t{ name: 'A', data: utils.mpNormalize(pub) },\r\n\t\t\t\t{ name: 'k', data: utils.mpNormalize(priv) }\r\n\t\t\t]\r\n\t\t}));\r\n\t}\r\n\tthrow (new Error('Key derivation not supported from ' + this.type +\r\n\t    ' to ' + newType));\r\n};\r\n\r\nPrivateKey.prototype.createVerify = function (hashAlgo) {\r\n\treturn (this.toPublic().createVerify(hashAlgo));\r\n};\r\n\r\nPrivateKey.prototype.createSign = function (hashAlgo) {\r\n\tif (hashAlgo === undefined)\r\n\t\thashAlgo = this.defaultHashAlgorithm();\r\n\tassert.string(hashAlgo, 'hash algorithm');\r\n\r\n\t/* ED25519 is not supported by OpenSSL, use a javascript impl. */\r\n\tif (this.type === 'ed25519' && edCompat !== undefined)\r\n\t\treturn (new edCompat.Signer(this, hashAlgo));\r\n\tif (this.type === 'curve25519')\r\n\t\tthrow (new Error('Curve25519 keys are not suitable for ' +\r\n\t\t    'signing or verification'));\r\n\r\n\tvar v, nm, err;\r\n\ttry {\r\n\t\tnm = hashAlgo.toUpperCase();\r\n\t\tv = crypto.createSign(nm);\r\n\t} catch (e) {\r\n\t\terr = e;\r\n\t}\r\n\tif (v === undefined || (err instanceof Error &&\r\n\t    err.message.match(/Unknown message digest/))) {\r\n\t\tnm = 'RSA-';\r\n\t\tnm += hashAlgo.toUpperCase();\r\n\t\tv = crypto.createSign(nm);\r\n\t}\r\n\tassert.ok(v, 'failed to create verifier');\r\n\tvar oldSign = v.sign.bind(v);\r\n\tvar key = this.toBuffer('pkcs1');\r\n\tvar type = this.type;\r\n\tvar curve = this.curve;\r\n\tv.sign = function () {\r\n\t\tvar sig = oldSign(key);\r\n\t\tif (typeof (sig) === 'string')\r\n\t\t\tsig = Buffer.from(sig, 'binary');\r\n\t\tsig = Signature.parse(sig, type, 'asn1');\r\n\t\tsig.hashAlgorithm = hashAlgo;\r\n\t\tsig.curve = curve;\r\n\t\treturn (sig);\r\n\t};\r\n\treturn (v);\r\n};\r\n\r\nPrivateKey.parse = function (data, format, options) {\r\n\tif (typeof (data) !== 'string')\r\n\t\tassert.buffer(data, 'data');\r\n\tif (format === undefined)\r\n\t\tformat = 'auto';\r\n\tassert.string(format, 'format');\r\n\tif (typeof (options) === 'string')\r\n\t\toptions = { filename: options };\r\n\tassert.optionalObject(options, 'options');\r\n\tif (options === undefined)\r\n\t\toptions = {};\r\n\tassert.optionalString(options.filename, 'options.filename');\r\n\tif (options.filename === undefined)\r\n\t\toptions.filename = '(unnamed)';\r\n\r\n\tassert.object(formats[format], 'formats[format]');\r\n\r\n\ttry {\r\n\t\tvar k = formats[format].read(data, options);\r\n\t\tassert.ok(k instanceof PrivateKey, 'key is not a private key');\r\n\t\tif (!k.comment)\r\n\t\t\tk.comment = options.filename;\r\n\t\treturn (k);\r\n\t} catch (e) {\r\n\t\tif (e.name === 'KeyEncryptedError')\r\n\t\t\tthrow (e);\r\n\t\tthrow (new KeyParseError(options.filename, format, e));\r\n\t}\r\n};\r\n\r\nPrivateKey.isPrivateKey = function (obj, ver) {\r\n\treturn (utils.isCompatible(obj, PrivateKey, ver));\r\n};\r\n\r\nPrivateKey.generate = function (type, options) {\r\n\tif (options === undefined)\r\n\t\toptions = {};\r\n\tassert.object(options, 'options');\r\n\r\n\tswitch (type) {\r\n\tcase 'ecdsa':\r\n\t\tif (options.curve === undefined)\r\n\t\t\toptions.curve = 'nistp256';\r\n\t\tassert.string(options.curve, 'options.curve');\r\n\t\treturn (generateECDSA(options.curve));\r\n\tcase 'ed25519':\r\n\t\treturn (generateED25519());\r\n\tdefault:\r\n\t\tthrow (new Error('Key generation not supported with key ' +\r\n\t\t    'type \"' + type + '\"'));\r\n\t}\r\n};\r\n\r\n/*\r\n * API versions for PrivateKey:\r\n * [1,0] -- initial ver\r\n * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats\r\n * [1,2] -- added defaultHashAlgorithm\r\n * [1,3] -- added derive, ed, createDH\r\n * [1,4] -- first tagged version\r\n * [1,5] -- changed ed25519 part names and format\r\n * [1,6] -- type arguments for hash() and fingerprint()\r\n */\r\nPrivateKey.prototype._sshpkApiVersion = [1, 6];\r\n\r\nPrivateKey._oldVersionDetect = function (obj) {\r\n\tassert.func(obj.toPublic);\r\n\tassert.func(obj.createSign);\r\n\tif (obj.derive)\r\n\t\treturn ([1, 3]);\r\n\tif (obj.defaultHashAlgorithm)\r\n\t\treturn ([1, 2]);\r\n\tif (obj.formats['auto'])\r\n\t\treturn ([1, 1]);\r\n\treturn ([1, 0]);\r\n};\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nmodule.exports = Signature;\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('./algs');\r\nvar crypto = require('crypto');\r\nvar errs = require('./errors');\r\nvar utils = require('./utils');\r\nvar asn1 = require('asn1');\r\nvar SSHBuffer = require('./ssh-buffer');\r\n\r\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\r\nvar SignatureParseError = errs.SignatureParseError;\r\n\r\nfunction Signature(opts) {\r\n\tassert.object(opts, 'options');\r\n\tassert.arrayOfObject(opts.parts, 'options.parts');\r\n\tassert.string(opts.type, 'options.type');\r\n\r\n\tvar partLookup = {};\r\n\tfor (var i = 0; i < opts.parts.length; ++i) {\r\n\t\tvar part = opts.parts[i];\r\n\t\tpartLookup[part.name] = part;\r\n\t}\r\n\r\n\tthis.type = opts.type;\r\n\tthis.hashAlgorithm = opts.hashAlgo;\r\n\tthis.curve = opts.curve;\r\n\tthis.parts = opts.parts;\r\n\tthis.part = partLookup;\r\n}\r\n\r\nSignature.prototype.toBuffer = function (format) {\r\n\tif (format === undefined)\r\n\t\tformat = 'asn1';\r\n\tassert.string(format, 'format');\r\n\r\n\tvar buf;\r\n\tvar stype = 'ssh-' + this.type;\r\n\r\n\tswitch (this.type) {\r\n\tcase 'rsa':\r\n\t\tswitch (this.hashAlgorithm) {\r\n\t\tcase 'sha256':\r\n\t\t\tstype = 'rsa-sha2-256';\r\n\t\t\tbreak;\r\n\t\tcase 'sha512':\r\n\t\t\tstype = 'rsa-sha2-512';\r\n\t\t\tbreak;\r\n\t\tcase 'sha1':\r\n\t\tcase undefined:\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow (new Error('SSH signature ' +\r\n\t\t\t    'format does not support hash ' +\r\n\t\t\t    'algorithm ' + this.hashAlgorithm));\r\n\t\t}\r\n\t\tif (format === 'ssh') {\r\n\t\t\tbuf = new SSHBuffer({});\r\n\t\t\tbuf.writeString(stype);\r\n\t\t\tbuf.writePart(this.part.sig);\r\n\t\t\treturn (buf.toBuffer());\r\n\t\t} else {\r\n\t\t\treturn (this.part.sig.data);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase 'ed25519':\r\n\t\tif (format === 'ssh') {\r\n\t\t\tbuf = new SSHBuffer({});\r\n\t\t\tbuf.writeString(stype);\r\n\t\t\tbuf.writePart(this.part.sig);\r\n\t\t\treturn (buf.toBuffer());\r\n\t\t} else {\r\n\t\t\treturn (this.part.sig.data);\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase 'dsa':\r\n\tcase 'ecdsa':\r\n\t\tvar r, s;\r\n\t\tif (format === 'asn1') {\r\n\t\t\tvar der = new asn1.BerWriter();\r\n\t\t\tder.startSequence();\r\n\t\t\tr = utils.mpNormalize(this.part.r.data);\r\n\t\t\ts = utils.mpNormalize(this.part.s.data);\r\n\t\t\tder.writeBuffer(r, asn1.Ber.Integer);\r\n\t\t\tder.writeBuffer(s, asn1.Ber.Integer);\r\n\t\t\tder.endSequence();\r\n\t\t\treturn (der.buffer);\r\n\t\t} else if (format === 'ssh' && this.type === 'dsa') {\r\n\t\t\tbuf = new SSHBuffer({});\r\n\t\t\tbuf.writeString('ssh-dss');\r\n\t\t\tr = this.part.r.data;\r\n\t\t\tif (r.length > 20 && r[0] === 0x00)\r\n\t\t\t\tr = r.slice(1);\r\n\t\t\ts = this.part.s.data;\r\n\t\t\tif (s.length > 20 && s[0] === 0x00)\r\n\t\t\t\ts = s.slice(1);\r\n\t\t\tif ((this.hashAlgorithm &&\r\n\t\t\t    this.hashAlgorithm !== 'sha1') ||\r\n\t\t\t    r.length + s.length !== 40) {\r\n\t\t\t\tthrow (new Error('OpenSSH only supports ' +\r\n\t\t\t\t    'DSA signatures with SHA1 hash'));\r\n\t\t\t}\r\n\t\t\tbuf.writeBuffer(Buffer.concat([r, s]));\r\n\t\t\treturn (buf.toBuffer());\r\n\t\t} else if (format === 'ssh' && this.type === 'ecdsa') {\r\n\t\t\tvar inner = new SSHBuffer({});\r\n\t\t\tr = this.part.r.data;\r\n\t\t\tinner.writeBuffer(r);\r\n\t\t\tinner.writePart(this.part.s);\r\n\r\n\t\t\tbuf = new SSHBuffer({});\r\n\t\t\t/* XXX: find a more proper way to do this? */\r\n\t\t\tvar curve;\r\n\t\t\tif (r[0] === 0x00)\r\n\t\t\t\tr = r.slice(1);\r\n\t\t\tvar sz = r.length * 8;\r\n\t\t\tif (sz === 256)\r\n\t\t\t\tcurve = 'nistp256';\r\n\t\t\telse if (sz === 384)\r\n\t\t\t\tcurve = 'nistp384';\r\n\t\t\telse if (sz === 528)\r\n\t\t\t\tcurve = 'nistp521';\r\n\t\t\tbuf.writeString('ecdsa-sha2-' + curve);\r\n\t\t\tbuf.writeBuffer(inner.toBuffer());\r\n\t\t\treturn (buf.toBuffer());\r\n\t\t}\r\n\t\tthrow (new Error('Invalid signature format'));\r\n\tdefault:\r\n\t\tthrow (new Error('Invalid signature data'));\r\n\t}\r\n};\r\n\r\nSignature.prototype.toString = function (format) {\r\n\tassert.optionalString(format, 'format');\r\n\treturn (this.toBuffer(format).toString('base64'));\r\n};\r\n\r\nSignature.parse = function (data, type, format) {\r\n\tif (typeof (data) === 'string')\r\n\t\tdata = Buffer.from(data, 'base64');\r\n\tassert.buffer(data, 'data');\r\n\tassert.string(format, 'format');\r\n\tassert.string(type, 'type');\r\n\r\n\tvar opts = {};\r\n\topts.type = type.toLowerCase();\r\n\topts.parts = [];\r\n\r\n\ttry {\r\n\t\tassert.ok(data.length > 0, 'signature must not be empty');\r\n\t\tswitch (opts.type) {\r\n\t\tcase 'rsa':\r\n\t\t\treturn (parseOneNum(data, type, format, opts));\r\n\t\tcase 'ed25519':\r\n\t\t\treturn (parseOneNum(data, type, format, opts));\r\n\r\n\t\tcase 'dsa':\r\n\t\tcase 'ecdsa':\r\n\t\t\tif (format === 'asn1')\r\n\t\t\t\treturn (parseDSAasn1(data, type, format, opts));\r\n\t\t\telse if (opts.type === 'dsa')\r\n\t\t\t\treturn (parseDSA(data, type, format, opts));\r\n\t\t\telse\r\n\t\t\t\treturn (parseECDSA(data, type, format, opts));\r\n\r\n\t\tdefault:\r\n\t\t\tthrow (new InvalidAlgorithmError(type));\r\n\t\t}\r\n\r\n\t} catch (e) {\r\n\t\tif (e instanceof InvalidAlgorithmError)\r\n\t\t\tthrow (e);\r\n\t\tthrow (new SignatureParseError(type, format, e));\r\n\t}\r\n};\r\n\r\nfunction parseOneNum(data, type, format, opts) {\r\n\tif (format === 'ssh') {\r\n\t\ttry {\r\n\t\t\tvar buf = new SSHBuffer({buffer: data});\r\n\t\t\tvar head = buf.readString();\r\n\t\t} catch (e) {\r\n\t\t\t/* fall through */\r\n\t\t}\r\n\t\tif (buf !== undefined) {\r\n\t\t\tvar msg = 'SSH signature does not match expected ' +\r\n\t\t\t    'type (expected ' + type + ', got ' + head + ')';\r\n\t\t\tswitch (head) {\r\n\t\t\tcase 'ssh-rsa':\r\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\r\n\t\t\t\topts.hashAlgo = 'sha1';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'rsa-sha2-256':\r\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\r\n\t\t\t\topts.hashAlgo = 'sha256';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'rsa-sha2-512':\r\n\t\t\t\tassert.strictEqual(type, 'rsa', msg);\r\n\t\t\t\topts.hashAlgo = 'sha512';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'ssh-ed25519':\r\n\t\t\t\tassert.strictEqual(type, 'ed25519', msg);\r\n\t\t\t\topts.hashAlgo = 'sha512';\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow (new Error('Unknown SSH signature ' +\r\n\t\t\t\t    'type: ' + head));\r\n\t\t\t}\r\n\t\t\tvar sig = buf.readPart();\r\n\t\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\r\n\t\t\tsig.name = 'sig';\r\n\t\t\topts.parts.push(sig);\r\n\t\t\treturn (new Signature(opts));\r\n\t\t}\r\n\t}\r\n\topts.parts.push({name: 'sig', data: data});\r\n\treturn (new Signature(opts));\r\n}\r\n\r\nfunction parseDSAasn1(data, type, format, opts) {\r\n\tvar der = new asn1.BerReader(data);\r\n\tder.readSequence();\r\n\tvar r = der.readString(asn1.Ber.Integer, true);\r\n\tvar s = der.readString(asn1.Ber.Integer, true);\r\n\r\n\topts.parts.push({name: 'r', data: utils.mpNormalize(r)});\r\n\topts.parts.push({name: 's', data: utils.mpNormalize(s)});\r\n\r\n\treturn (new Signature(opts));\r\n}\r\n\r\nfunction parseDSA(data, type, format, opts) {\r\n\tif (data.length != 40) {\r\n\t\tvar buf = new SSHBuffer({buffer: data});\r\n\t\tvar d = buf.readBuffer();\r\n\t\tif (d.toString('ascii') === 'ssh-dss')\r\n\t\t\td = buf.readBuffer();\r\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes');\r\n\t\tassert.strictEqual(d.length, 40, 'invalid inner length');\r\n\t\tdata = d;\r\n\t}\r\n\topts.parts.push({name: 'r', data: data.slice(0, 20)});\r\n\topts.parts.push({name: 's', data: data.slice(20, 40)});\r\n\treturn (new Signature(opts));\r\n}\r\n\r\nfunction parseECDSA(data, type, format, opts) {\r\n\tvar buf = new SSHBuffer({buffer: data});\r\n\r\n\tvar r, s;\r\n\tvar inner = buf.readBuffer();\r\n\tvar stype = inner.toString('ascii');\r\n\tif (stype.slice(0, 6) === 'ecdsa-') {\r\n\t\tvar parts = stype.split('-');\r\n\t\tassert.strictEqual(parts[0], 'ecdsa');\r\n\t\tassert.strictEqual(parts[1], 'sha2');\r\n\t\topts.curve = parts[2];\r\n\t\tswitch (opts.curve) {\r\n\t\tcase 'nistp256':\r\n\t\t\topts.hashAlgo = 'sha256';\r\n\t\t\tbreak;\r\n\t\tcase 'nistp384':\r\n\t\t\topts.hashAlgo = 'sha384';\r\n\t\t\tbreak;\r\n\t\tcase 'nistp521':\r\n\t\t\topts.hashAlgo = 'sha512';\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow (new Error('Unsupported ECDSA curve: ' +\r\n\t\t\t    opts.curve));\r\n\t\t}\r\n\t\tinner = buf.readBuffer();\r\n\t\tassert.ok(buf.atEnd(), 'extra trailing bytes on outer');\r\n\t\tbuf = new SSHBuffer({buffer: inner});\r\n\t\tr = buf.readPart();\r\n\t} else {\r\n\t\tr = {data: inner};\r\n\t}\r\n\r\n\ts = buf.readPart();\r\n\tassert.ok(buf.atEnd(), 'extra trailing bytes');\r\n\r\n\tr.name = 'r';\r\n\ts.name = 's';\r\n\r\n\topts.parts.push(r);\r\n\topts.parts.push(s);\r\n\treturn (new Signature(opts));\r\n}\r\n\r\nSignature.isSignature = function (obj, ver) {\r\n\treturn (utils.isCompatible(obj, Signature, ver));\r\n};\r\n\r\n/*\r\n * API versions for Signature:\r\n * [1,0] -- initial ver\r\n * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent\r\n *          hashAlgorithm property\r\n * [2,1] -- first tagged version\r\n */\r\nSignature.prototype._sshpkApiVersion = [2, 1];\r\n\r\nSignature._oldVersionDetect = function (obj) {\r\n\tassert.func(obj.toBuffer);\r\n\tif (obj.hasOwnProperty('hashAlgorithm'))\r\n\t\treturn ([2, 0]);\r\n\treturn ([1, 0]);\r\n};\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tbufferSplit: bufferSplit,\r\n\taddRSAMissing: addRSAMissing,\r\n\tcalculateDSAPublic: calculateDSAPublic,\r\n\tcalculateED25519Public: calculateED25519Public,\r\n\tcalculateX25519Public: calculateX25519Public,\r\n\tmpNormalize: mpNormalize,\r\n\tmpDenormalize: mpDenormalize,\r\n\tecNormalize: ecNormalize,\r\n\tcountZeros: countZeros,\r\n\tassertCompatible: assertCompatible,\r\n\tisCompatible: isCompatible,\r\n\topensslKeyDeriv: opensslKeyDeriv,\r\n\topensshCipherInfo: opensshCipherInfo,\r\n\tpublicFromPrivateECDSA: publicFromPrivateECDSA,\r\n\tzeroPadToLength: zeroPadToLength,\r\n\twriteBitString: writeBitString,\r\n\treadBitString: readBitString,\r\n\tpbkdf2: pbkdf2\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar PrivateKey = require('./private-key');\r\nvar Key = require('./key');\r\nvar crypto = require('crypto');\r\nvar algs = require('./algs');\r\nvar asn1 = require('asn1');\r\n\r\nvar ec = require('ecc-jsbn/lib/ec');\r\nvar jsbn = require('jsbn').BigInteger;\r\nvar nacl = require('tweetnacl');\r\n\r\nvar MAX_CLASS_DEPTH = 3;\r\n\r\nfunction isCompatible(obj, klass, needVer) {\r\n\tif (obj === null || typeof (obj) !== 'object')\r\n\t\treturn (false);\r\n\tif (needVer === undefined)\r\n\t\tneedVer = klass.prototype._sshpkApiVersion;\r\n\tif (obj instanceof klass &&\r\n\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\r\n\t\treturn (true);\r\n\tvar proto = Object.getPrototypeOf(obj);\r\n\tvar depth = 0;\r\n\twhile (proto.constructor.name !== klass.name) {\r\n\t\tproto = Object.getPrototypeOf(proto);\r\n\t\tif (!proto || ++depth > MAX_CLASS_DEPTH)\r\n\t\t\treturn (false);\r\n\t}\r\n\tif (proto.constructor.name !== klass.name)\r\n\t\treturn (false);\r\n\tvar ver = proto._sshpkApiVersion;\r\n\tif (ver === undefined)\r\n\t\tver = klass._oldVersionDetect(obj);\r\n\tif (ver[0] != needVer[0] || ver[1] < needVer[1])\r\n\t\treturn (false);\r\n\treturn (true);\r\n}\r\n\r\nfunction assertCompatible(obj, klass, needVer, name) {\r\n\tif (name === undefined)\r\n\t\tname = 'object';\r\n\tassert.ok(obj, name + ' must not be null');\r\n\tassert.object(obj, name + ' must be an object');\r\n\tif (needVer === undefined)\r\n\t\tneedVer = klass.prototype._sshpkApiVersion;\r\n\tif (obj instanceof klass &&\r\n\t    klass.prototype._sshpkApiVersion[0] == needVer[0])\r\n\t\treturn;\r\n\tvar proto = Object.getPrototypeOf(obj);\r\n\tvar depth = 0;\r\n\twhile (proto.constructor.name !== klass.name) {\r\n\t\tproto = Object.getPrototypeOf(proto);\r\n\t\tassert.ok(proto && ++depth <= MAX_CLASS_DEPTH,\r\n\t\t    name + ' must be a ' + klass.name + ' instance');\r\n\t}\r\n\tassert.strictEqual(proto.constructor.name, klass.name,\r\n\t    name + ' must be a ' + klass.name + ' instance');\r\n\tvar ver = proto._sshpkApiVersion;\r\n\tif (ver === undefined)\r\n\t\tver = klass._oldVersionDetect(obj);\r\n\tassert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],\r\n\t    name + ' must be compatible with ' + klass.name + ' klass ' +\r\n\t    'version ' + needVer[0] + '.' + needVer[1]);\r\n}\r\n\r\nvar CIPHER_LEN = {\r\n\t'des-ede3-cbc': { key: 24, iv: 8 },\r\n\t'aes-128-cbc': { key: 16, iv: 16 },\r\n\t'aes-256-cbc': { key: 32, iv: 16 }\r\n};\r\nvar PKCS5_SALT_LEN = 8;\r\n\r\nfunction opensslKeyDeriv(cipher, salt, passphrase, count) {\r\n\tassert.buffer(salt, 'salt');\r\n\tassert.buffer(passphrase, 'passphrase');\r\n\tassert.number(count, 'iteration count');\r\n\r\n\tvar clen = CIPHER_LEN[cipher];\r\n\tassert.object(clen, 'supported cipher');\r\n\r\n\tsalt = salt.slice(0, PKCS5_SALT_LEN);\r\n\r\n\tvar D, D_prev, bufs;\r\n\tvar material = Buffer.alloc(0);\r\n\twhile (material.length < clen.key + clen.iv) {\r\n\t\tbufs = [];\r\n\t\tif (D_prev)\r\n\t\t\tbufs.push(D_prev);\r\n\t\tbufs.push(passphrase);\r\n\t\tbufs.push(salt);\r\n\t\tD = Buffer.concat(bufs);\r\n\t\tfor (var j = 0; j < count; ++j)\r\n\t\t\tD = crypto.createHash('md5').update(D).digest();\r\n\t\tmaterial = Buffer.concat([material, D]);\r\n\t\tD_prev = D;\r\n\t}\r\n\r\n\treturn ({\r\n\t    key: material.slice(0, clen.key),\r\n\t    iv: material.slice(clen.key, clen.key + clen.iv)\r\n\t});\r\n}\r\n\r\n/* See: RFC2898 */\r\nfunction pbkdf2(hashAlg, salt, iterations, size, passphrase) {\r\n\tvar hkey = Buffer.alloc(salt.length + 4);\r\n\tsalt.copy(hkey);\r\n\r\n\tvar gen = 0, ts = [];\r\n\tvar i = 1;\r\n\twhile (gen < size) {\r\n\t\tvar t = T(i++);\r\n\t\tgen += t.length;\r\n\t\tts.push(t);\r\n\t}\r\n\treturn (Buffer.concat(ts).slice(0, size));\r\n\r\n\tfunction T(I) {\r\n\t\thkey.writeUInt32BE(I, hkey.length - 4);\r\n\r\n\t\tvar hmac = crypto.createHmac(hashAlg, passphrase);\r\n\t\thmac.update(hkey);\r\n\r\n\t\tvar Ti = hmac.digest();\r\n\t\tvar Uc = Ti;\r\n\t\tvar c = 1;\r\n\t\twhile (c++ < iterations) {\r\n\t\t\thmac = crypto.createHmac(hashAlg, passphrase);\r\n\t\t\thmac.update(Uc);\r\n\t\t\tUc = hmac.digest();\r\n\t\t\tfor (var x = 0; x < Ti.length; ++x)\r\n\t\t\t\tTi[x] ^= Uc[x];\r\n\t\t}\r\n\t\treturn (Ti);\r\n\t}\r\n}\r\n\r\n/* Count leading zero bits on a buffer */\r\nfunction countZeros(buf) {\r\n\tvar o = 0, obit = 8;\r\n\twhile (o < buf.length) {\r\n\t\tvar mask = (1 << obit);\r\n\t\tif ((buf[o] & mask) === mask)\r\n\t\t\tbreak;\r\n\t\tobit--;\r\n\t\tif (obit < 0) {\r\n\t\t\to++;\r\n\t\t\tobit = 8;\r\n\t\t}\r\n\t}\r\n\treturn (o*8 + (8 - obit) - 1);\r\n}\r\n\r\nfunction bufferSplit(buf, chr) {\r\n\tassert.buffer(buf);\r\n\tassert.string(chr);\r\n\r\n\tvar parts = [];\r\n\tvar lastPart = 0;\r\n\tvar matches = 0;\r\n\tfor (var i = 0; i < buf.length; ++i) {\r\n\t\tif (buf[i] === chr.charCodeAt(matches))\r\n\t\t\t++matches;\r\n\t\telse if (buf[i] === chr.charCodeAt(0))\r\n\t\t\tmatches = 1;\r\n\t\telse\r\n\t\t\tmatches = 0;\r\n\r\n\t\tif (matches >= chr.length) {\r\n\t\t\tvar newPart = i + 1;\r\n\t\t\tparts.push(buf.slice(lastPart, newPart - matches));\r\n\t\t\tlastPart = newPart;\r\n\t\t\tmatches = 0;\r\n\t\t}\r\n\t}\r\n\tif (lastPart <= buf.length)\r\n\t\tparts.push(buf.slice(lastPart, buf.length));\r\n\r\n\treturn (parts);\r\n}\r\n\r\nfunction ecNormalize(buf, addZero) {\r\n\tassert.buffer(buf);\r\n\tif (buf[0] === 0x00 && buf[1] === 0x04) {\r\n\t\tif (addZero)\r\n\t\t\treturn (buf);\r\n\t\treturn (buf.slice(1));\r\n\t} else if (buf[0] === 0x04) {\r\n\t\tif (!addZero)\r\n\t\t\treturn (buf);\r\n\t} else {\r\n\t\twhile (buf[0] === 0x00)\r\n\t\t\tbuf = buf.slice(1);\r\n\t\tif (buf[0] === 0x02 || buf[0] === 0x03)\r\n\t\t\tthrow (new Error('Compressed elliptic curve points ' +\r\n\t\t\t    'are not supported'));\r\n\t\tif (buf[0] !== 0x04)\r\n\t\t\tthrow (new Error('Not a valid elliptic curve point'));\r\n\t\tif (!addZero)\r\n\t\t\treturn (buf);\r\n\t}\r\n\tvar b = Buffer.alloc(buf.length + 1);\r\n\tb[0] = 0x0;\r\n\tbuf.copy(b, 1);\r\n\treturn (b);\r\n}\r\n\r\nfunction readBitString(der, tag) {\r\n\tif (tag === undefined)\r\n\t\ttag = asn1.Ber.BitString;\r\n\tvar buf = der.readString(tag, true);\r\n\tassert.strictEqual(buf[0], 0x00, 'bit strings with unused bits are ' +\r\n\t    'not supported (0x' + buf[0].toString(16) + ')');\r\n\treturn (buf.slice(1));\r\n}\r\n\r\nfunction writeBitString(der, buf, tag) {\r\n\tif (tag === undefined)\r\n\t\ttag = asn1.Ber.BitString;\r\n\tvar b = Buffer.alloc(buf.length + 1);\r\n\tb[0] = 0x00;\r\n\tbuf.copy(b, 1);\r\n\tder.writeBuffer(b, tag);\r\n}\r\n\r\nfunction mpNormalize(buf) {\r\n\tassert.buffer(buf);\r\n\twhile (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)\r\n\t\tbuf = buf.slice(1);\r\n\tif ((buf[0] & 0x80) === 0x80) {\r\n\t\tvar b = Buffer.alloc(buf.length + 1);\r\n\t\tb[0] = 0x00;\r\n\t\tbuf.copy(b, 1);\r\n\t\tbuf = b;\r\n\t}\r\n\treturn (buf);\r\n}\r\n\r\nfunction mpDenormalize(buf) {\r\n\tassert.buffer(buf);\r\n\twhile (buf.length > 1 && buf[0] === 0x00)\r\n\t\tbuf = buf.slice(1);\r\n\treturn (buf);\r\n}\r\n\r\nfunction zeroPadToLength(buf, len) {\r\n\tassert.buffer(buf);\r\n\tassert.number(len);\r\n\twhile (buf.length > len) {\r\n\t\tassert.equal(buf[0], 0x00);\r\n\t\tbuf = buf.slice(1);\r\n\t}\r\n\twhile (buf.length < len) {\r\n\t\tvar b = Buffer.alloc(buf.length + 1);\r\n\t\tb[0] = 0x00;\r\n\t\tbuf.copy(b, 1);\r\n\t\tbuf = b;\r\n\t}\r\n\treturn (buf);\r\n}\r\n\r\nfunction bigintToMpBuf(bigint) {\r\n\tvar buf = Buffer.from(bigint.toByteArray());\r\n\tbuf = mpNormalize(buf);\r\n\treturn (buf);\r\n}\r\n\r\nfunction calculateDSAPublic(g, p, x) {\r\n\tassert.buffer(g);\r\n\tassert.buffer(p);\r\n\tassert.buffer(x);\r\n\tg = new jsbn(g);\r\n\tp = new jsbn(p);\r\n\tx = new jsbn(x);\r\n\tvar y = g.modPow(x, p);\r\n\tvar ybuf = bigintToMpBuf(y);\r\n\treturn (ybuf);\r\n}\r\n\r\nfunction calculateED25519Public(k) {\r\n\tassert.buffer(k);\r\n\r\n\tvar kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));\r\n\treturn (Buffer.from(kp.publicKey));\r\n}\r\n\r\nfunction calculateX25519Public(k) {\r\n\tassert.buffer(k);\r\n\r\n\tvar kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));\r\n\treturn (Buffer.from(kp.publicKey));\r\n}\r\n\r\nfunction addRSAMissing(key) {\r\n\tassert.object(key);\r\n\tassertCompatible(key, PrivateKey, [1, 1]);\r\n\r\n\tvar d = new jsbn(key.part.d.data);\r\n\tvar buf;\r\n\r\n\tif (!key.part.dmodp) {\r\n\t\tvar p = new jsbn(key.part.p.data);\r\n\t\tvar dmodp = d.mod(p.subtract(1));\r\n\r\n\t\tbuf = bigintToMpBuf(dmodp);\r\n\t\tkey.part.dmodp = {name: 'dmodp', data: buf};\r\n\t\tkey.parts.push(key.part.dmodp);\r\n\t}\r\n\tif (!key.part.dmodq) {\r\n\t\tvar q = new jsbn(key.part.q.data);\r\n\t\tvar dmodq = d.mod(q.subtract(1));\r\n\r\n\t\tbuf = bigintToMpBuf(dmodq);\r\n\t\tkey.part.dmodq = {name: 'dmodq', data: buf};\r\n\t\tkey.parts.push(key.part.dmodq);\r\n\t}\r\n}\r\n\r\nfunction publicFromPrivateECDSA(curveName, priv) {\r\n\tassert.string(curveName, 'curveName');\r\n\tassert.buffer(priv);\r\n\tvar params = algs.curves[curveName];\r\n\tvar p = new jsbn(params.p);\r\n\tvar a = new jsbn(params.a);\r\n\tvar b = new jsbn(params.b);\r\n\tvar curve = new ec.ECCurveFp(p, a, b);\r\n\tvar G = curve.decodePointHex(params.G.toString('hex'));\r\n\r\n\tvar d = new jsbn(mpNormalize(priv));\r\n\tvar pub = G.multiply(d);\r\n\tpub = Buffer.from(curve.encodePointHex(pub), 'hex');\r\n\r\n\tvar parts = [];\r\n\tparts.push({name: 'curve', data: Buffer.from(curveName)});\r\n\tparts.push({name: 'Q', data: pub});\r\n\r\n\tvar key = new Key({type: 'ecdsa', curve: curve, parts: parts});\r\n\treturn (key);\r\n}\r\n\r\nfunction opensshCipherInfo(cipher) {\r\n\tvar inf = {};\r\n\tswitch (cipher) {\r\n\tcase '3des-cbc':\r\n\t\tinf.keySize = 24;\r\n\t\tinf.blockSize = 8;\r\n\t\tinf.opensslName = 'des-ede3-cbc';\r\n\t\tbreak;\r\n\tcase 'blowfish-cbc':\r\n\t\tinf.keySize = 16;\r\n\t\tinf.blockSize = 8;\r\n\t\tinf.opensslName = 'bf-cbc';\r\n\t\tbreak;\r\n\tcase 'aes128-cbc':\r\n\tcase 'aes128-ctr':\r\n\tcase 'aes128-gcm@openssh.com':\r\n\t\tinf.keySize = 16;\r\n\t\tinf.blockSize = 16;\r\n\t\tinf.opensslName = 'aes-128-' + cipher.slice(7, 10);\r\n\t\tbreak;\r\n\tcase 'aes192-cbc':\r\n\tcase 'aes192-ctr':\r\n\tcase 'aes192-gcm@openssh.com':\r\n\t\tinf.keySize = 24;\r\n\t\tinf.blockSize = 16;\r\n\t\tinf.opensslName = 'aes-192-' + cipher.slice(7, 10);\r\n\t\tbreak;\r\n\tcase 'aes256-cbc':\r\n\tcase 'aes256-ctr':\r\n\tcase 'aes256-gcm@openssh.com':\r\n\t\tinf.keySize = 32;\r\n\t\tinf.blockSize = 16;\r\n\t\tinf.opensslName = 'aes-256-' + cipher.slice(7, 10);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tthrow (new Error(\r\n\t\t    'Unsupported openssl cipher \"' + cipher + '\"'));\r\n\t}\r\n\treturn (inf);\r\n}\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nmodule.exports = SSHBuffer;\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\n\r\nfunction SSHBuffer(opts) {\r\n\tassert.object(opts, 'options');\r\n\tif (opts.buffer !== undefined)\r\n\t\tassert.buffer(opts.buffer, 'options.buffer');\r\n\r\n\tthis._size = opts.buffer ? opts.buffer.length : 1024;\r\n\tthis._buffer = opts.buffer || Buffer.alloc(this._size);\r\n\tthis._offset = 0;\r\n}\r\n\r\nSSHBuffer.prototype.toBuffer = function () {\r\n\treturn (this._buffer.slice(0, this._offset));\r\n};\r\n\r\nSSHBuffer.prototype.atEnd = function () {\r\n\treturn (this._offset >= this._buffer.length);\r\n};\r\n\r\nSSHBuffer.prototype.remainder = function () {\r\n\treturn (this._buffer.slice(this._offset));\r\n};\r\n\r\nSSHBuffer.prototype.skip = function (n) {\r\n\tthis._offset += n;\r\n};\r\n\r\nSSHBuffer.prototype.expand = function () {\r\n\tthis._size *= 2;\r\n\tvar buf = Buffer.alloc(this._size);\r\n\tthis._buffer.copy(buf, 0);\r\n\tthis._buffer = buf;\r\n};\r\n\r\nSSHBuffer.prototype.readPart = function () {\r\n\treturn ({data: this.readBuffer()});\r\n};\r\n\r\nSSHBuffer.prototype.readBuffer = function () {\r\n\tvar len = this._buffer.readUInt32BE(this._offset);\r\n\tthis._offset += 4;\r\n\tassert.ok(this._offset + len <= this._buffer.length,\r\n\t    'length out of bounds at +0x' + this._offset.toString(16) +\r\n\t    ' (data truncated?)');\r\n\tvar buf = this._buffer.slice(this._offset, this._offset + len);\r\n\tthis._offset += len;\r\n\treturn (buf);\r\n};\r\n\r\nSSHBuffer.prototype.readString = function () {\r\n\treturn (this.readBuffer().toString());\r\n};\r\n\r\nSSHBuffer.prototype.readCString = function () {\r\n\tvar offset = this._offset;\r\n\twhile (offset < this._buffer.length &&\r\n\t    this._buffer[offset] !== 0x00)\r\n\t\toffset++;\r\n\tassert.ok(offset < this._buffer.length, 'c string does not terminate');\r\n\tvar str = this._buffer.slice(this._offset, offset).toString();\r\n\tthis._offset = offset + 1;\r\n\treturn (str);\r\n};\r\n\r\nSSHBuffer.prototype.readInt = function () {\r\n\tvar v = this._buffer.readUInt32BE(this._offset);\r\n\tthis._offset += 4;\r\n\treturn (v);\r\n};\r\n\r\nSSHBuffer.prototype.readInt64 = function () {\r\n\tassert.ok(this._offset + 8 < this._buffer.length,\r\n\t    'buffer not long enough to read Int64');\r\n\tvar v = this._buffer.slice(this._offset, this._offset + 8);\r\n\tthis._offset += 8;\r\n\treturn (v);\r\n};\r\n\r\nSSHBuffer.prototype.readChar = function () {\r\n\tvar v = this._buffer[this._offset++];\r\n\treturn (v);\r\n};\r\n\r\nSSHBuffer.prototype.writeBuffer = function (buf) {\r\n\twhile (this._offset + 4 + buf.length > this._size)\r\n\t\tthis.expand();\r\n\tthis._buffer.writeUInt32BE(buf.length, this._offset);\r\n\tthis._offset += 4;\r\n\tbuf.copy(this._buffer, this._offset);\r\n\tthis._offset += buf.length;\r\n};\r\n\r\nSSHBuffer.prototype.writeString = function (str) {\r\n\tthis.writeBuffer(Buffer.from(str, 'utf8'));\r\n};\r\n\r\nSSHBuffer.prototype.writeCString = function (str) {\r\n\twhile (this._offset + 1 + str.length > this._size)\r\n\t\tthis.expand();\r\n\tthis._buffer.write(str, this._offset);\r\n\tthis._offset += str.length;\r\n\tthis._buffer[this._offset++] = 0;\r\n};\r\n\r\nSSHBuffer.prototype.writeInt = function (v) {\r\n\twhile (this._offset + 4 > this._size)\r\n\t\tthis.expand();\r\n\tthis._buffer.writeUInt32BE(v, this._offset);\r\n\tthis._offset += 4;\r\n};\r\n\r\nSSHBuffer.prototype.writeInt64 = function (v) {\r\n\tassert.buffer(v, 'value');\r\n\tif (v.length > 8) {\r\n\t\tvar lead = v.slice(0, v.length - 8);\r\n\t\tfor (var i = 0; i < lead.length; ++i) {\r\n\t\t\tassert.strictEqual(lead[i], 0,\r\n\t\t\t    'must fit in 64 bits of precision');\r\n\t\t}\r\n\t\tv = v.slice(v.length - 8, v.length);\r\n\t}\r\n\twhile (this._offset + 8 > this._size)\r\n\t\tthis.expand();\r\n\tv.copy(this._buffer, this._offset);\r\n\tthis._offset += 8;\r\n};\r\n\r\nSSHBuffer.prototype.writeChar = function (v) {\r\n\twhile (this._offset + 1 > this._size)\r\n\t\tthis.expand();\r\n\tthis._buffer[this._offset++] = v;\r\n};\r\n\r\nSSHBuffer.prototype.writePart = function (p) {\r\n\tthis.writeBuffer(p.data);\r\n};\r\n\r\nSSHBuffer.prototype.write = function (buf) {\r\n\twhile (this._offset + buf.length > this._size)\r\n\t\tthis.expand();\r\n\tbuf.copy(this._buffer, this._offset);\r\n\tthis._offset += buf.length;\r\n};\r\n","// Copyright 2017 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tDiffieHellman: DiffieHellman,\r\n\tgenerateECDSA: generateECDSA,\r\n\tgenerateED25519: generateED25519\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar crypto = require('crypto');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('./algs');\r\nvar utils = require('./utils');\r\nvar nacl = require('tweetnacl');\r\n\r\nvar Key = require('./key');\r\nvar PrivateKey = require('./private-key');\r\n\r\nvar CRYPTO_HAVE_ECDH = (crypto.createECDH !== undefined);\r\n\r\nvar ecdh = require('ecc-jsbn');\r\nvar ec = require('ecc-jsbn/lib/ec');\r\nvar jsbn = require('jsbn').BigInteger;\r\n\r\nfunction DiffieHellman(key) {\r\n\tutils.assertCompatible(key, Key, [1, 4], 'key');\r\n\tthis._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);\r\n\tthis._algo = key.type;\r\n\tthis._curve = key.curve;\r\n\tthis._key = key;\r\n\tif (key.type === 'dsa') {\r\n\t\tif (!CRYPTO_HAVE_ECDH) {\r\n\t\t\tthrow (new Error('Due to bugs in the node 0.10 ' +\r\n\t\t\t    'crypto API, node 0.12.x or later is required ' +\r\n\t\t\t    'to use DH'));\r\n\t\t}\r\n\t\tthis._dh = crypto.createDiffieHellman(\r\n\t\t    key.part.p.data, undefined,\r\n\t\t    key.part.g.data, undefined);\r\n\t\tthis._p = key.part.p;\r\n\t\tthis._g = key.part.g;\r\n\t\tif (this._isPriv)\r\n\t\t\tthis._dh.setPrivateKey(key.part.x.data);\r\n\t\tthis._dh.setPublicKey(key.part.y.data);\r\n\r\n\t} else if (key.type === 'ecdsa') {\r\n\t\tif (!CRYPTO_HAVE_ECDH) {\r\n\t\t\tthis._ecParams = new X9ECParameters(this._curve);\r\n\r\n\t\t\tif (this._isPriv) {\r\n\t\t\t\tthis._priv = new ECPrivate(\r\n\t\t\t\t    this._ecParams, key.part.d.data);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar curve = {\r\n\t\t\t'nistp256': 'prime256v1',\r\n\t\t\t'nistp384': 'secp384r1',\r\n\t\t\t'nistp521': 'secp521r1'\r\n\t\t}[key.curve];\r\n\t\tthis._dh = crypto.createECDH(curve);\r\n\t\tif (typeof (this._dh) !== 'object' ||\r\n\t\t    typeof (this._dh.setPrivateKey) !== 'function') {\r\n\t\t\tCRYPTO_HAVE_ECDH = false;\r\n\t\t\tDiffieHellman.call(this, key);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this._isPriv)\r\n\t\t\tthis._dh.setPrivateKey(key.part.d.data);\r\n\t\tthis._dh.setPublicKey(key.part.Q.data);\r\n\r\n\t} else if (key.type === 'curve25519') {\r\n\t\tif (this._isPriv) {\r\n\t\t\tutils.assertCompatible(key, PrivateKey, [1, 5], 'key');\r\n\t\t\tthis._priv = key.part.k.data;\r\n\t\t}\r\n\r\n\t} else {\r\n\t\tthrow (new Error('DH not supported for ' + key.type + ' keys'));\r\n\t}\r\n}\r\n\r\nDiffieHellman.prototype.getPublicKey = function () {\r\n\tif (this._isPriv)\r\n\t\treturn (this._key.toPublic());\r\n\treturn (this._key);\r\n};\r\n\r\nDiffieHellman.prototype.getPrivateKey = function () {\r\n\tif (this._isPriv)\r\n\t\treturn (this._key);\r\n\telse\r\n\t\treturn (undefined);\r\n};\r\nDiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;\r\n\r\nDiffieHellman.prototype._keyCheck = function (pk, isPub) {\r\n\tassert.object(pk, 'key');\r\n\tif (!isPub)\r\n\t\tutils.assertCompatible(pk, PrivateKey, [1, 3], 'key');\r\n\tutils.assertCompatible(pk, Key, [1, 4], 'key');\r\n\r\n\tif (pk.type !== this._algo) {\r\n\t\tthrow (new Error('A ' + pk.type + ' key cannot be used in ' +\r\n\t\t    this._algo + ' Diffie-Hellman'));\r\n\t}\r\n\r\n\tif (pk.curve !== this._curve) {\r\n\t\tthrow (new Error('A key from the ' + pk.curve + ' curve ' +\r\n\t\t    'cannot be used with a ' + this._curve +\r\n\t\t    ' Diffie-Hellman'));\r\n\t}\r\n\r\n\tif (pk.type === 'dsa') {\r\n\t\tassert.deepEqual(pk.part.p, this._p,\r\n\t\t    'DSA key prime does not match');\r\n\t\tassert.deepEqual(pk.part.g, this._g,\r\n\t\t    'DSA key generator does not match');\r\n\t}\r\n};\r\n\r\nDiffieHellman.prototype.setKey = function (pk) {\r\n\tthis._keyCheck(pk);\r\n\r\n\tif (pk.type === 'dsa') {\r\n\t\tthis._dh.setPrivateKey(pk.part.x.data);\r\n\t\tthis._dh.setPublicKey(pk.part.y.data);\r\n\r\n\t} else if (pk.type === 'ecdsa') {\r\n\t\tif (CRYPTO_HAVE_ECDH) {\r\n\t\t\tthis._dh.setPrivateKey(pk.part.d.data);\r\n\t\t\tthis._dh.setPublicKey(pk.part.Q.data);\r\n\t\t} else {\r\n\t\t\tthis._priv = new ECPrivate(\r\n\t\t\t    this._ecParams, pk.part.d.data);\r\n\t\t}\r\n\r\n\t} else if (pk.type === 'curve25519') {\r\n\t\tvar k = pk.part.k;\r\n\t\tif (!pk.part.k)\r\n\t\t\tk = pk.part.r;\r\n\t\tthis._priv = k.data;\r\n\t\tif (this._priv[0] === 0x00)\r\n\t\t\tthis._priv = this._priv.slice(1);\r\n\t\tthis._priv = this._priv.slice(0, 32);\r\n\t}\r\n\tthis._key = pk;\r\n\tthis._isPriv = true;\r\n};\r\nDiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;\r\n\r\nDiffieHellman.prototype.computeSecret = function (otherpk) {\r\n\tthis._keyCheck(otherpk, true);\r\n\tif (!this._isPriv)\r\n\t\tthrow (new Error('DH exchange has not been initialized with ' +\r\n\t\t    'a private key yet'));\r\n\r\n\tvar pub;\r\n\tif (this._algo === 'dsa') {\r\n\t\treturn (this._dh.computeSecret(\r\n\t\t    otherpk.part.y.data));\r\n\r\n\t} else if (this._algo === 'ecdsa') {\r\n\t\tif (CRYPTO_HAVE_ECDH) {\r\n\t\t\treturn (this._dh.computeSecret(\r\n\t\t\t    otherpk.part.Q.data));\r\n\t\t} else {\r\n\t\t\tpub = new ECPublic(\r\n\t\t\t    this._ecParams, otherpk.part.Q.data);\r\n\t\t\treturn (this._priv.deriveSharedSecret(pub));\r\n\t\t}\r\n\r\n\t} else if (this._algo === 'curve25519') {\r\n\t\tpub = otherpk.part.A.data;\r\n\t\twhile (pub[0] === 0x00 && pub.length > 32)\r\n\t\t\tpub = pub.slice(1);\r\n\t\tvar priv = this._priv;\r\n\t\tassert.strictEqual(pub.length, 32);\r\n\t\tassert.strictEqual(priv.length, 32);\r\n\r\n\t\tvar secret = nacl.box.before(new Uint8Array(pub),\r\n\t\t    new Uint8Array(priv));\r\n\r\n\t\treturn (Buffer.from(secret));\r\n\t}\r\n\r\n\tthrow (new Error('Invalid algorithm: ' + this._algo));\r\n};\r\n\r\nDiffieHellman.prototype.generateKey = function () {\r\n\tvar parts = [];\r\n\tvar priv, pub;\r\n\tif (this._algo === 'dsa') {\r\n\t\tthis._dh.generateKeys();\r\n\r\n\t\tparts.push({name: 'p', data: this._p.data});\r\n\t\tparts.push({name: 'q', data: this._key.part.q.data});\r\n\t\tparts.push({name: 'g', data: this._g.data});\r\n\t\tparts.push({name: 'y', data: this._dh.getPublicKey()});\r\n\t\tparts.push({name: 'x', data: this._dh.getPrivateKey()});\r\n\t\tthis._key = new PrivateKey({\r\n\t\t\ttype: 'dsa',\r\n\t\t\tparts: parts\r\n\t\t});\r\n\t\tthis._isPriv = true;\r\n\t\treturn (this._key);\r\n\r\n\t} else if (this._algo === 'ecdsa') {\r\n\t\tif (CRYPTO_HAVE_ECDH) {\r\n\t\t\tthis._dh.generateKeys();\r\n\r\n\t\t\tparts.push({name: 'curve',\r\n\t\t\t    data: Buffer.from(this._curve)});\r\n\t\t\tparts.push({name: 'Q', data: this._dh.getPublicKey()});\r\n\t\t\tparts.push({name: 'd', data: this._dh.getPrivateKey()});\r\n\t\t\tthis._key = new PrivateKey({\r\n\t\t\t\ttype: 'ecdsa',\r\n\t\t\t\tcurve: this._curve,\r\n\t\t\t\tparts: parts\r\n\t\t\t});\r\n\t\t\tthis._isPriv = true;\r\n\t\t\treturn (this._key);\r\n\r\n\t\t} else {\r\n\t\t\tvar n = this._ecParams.getN();\r\n\t\t\tvar r = new jsbn(crypto.randomBytes(n.bitLength()));\r\n\t\t\tvar n1 = n.subtract(jsbn.ONE);\r\n\t\t\tpriv = r.mod(n1).add(jsbn.ONE);\r\n\t\t\tpub = this._ecParams.getG().multiply(priv);\r\n\r\n\t\t\tpriv = Buffer.from(priv.toByteArray());\r\n\t\t\tpub = Buffer.from(this._ecParams.getCurve().\r\n\t\t\t    encodePointHex(pub), 'hex');\r\n\r\n\t\t\tthis._priv = new ECPrivate(this._ecParams, priv);\r\n\r\n\t\t\tparts.push({name: 'curve',\r\n\t\t\t    data: Buffer.from(this._curve)});\r\n\t\t\tparts.push({name: 'Q', data: pub});\r\n\t\t\tparts.push({name: 'd', data: priv});\r\n\r\n\t\t\tthis._key = new PrivateKey({\r\n\t\t\t\ttype: 'ecdsa',\r\n\t\t\t\tcurve: this._curve,\r\n\t\t\t\tparts: parts\r\n\t\t\t});\r\n\t\t\tthis._isPriv = true;\r\n\t\t\treturn (this._key);\r\n\t\t}\r\n\r\n\t} else if (this._algo === 'curve25519') {\r\n\t\tvar pair = nacl.box.keyPair();\r\n\t\tpriv = Buffer.from(pair.secretKey);\r\n\t\tpub = Buffer.from(pair.publicKey);\r\n\t\tpriv = Buffer.concat([priv, pub]);\r\n\t\tassert.strictEqual(priv.length, 64);\r\n\t\tassert.strictEqual(pub.length, 32);\r\n\r\n\t\tparts.push({name: 'A', data: pub});\r\n\t\tparts.push({name: 'k', data: priv});\r\n\t\tthis._key = new PrivateKey({\r\n\t\t\ttype: 'curve25519',\r\n\t\t\tparts: parts\r\n\t\t});\r\n\t\tthis._isPriv = true;\r\n\t\treturn (this._key);\r\n\t}\r\n\r\n\tthrow (new Error('Invalid algorithm: ' + this._algo));\r\n};\r\nDiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;\r\n\r\n/* These are helpers for using ecc-jsbn (for node 0.10 compatibility). */\r\n\r\nfunction X9ECParameters(name) {\r\n\tvar params = algs.curves[name];\r\n\tassert.object(params);\r\n\r\n\tvar p = new jsbn(params.p);\r\n\tvar a = new jsbn(params.a);\r\n\tvar b = new jsbn(params.b);\r\n\tvar n = new jsbn(params.n);\r\n\tvar h = jsbn.ONE;\r\n\tvar curve = new ec.ECCurveFp(p, a, b);\r\n\tvar G = curve.decodePointHex(params.G.toString('hex'));\r\n\r\n\tthis.curve = curve;\r\n\tthis.g = G;\r\n\tthis.n = n;\r\n\tthis.h = h;\r\n}\r\nX9ECParameters.prototype.getCurve = function () { return (this.curve); };\r\nX9ECParameters.prototype.getG = function () { return (this.g); };\r\nX9ECParameters.prototype.getN = function () { return (this.n); };\r\nX9ECParameters.prototype.getH = function () { return (this.h); };\r\n\r\nfunction ECPublic(params, buffer) {\r\n\tthis._params = params;\r\n\tif (buffer[0] === 0x00)\r\n\t\tbuffer = buffer.slice(1);\r\n\tthis._pub = params.getCurve().decodePointHex(buffer.toString('hex'));\r\n}\r\n\r\nfunction ECPrivate(params, buffer) {\r\n\tthis._params = params;\r\n\tthis._priv = new jsbn(utils.mpNormalize(buffer));\r\n}\r\nECPrivate.prototype.deriveSharedSecret = function (pubKey) {\r\n\tassert.ok(pubKey instanceof ECPublic);\r\n\tvar S = pubKey._pub.multiply(this._priv);\r\n\treturn (Buffer.from(S.getX().toBigInteger().toByteArray()));\r\n};\r\n\r\nfunction generateED25519() {\r\n\tvar pair = nacl.sign.keyPair();\r\n\tvar priv = Buffer.from(pair.secretKey);\r\n\tvar pub = Buffer.from(pair.publicKey);\r\n\tassert.strictEqual(priv.length, 64);\r\n\tassert.strictEqual(pub.length, 32);\r\n\r\n\tvar parts = [];\r\n\tparts.push({name: 'A', data: pub});\r\n\tparts.push({name: 'k', data: priv.slice(0, 32)});\r\n\tvar key = new PrivateKey({\r\n\t\ttype: 'ed25519',\r\n\t\tparts: parts\r\n\t});\r\n\treturn (key);\r\n}\r\n\r\n/* Generates a new ECDSA private key on a given curve. */\r\nfunction generateECDSA(curve) {\r\n\tvar parts = [];\r\n\tvar key;\r\n\r\n\tif (CRYPTO_HAVE_ECDH) {\r\n\t\t/*\r\n\t\t * Node crypto doesn't expose key generation directly, but the\r\n\t\t * ECDH instances can generate keys. It turns out this just\r\n\t\t * calls into the OpenSSL generic key generator, and we can\r\n\t\t * read its output happily without doing an actual DH. So we\r\n\t\t * use that here.\r\n\t\t */\r\n\t\tvar osCurve = {\r\n\t\t\t'nistp256': 'prime256v1',\r\n\t\t\t'nistp384': 'secp384r1',\r\n\t\t\t'nistp521': 'secp521r1'\r\n\t\t}[curve];\r\n\r\n\t\tvar dh = crypto.createECDH(osCurve);\r\n\t\tdh.generateKeys();\r\n\r\n\t\tparts.push({name: 'curve',\r\n\t\t    data: Buffer.from(curve)});\r\n\t\tparts.push({name: 'Q', data: dh.getPublicKey()});\r\n\t\tparts.push({name: 'd', data: dh.getPrivateKey()});\r\n\r\n\t\tkey = new PrivateKey({\r\n\t\t\ttype: 'ecdsa',\r\n\t\t\tcurve: curve,\r\n\t\t\tparts: parts\r\n\t\t});\r\n\t\treturn (key);\r\n\t} else {\r\n\r\n\t\tvar ecParams = new X9ECParameters(curve);\r\n\r\n\t\t/* This algorithm taken from FIPS PUB 186-4 (section B.4.1) */\r\n\t\tvar n = ecParams.getN();\r\n\t\t/*\r\n\t\t * The crypto.randomBytes() function can only give us whole\r\n\t\t * bytes, so taking a nod from X9.62, we round up.\r\n\t\t */\r\n\t\tvar cByteLen = Math.ceil((n.bitLength() + 64) / 8);\r\n\t\tvar c = new jsbn(crypto.randomBytes(cByteLen));\r\n\r\n\t\tvar n1 = n.subtract(jsbn.ONE);\r\n\t\tvar priv = c.mod(n1).add(jsbn.ONE);\r\n\t\tvar pub = ecParams.getG().multiply(priv);\r\n\r\n\t\tpriv = Buffer.from(priv.toByteArray());\r\n\t\tpub = Buffer.from(ecParams.getCurve().\r\n\t\t    encodePointHex(pub), 'hex');\r\n\r\n\t\tparts.push({name: 'curve', data: Buffer.from(curve)});\r\n\t\tparts.push({name: 'Q', data: pub});\r\n\t\tparts.push({name: 'd', data: priv});\r\n\r\n\t\tkey = new PrivateKey({\r\n\t\t\ttype: 'ecdsa',\r\n\t\t\tcurve: curve,\r\n\t\t\tparts: parts\r\n\t\t});\r\n\t\treturn (key);\r\n\t}\r\n}\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tVerifier: Verifier,\r\n\tSigner: Signer\r\n};\r\n\r\nvar nacl = require('tweetnacl');\r\nvar stream = require('stream');\r\nvar util = require('util');\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar Signature = require('./signature');\r\n\r\nfunction Verifier(key, hashAlgo) {\r\n\tif (hashAlgo.toLowerCase() !== 'sha512')\r\n\t\tthrow (new Error('ED25519 only supports the use of ' +\r\n\t\t    'SHA-512 hashes'));\r\n\r\n\tthis.key = key;\r\n\tthis.chunks = [];\r\n\r\n\tstream.Writable.call(this, {});\r\n}\r\nutil.inherits(Verifier, stream.Writable);\r\n\r\nVerifier.prototype._write = function (chunk, enc, cb) {\r\n\tthis.chunks.push(chunk);\r\n\tcb();\r\n};\r\n\r\nVerifier.prototype.update = function (chunk) {\r\n\tif (typeof (chunk) === 'string')\r\n\t\tchunk = Buffer.from(chunk, 'binary');\r\n\tthis.chunks.push(chunk);\r\n};\r\n\r\nVerifier.prototype.verify = function (signature, fmt) {\r\n\tvar sig;\r\n\tif (Signature.isSignature(signature, [2, 0])) {\r\n\t\tif (signature.type !== 'ed25519')\r\n\t\t\treturn (false);\r\n\t\tsig = signature.toBuffer('raw');\r\n\r\n\t} else if (typeof (signature) === 'string') {\r\n\t\tsig = Buffer.from(signature, 'base64');\r\n\r\n\t} else if (Signature.isSignature(signature, [1, 0])) {\r\n\t\tthrow (new Error('signature was created by too old ' +\r\n\t\t    'a version of sshpk and cannot be verified'));\r\n\t}\r\n\r\n\tassert.buffer(sig);\r\n\treturn (nacl.sign.detached.verify(\r\n\t    new Uint8Array(Buffer.concat(this.chunks)),\r\n\t    new Uint8Array(sig),\r\n\t    new Uint8Array(this.key.part.A.data)));\r\n};\r\n\r\nfunction Signer(key, hashAlgo) {\r\n\tif (hashAlgo.toLowerCase() !== 'sha512')\r\n\t\tthrow (new Error('ED25519 only supports the use of ' +\r\n\t\t    'SHA-512 hashes'));\r\n\r\n\tthis.key = key;\r\n\tthis.chunks = [];\r\n\r\n\tstream.Writable.call(this, {});\r\n}\r\nutil.inherits(Signer, stream.Writable);\r\n\r\nSigner.prototype._write = function (chunk, enc, cb) {\r\n\tthis.chunks.push(chunk);\r\n\tcb();\r\n};\r\n\r\nSigner.prototype.update = function (chunk) {\r\n\tif (typeof (chunk) === 'string')\r\n\t\tchunk = Buffer.from(chunk, 'binary');\r\n\tthis.chunks.push(chunk);\r\n};\r\n\r\nSigner.prototype.sign = function () {\r\n\tvar sig = nacl.sign.detached(\r\n\t    new Uint8Array(Buffer.concat(this.chunks)),\r\n\t    new Uint8Array(Buffer.concat([\r\n\t\tthis.key.part.k.data, this.key.part.A.data])));\r\n\tvar sigBuf = Buffer.from(sig);\r\n\tvar sigObj = Signature.parse(sigBuf, 'ed25519', 'raw');\r\n\tsigObj.hashAlgorithm = 'sha512';\r\n\treturn (sigObj);\r\n};\r\n","// Copyright 2018 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\twrite: write\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar utils = require('../utils');\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\n\r\nvar pem = require('./pem');\r\nvar ssh = require('./ssh');\r\nvar rfc4253 = require('./rfc4253');\r\nvar dnssec = require('./dnssec');\r\nvar putty = require('./putty');\r\n\r\nvar DNSSEC_PRIVKEY_HEADER_PREFIX = 'Private-key-format: v1';\r\n\r\nfunction read(buf, options) {\r\n\tif (typeof (buf) === 'string') {\r\n\t\tif (buf.trim().match(/^[-]+[ ]*BEGIN/))\r\n\t\t\treturn (pem.read(buf, options));\r\n\t\tif (buf.match(/^\\s*ssh-[a-z]/))\r\n\t\t\treturn (ssh.read(buf, options));\r\n\t\tif (buf.match(/^\\s*ecdsa-/))\r\n\t\t\treturn (ssh.read(buf, options));\r\n\t\tif (buf.match(/^putty-user-key-file-2:/i))\r\n\t\t\treturn (putty.read(buf, options));\r\n\t\tif (findDNSSECHeader(buf))\r\n\t\t\treturn (dnssec.read(buf, options));\r\n\t\tbuf = Buffer.from(buf, 'binary');\r\n\t} else {\r\n\t\tassert.buffer(buf);\r\n\t\tif (findPEMHeader(buf))\r\n\t\t\treturn (pem.read(buf, options));\r\n\t\tif (findSSHHeader(buf))\r\n\t\t\treturn (ssh.read(buf, options));\r\n\t\tif (findPuTTYHeader(buf))\r\n\t\t\treturn (putty.read(buf, options));\r\n\t\tif (findDNSSECHeader(buf))\r\n\t\t\treturn (dnssec.read(buf, options));\r\n\t}\r\n\tif (buf.readUInt32BE(0) < buf.length)\r\n\t\treturn (rfc4253.read(buf, options));\r\n\tthrow (new Error('Failed to auto-detect format of key'));\r\n}\r\n\r\nfunction findPuTTYHeader(buf) {\r\n\tvar offset = 0;\r\n\twhile (offset < buf.length &&\r\n\t    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))\r\n\t\t++offset;\r\n\tif (offset + 22 <= buf.length &&\r\n\t    buf.slice(offset, offset + 22).toString('ascii').toLowerCase() ===\r\n\t    'putty-user-key-file-2:')\r\n\t\treturn (true);\r\n\treturn (false);\r\n}\r\n\r\nfunction findSSHHeader(buf) {\r\n\tvar offset = 0;\r\n\twhile (offset < buf.length &&\r\n\t    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))\r\n\t\t++offset;\r\n\tif (offset + 4 <= buf.length &&\r\n\t    buf.slice(offset, offset + 4).toString('ascii') === 'ssh-')\r\n\t\treturn (true);\r\n\tif (offset + 6 <= buf.length &&\r\n\t    buf.slice(offset, offset + 6).toString('ascii') === 'ecdsa-')\r\n\t\treturn (true);\r\n\treturn (false);\r\n}\r\n\r\nfunction findPEMHeader(buf) {\r\n\tvar offset = 0;\r\n\twhile (offset < buf.length &&\r\n\t    (buf[offset] === 32 || buf[offset] === 10))\r\n\t\t++offset;\r\n\tif (buf[offset] !== 45)\r\n\t\treturn (false);\r\n\twhile (offset < buf.length &&\r\n\t    (buf[offset] === 45))\r\n\t\t++offset;\r\n\twhile (offset < buf.length &&\r\n\t    (buf[offset] === 32))\r\n\t\t++offset;\r\n\tif (offset + 5 > buf.length ||\r\n\t    buf.slice(offset, offset + 5).toString('ascii') !== 'BEGIN')\r\n\t\treturn (false);\r\n\treturn (true);\r\n}\r\n\r\nfunction findDNSSECHeader(buf) {\r\n\t// private case first\r\n\tif (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)\r\n\t\treturn (false);\r\n\tvar headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);\r\n\tif (headerCheck.toString('ascii') === DNSSEC_PRIVKEY_HEADER_PREFIX)\r\n\t\treturn (true);\r\n\r\n\t// public-key RFC3110 ?\r\n\t// 'domain.com. IN KEY ...' or 'domain.com. IN DNSKEY ...'\r\n\t// skip any comment-lines\r\n\tif (typeof (buf) !== 'string') {\r\n\t\tbuf = buf.toString('ascii');\r\n\t}\r\n\tvar lines = buf.split('\\n');\r\n\tvar line = 0;\r\n\t/* JSSTYLED */\r\n\twhile (lines[line].match(/^\\;/))\r\n\t\tline++;\r\n\tif (lines[line].toString('ascii').match(/\\. IN KEY /))\r\n\t\treturn (true);\r\n\tif (lines[line].toString('ascii').match(/\\. IN DNSKEY /))\r\n\t\treturn (true);\r\n\treturn (false);\r\n}\r\n\r\nfunction write(key, options) {\r\n\tthrow (new Error('\"auto\" format cannot be used for writing'));\r\n}\r\n","// Copyright 2018 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\twrite: write\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar asn1 = require('asn1');\r\nvar crypto = require('crypto');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('../algs');\r\nvar utils = require('../utils');\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\n\r\nvar pkcs1 = require('./pkcs1');\r\nvar pkcs8 = require('./pkcs8');\r\nvar sshpriv = require('./ssh-private');\r\nvar rfc4253 = require('./rfc4253');\r\n\r\nvar errors = require('../errors');\r\n\r\nvar OID_PBES2 = '1.2.840.113549.1.5.13';\r\nvar OID_PBKDF2 = '1.2.840.113549.1.5.12';\r\n\r\nvar OID_TO_CIPHER = {\r\n\t'1.2.840.113549.3.7': '3des-cbc',\r\n\t'2.16.840.1.101.3.4.1.2': 'aes128-cbc',\r\n\t'2.16.840.1.101.3.4.1.42': 'aes256-cbc'\r\n};\r\nvar CIPHER_TO_OID = {};\r\nObject.keys(OID_TO_CIPHER).forEach(function (k) {\r\n\tCIPHER_TO_OID[OID_TO_CIPHER[k]] = k;\r\n});\r\n\r\nvar OID_TO_HASH = {\r\n\t'1.2.840.113549.2.7': 'sha1',\r\n\t'1.2.840.113549.2.9': 'sha256',\r\n\t'1.2.840.113549.2.11': 'sha512'\r\n};\r\nvar HASH_TO_OID = {};\r\nObject.keys(OID_TO_HASH).forEach(function (k) {\r\n\tHASH_TO_OID[OID_TO_HASH[k]] = k;\r\n});\r\n\r\n/*\r\n * For reading we support both PKCS#1 and PKCS#8. If we find a private key,\r\n * we just take the public component of it and use that.\r\n */\r\nfunction read(buf, options, forceType) {\r\n\tvar input = buf;\r\n\tif (typeof (buf) !== 'string') {\r\n\t\tassert.buffer(buf, 'buf');\r\n\t\tbuf = buf.toString('ascii');\r\n\t}\r\n\r\n\tvar lines = buf.trim().split(/[\\r\\n]+/g);\r\n\r\n\tvar m;\r\n\tvar si = -1;\r\n\twhile (!m && si < lines.length) {\r\n\t\tm = lines[++si].match(/*JSSTYLED*/\r\n\t\t    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\r\n\t}\r\n\tassert.ok(m, 'invalid PEM header');\r\n\r\n\tvar m2;\r\n\tvar ei = lines.length;\r\n\twhile (!m2 && ei > 0) {\r\n\t\tm2 = lines[--ei].match(/*JSSTYLED*/\r\n\t\t    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);\r\n\t}\r\n\tassert.ok(m2, 'invalid PEM footer');\r\n\r\n\t/* Begin and end banners must match key type */\r\n\tassert.equal(m[2], m2[2]);\r\n\tvar type = m[2].toLowerCase();\r\n\r\n\tvar alg;\r\n\tif (m[1]) {\r\n\t\t/* They also must match algorithms, if given */\r\n\t\tassert.equal(m[1], m2[1], 'PEM header and footer mismatch');\r\n\t\talg = m[1].trim();\r\n\t}\r\n\r\n\tlines = lines.slice(si, ei + 1);\r\n\r\n\tvar headers = {};\r\n\twhile (true) {\r\n\t\tlines = lines.slice(1);\r\n\t\tm = lines[0].match(/*JSSTYLED*/\r\n\t\t    /^([A-Za-z0-9-]+): (.+)$/);\r\n\t\tif (!m)\r\n\t\t\tbreak;\r\n\t\theaders[m[1].toLowerCase()] = m[2];\r\n\t}\r\n\r\n\t/* Chop off the first and last lines */\r\n\tlines = lines.slice(0, -1).join('');\r\n\tbuf = Buffer.from(lines, 'base64');\r\n\r\n\tvar cipher, key, iv;\r\n\tif (headers['proc-type']) {\r\n\t\tvar parts = headers['proc-type'].split(',');\r\n\t\tif (parts[0] === '4' && parts[1] === 'ENCRYPTED') {\r\n\t\t\tif (typeof (options.passphrase) === 'string') {\r\n\t\t\t\toptions.passphrase = Buffer.from(\r\n\t\t\t\t    options.passphrase, 'utf-8');\r\n\t\t\t}\r\n\t\t\tif (!Buffer.isBuffer(options.passphrase)) {\r\n\t\t\t\tthrow (new errors.KeyEncryptedError(\r\n\t\t\t\t    options.filename, 'PEM'));\r\n\t\t\t} else {\r\n\t\t\t\tparts = headers['dek-info'].split(',');\r\n\t\t\t\tassert.ok(parts.length === 2);\r\n\t\t\t\tcipher = parts[0].toLowerCase();\r\n\t\t\t\tiv = Buffer.from(parts[1], 'hex');\r\n\t\t\t\tkey = utils.opensslKeyDeriv(cipher, iv,\r\n\t\t\t\t    options.passphrase, 1).key;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (alg && alg.toLowerCase() === 'encrypted') {\r\n\t\tvar eder = new asn1.BerReader(buf);\r\n\t\tvar pbesEnd;\r\n\t\teder.readSequence();\r\n\r\n\t\teder.readSequence();\r\n\t\tpbesEnd = eder.offset + eder.length;\r\n\r\n\t\tvar method = eder.readOID();\r\n\t\tif (method !== OID_PBES2) {\r\n\t\t\tthrow (new Error('Unsupported PEM/PKCS8 encryption ' +\r\n\t\t\t    'scheme: ' + method));\r\n\t\t}\r\n\r\n\t\teder.readSequence();\t/* PBES2-params */\r\n\r\n\t\teder.readSequence();\t/* keyDerivationFunc */\r\n\t\tvar kdfEnd = eder.offset + eder.length;\r\n\t\tvar kdfOid = eder.readOID();\r\n\t\tif (kdfOid !== OID_PBKDF2)\r\n\t\t\tthrow (new Error('Unsupported PBES2 KDF: ' + kdfOid));\r\n\t\teder.readSequence();\r\n\t\tvar salt = eder.readString(asn1.Ber.OctetString, true);\r\n\t\tvar iterations = eder.readInt();\r\n\t\tvar hashAlg = 'sha1';\r\n\t\tif (eder.offset < kdfEnd) {\r\n\t\t\teder.readSequence();\r\n\t\t\tvar hashAlgOid = eder.readOID();\r\n\t\t\thashAlg = OID_TO_HASH[hashAlgOid];\r\n\t\t\tif (hashAlg === undefined) {\r\n\t\t\t\tthrow (new Error('Unsupported PBKDF2 hash: ' +\r\n\t\t\t\t    hashAlgOid));\r\n\t\t\t}\r\n\t\t}\r\n\t\teder._offset = kdfEnd;\r\n\r\n\t\teder.readSequence();\t/* encryptionScheme */\r\n\t\tvar cipherOid = eder.readOID();\r\n\t\tcipher = OID_TO_CIPHER[cipherOid];\r\n\t\tif (cipher === undefined) {\r\n\t\t\tthrow (new Error('Unsupported PBES2 cipher: ' +\r\n\t\t\t    cipherOid));\r\n\t\t}\r\n\t\tiv = eder.readString(asn1.Ber.OctetString, true);\r\n\r\n\t\teder._offset = pbesEnd;\r\n\t\tbuf = eder.readString(asn1.Ber.OctetString, true);\r\n\r\n\t\tif (typeof (options.passphrase) === 'string') {\r\n\t\t\toptions.passphrase = Buffer.from(\r\n\t\t\t    options.passphrase, 'utf-8');\r\n\t\t}\r\n\t\tif (!Buffer.isBuffer(options.passphrase)) {\r\n\t\t\tthrow (new errors.KeyEncryptedError(\r\n\t\t\t    options.filename, 'PEM'));\r\n\t\t}\r\n\r\n\t\tvar cinfo = utils.opensshCipherInfo(cipher);\r\n\r\n\t\tcipher = cinfo.opensslName;\r\n\t\tkey = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,\r\n\t\t    options.passphrase);\r\n\t\talg = undefined;\r\n\t}\r\n\r\n\tif (cipher && key && iv) {\r\n\t\tvar cipherStream = crypto.createDecipheriv(cipher, key, iv);\r\n\t\tvar chunk, chunks = [];\r\n\t\tcipherStream.once('error', function (e) {\r\n\t\t\tif (e.toString().indexOf('bad decrypt') !== -1) {\r\n\t\t\t\tthrow (new Error('Incorrect passphrase ' +\r\n\t\t\t\t    'supplied, could not decrypt key'));\r\n\t\t\t}\r\n\t\t\tthrow (e);\r\n\t\t});\r\n\t\tcipherStream.write(buf);\r\n\t\tcipherStream.end();\r\n\t\twhile ((chunk = cipherStream.read()) !== null)\r\n\t\t\tchunks.push(chunk);\r\n\t\tbuf = Buffer.concat(chunks);\r\n\t}\r\n\r\n\t/* The new OpenSSH internal format abuses PEM headers */\r\n\tif (alg && alg.toLowerCase() === 'openssh')\r\n\t\treturn (sshpriv.readSSHPrivate(type, buf, options));\r\n\tif (alg && alg.toLowerCase() === 'ssh2')\r\n\t\treturn (rfc4253.readType(type, buf, options));\r\n\r\n\tvar der = new asn1.BerReader(buf);\r\n\tder.originalInput = input;\r\n\r\n\t/*\r\n\t * All of the PEM file types start with a sequence tag, so chop it\r\n\t * off here\r\n\t */\r\n\tder.readSequence();\r\n\r\n\t/* PKCS#1 type keys name an algorithm in the banner explicitly */\r\n\tif (alg) {\r\n\t\tif (forceType)\r\n\t\t\tassert.strictEqual(forceType, 'pkcs1');\r\n\t\treturn (pkcs1.readPkcs1(alg, type, der));\r\n\t} else {\r\n\t\tif (forceType)\r\n\t\t\tassert.strictEqual(forceType, 'pkcs8');\r\n\t\treturn (pkcs8.readPkcs8(alg, type, der));\r\n\t}\r\n}\r\n\r\nfunction write(key, options, type) {\r\n\tassert.object(key);\r\n\r\n\tvar alg = {\r\n\t    'ecdsa': 'EC',\r\n\t    'rsa': 'RSA',\r\n\t    'dsa': 'DSA',\r\n\t    'ed25519': 'EdDSA'\r\n\t}[key.type];\r\n\tvar header;\r\n\r\n\tvar der = new asn1.BerWriter();\r\n\r\n\tif (PrivateKey.isPrivateKey(key)) {\r\n\t\tif (type && type === 'pkcs8') {\r\n\t\t\theader = 'PRIVATE KEY';\r\n\t\t\tpkcs8.writePkcs8(der, key);\r\n\t\t} else {\r\n\t\t\tif (type)\r\n\t\t\t\tassert.strictEqual(type, 'pkcs1');\r\n\t\t\theader = alg + ' PRIVATE KEY';\r\n\t\t\tpkcs1.writePkcs1(der, key);\r\n\t\t}\r\n\r\n\t} else if (Key.isKey(key)) {\r\n\t\tif (type && type === 'pkcs1') {\r\n\t\t\theader = alg + ' PUBLIC KEY';\r\n\t\t\tpkcs1.writePkcs1(der, key);\r\n\t\t} else {\r\n\t\t\tif (type)\r\n\t\t\t\tassert.strictEqual(type, 'pkcs8');\r\n\t\t\theader = 'PUBLIC KEY';\r\n\t\t\tpkcs8.writePkcs8(der, key);\r\n\t\t}\r\n\r\n\t} else {\r\n\t\tthrow (new Error('key is not a Key or PrivateKey'));\r\n\t}\r\n\r\n\tvar tmp = der.buffer.toString('base64');\r\n\tvar len = tmp.length + (tmp.length / 64) +\r\n\t    18 + 16 + header.length*2 + 10;\r\n\tvar buf = Buffer.alloc(len);\r\n\tvar o = 0;\r\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\r\n\tfor (var i = 0; i < tmp.length; ) {\r\n\t\tvar limit = i + 64;\r\n\t\tif (limit > tmp.length)\r\n\t\t\tlimit = tmp.length;\r\n\t\to += buf.write(tmp.slice(i, limit), o);\r\n\t\tbuf[o++] = 10;\r\n\t\ti = limit;\r\n\t}\r\n\to += buf.write('-----END ' + header + '-----\\n', o);\r\n\r\n\treturn (buf.slice(0, o));\r\n}\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\treadPkcs1: readPkcs1,\r\n\twrite: write,\r\n\twritePkcs1: writePkcs1\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar asn1 = require('asn1');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('../algs');\r\nvar utils = require('../utils');\r\n\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\nvar pem = require('./pem');\r\n\r\nvar pkcs8 = require('./pkcs8');\r\nvar readECDSACurve = pkcs8.readECDSACurve;\r\n\r\nfunction read(buf, options) {\r\n\treturn (pem.read(buf, options, 'pkcs1'));\r\n}\r\n\r\nfunction write(key, options) {\r\n\treturn (pem.write(key, options, 'pkcs1'));\r\n}\r\n\r\n/* Helper to read in a single mpint */\r\nfunction readMPInt(der, nm) {\r\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\r\n\t    nm + ' is not an Integer');\r\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\r\n}\r\n\r\nfunction readPkcs1(alg, type, der) {\r\n\tswitch (alg) {\r\n\tcase 'RSA':\r\n\t\tif (type === 'public')\r\n\t\t\treturn (readPkcs1RSAPublic(der));\r\n\t\telse if (type === 'private')\r\n\t\t\treturn (readPkcs1RSAPrivate(der));\r\n\t\tthrow (new Error('Unknown key type: ' + type));\r\n\tcase 'DSA':\r\n\t\tif (type === 'public')\r\n\t\t\treturn (readPkcs1DSAPublic(der));\r\n\t\telse if (type === 'private')\r\n\t\t\treturn (readPkcs1DSAPrivate(der));\r\n\t\tthrow (new Error('Unknown key type: ' + type));\r\n\tcase 'EC':\r\n\tcase 'ECDSA':\r\n\t\tif (type === 'private')\r\n\t\t\treturn (readPkcs1ECDSAPrivate(der));\r\n\t\telse if (type === 'public')\r\n\t\t\treturn (readPkcs1ECDSAPublic(der));\r\n\t\tthrow (new Error('Unknown key type: ' + type));\r\n\tcase 'EDDSA':\r\n\tcase 'EdDSA':\r\n\t\tif (type === 'private')\r\n\t\t\treturn (readPkcs1EdDSAPrivate(der));\r\n\t\tthrow (new Error(type + ' keys not supported with EdDSA'));\r\n\tdefault:\r\n\t\tthrow (new Error('Unknown key algo: ' + alg));\r\n\t}\r\n}\r\n\r\nfunction readPkcs1RSAPublic(der) {\r\n\t// modulus and exponent\r\n\tvar n = readMPInt(der, 'modulus');\r\n\tvar e = readMPInt(der, 'exponent');\r\n\r\n\t// now, make the key\r\n\tvar key = {\r\n\t\ttype: 'rsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'e', data: e },\r\n\t\t\t{ name: 'n', data: n }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new Key(key));\r\n}\r\n\r\nfunction readPkcs1RSAPrivate(der) {\r\n\tvar version = readMPInt(der, 'version');\r\n\tassert.strictEqual(version[0], 0);\r\n\r\n\t// modulus then public exponent\r\n\tvar n = readMPInt(der, 'modulus');\r\n\tvar e = readMPInt(der, 'public exponent');\r\n\tvar d = readMPInt(der, 'private exponent');\r\n\tvar p = readMPInt(der, 'prime1');\r\n\tvar q = readMPInt(der, 'prime2');\r\n\tvar dmodp = readMPInt(der, 'exponent1');\r\n\tvar dmodq = readMPInt(der, 'exponent2');\r\n\tvar iqmp = readMPInt(der, 'iqmp');\r\n\r\n\t// now, make the key\r\n\tvar key = {\r\n\t\ttype: 'rsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'n', data: n },\r\n\t\t\t{ name: 'e', data: e },\r\n\t\t\t{ name: 'd', data: d },\r\n\t\t\t{ name: 'iqmp', data: iqmp },\r\n\t\t\t{ name: 'p', data: p },\r\n\t\t\t{ name: 'q', data: q },\r\n\t\t\t{ name: 'dmodp', data: dmodp },\r\n\t\t\t{ name: 'dmodq', data: dmodq }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction readPkcs1DSAPrivate(der) {\r\n\tvar version = readMPInt(der, 'version');\r\n\tassert.strictEqual(version.readUInt8(0), 0);\r\n\r\n\tvar p = readMPInt(der, 'p');\r\n\tvar q = readMPInt(der, 'q');\r\n\tvar g = readMPInt(der, 'g');\r\n\tvar y = readMPInt(der, 'y');\r\n\tvar x = readMPInt(der, 'x');\r\n\r\n\t// now, make the key\r\n\tvar key = {\r\n\t\ttype: 'dsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'p', data: p },\r\n\t\t\t{ name: 'q', data: q },\r\n\t\t\t{ name: 'g', data: g },\r\n\t\t\t{ name: 'y', data: y },\r\n\t\t\t{ name: 'x', data: x }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction readPkcs1EdDSAPrivate(der) {\r\n\tvar version = readMPInt(der, 'version');\r\n\tassert.strictEqual(version.readUInt8(0), 1);\r\n\r\n\t// private key\r\n\tvar k = der.readString(asn1.Ber.OctetString, true);\r\n\r\n\tder.readSequence(0xa0);\r\n\tvar oid = der.readOID();\r\n\tassert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');\r\n\r\n\tder.readSequence(0xa1);\r\n\tvar A = utils.readBitString(der);\r\n\r\n\tvar key = {\r\n\t\ttype: 'ed25519',\r\n\t\tparts: [\r\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\r\n\t\t\t{ name: 'k', data: k }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction readPkcs1DSAPublic(der) {\r\n\tvar y = readMPInt(der, 'y');\r\n\tvar p = readMPInt(der, 'p');\r\n\tvar q = readMPInt(der, 'q');\r\n\tvar g = readMPInt(der, 'g');\r\n\r\n\tvar key = {\r\n\t\ttype: 'dsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'y', data: y },\r\n\t\t\t{ name: 'p', data: p },\r\n\t\t\t{ name: 'q', data: q },\r\n\t\t\t{ name: 'g', data: g }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new Key(key));\r\n}\r\n\r\nfunction readPkcs1ECDSAPublic(der) {\r\n\tder.readSequence();\r\n\r\n\tvar oid = der.readOID();\r\n\tassert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');\r\n\r\n\tvar curveOid = der.readOID();\r\n\r\n\tvar curve;\r\n\tvar curves = Object.keys(algs.curves);\r\n\tfor (var j = 0; j < curves.length; ++j) {\r\n\t\tvar c = curves[j];\r\n\t\tvar cd = algs.curves[c];\r\n\t\tif (cd.pkcs8oid === curveOid) {\r\n\t\t\tcurve = c;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tassert.string(curve, 'a known ECDSA named curve');\r\n\r\n\tvar Q = der.readString(asn1.Ber.BitString, true);\r\n\tQ = utils.ecNormalize(Q);\r\n\r\n\tvar key = {\r\n\t\ttype: 'ecdsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'curve', data: Buffer.from(curve) },\r\n\t\t\t{ name: 'Q', data: Q }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new Key(key));\r\n}\r\n\r\nfunction readPkcs1ECDSAPrivate(der) {\r\n\tvar version = readMPInt(der, 'version');\r\n\tassert.strictEqual(version.readUInt8(0), 1);\r\n\r\n\t// private key\r\n\tvar d = der.readString(asn1.Ber.OctetString, true);\r\n\r\n\tder.readSequence(0xa0);\r\n\tvar curve = readECDSACurve(der);\r\n\tassert.string(curve, 'a known elliptic curve');\r\n\r\n\tder.readSequence(0xa1);\r\n\tvar Q = der.readString(asn1.Ber.BitString, true);\r\n\tQ = utils.ecNormalize(Q);\r\n\r\n\tvar key = {\r\n\t\ttype: 'ecdsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'curve', data: Buffer.from(curve) },\r\n\t\t\t{ name: 'Q', data: Q },\r\n\t\t\t{ name: 'd', data: d }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction writePkcs1(der, key) {\r\n\tder.startSequence();\r\n\r\n\tswitch (key.type) {\r\n\tcase 'rsa':\r\n\t\tif (PrivateKey.isPrivateKey(key))\r\n\t\t\twritePkcs1RSAPrivate(der, key);\r\n\t\telse\r\n\t\t\twritePkcs1RSAPublic(der, key);\r\n\t\tbreak;\r\n\tcase 'dsa':\r\n\t\tif (PrivateKey.isPrivateKey(key))\r\n\t\t\twritePkcs1DSAPrivate(der, key);\r\n\t\telse\r\n\t\t\twritePkcs1DSAPublic(der, key);\r\n\t\tbreak;\r\n\tcase 'ecdsa':\r\n\t\tif (PrivateKey.isPrivateKey(key))\r\n\t\t\twritePkcs1ECDSAPrivate(der, key);\r\n\t\telse\r\n\t\t\twritePkcs1ECDSAPublic(der, key);\r\n\t\tbreak;\r\n\tcase 'ed25519':\r\n\t\tif (PrivateKey.isPrivateKey(key))\r\n\t\t\twritePkcs1EdDSAPrivate(der, key);\r\n\t\telse\r\n\t\t\twritePkcs1EdDSAPublic(der, key);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tthrow (new Error('Unknown key algo: ' + key.type));\r\n\t}\r\n\r\n\tder.endSequence();\r\n}\r\n\r\nfunction writePkcs1RSAPublic(der, key) {\r\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\r\n}\r\n\r\nfunction writePkcs1RSAPrivate(der, key) {\r\n\tvar ver = Buffer.from([0]);\r\n\tder.writeBuffer(ver, asn1.Ber.Integer);\r\n\r\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\r\n\tif (!key.part.dmodp || !key.part.dmodq)\r\n\t\tutils.addRSAMissing(key);\r\n\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\r\n}\r\n\r\nfunction writePkcs1DSAPrivate(der, key) {\r\n\tvar ver = Buffer.from([0]);\r\n\tder.writeBuffer(ver, asn1.Ber.Integer);\r\n\r\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\r\n}\r\n\r\nfunction writePkcs1DSAPublic(der, key) {\r\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\r\n}\r\n\r\nfunction writePkcs1ECDSAPublic(der, key) {\r\n\tder.startSequence();\r\n\r\n\tder.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */\r\n\tvar curve = key.part.curve.data.toString();\r\n\tvar curveOid = algs.curves[curve].pkcs8oid;\r\n\tassert.string(curveOid, 'a known ECDSA named curve');\r\n\tder.writeOID(curveOid);\r\n\r\n\tder.endSequence();\r\n\r\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\r\n\tder.writeBuffer(Q, asn1.Ber.BitString);\r\n}\r\n\r\nfunction writePkcs1ECDSAPrivate(der, key) {\r\n\tvar ver = Buffer.from([1]);\r\n\tder.writeBuffer(ver, asn1.Ber.Integer);\r\n\r\n\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\r\n\r\n\tder.startSequence(0xa0);\r\n\tvar curve = key.part.curve.data.toString();\r\n\tvar curveOid = algs.curves[curve].pkcs8oid;\r\n\tassert.string(curveOid, 'a known ECDSA named curve');\r\n\tder.writeOID(curveOid);\r\n\tder.endSequence();\r\n\r\n\tder.startSequence(0xa1);\r\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\r\n\tder.writeBuffer(Q, asn1.Ber.BitString);\r\n\tder.endSequence();\r\n}\r\n\r\nfunction writePkcs1EdDSAPrivate(der, key) {\r\n\tvar ver = Buffer.from([1]);\r\n\tder.writeBuffer(ver, asn1.Ber.Integer);\r\n\r\n\tder.writeBuffer(key.part.k.data, asn1.Ber.OctetString);\r\n\r\n\tder.startSequence(0xa0);\r\n\tder.writeOID('1.3.101.112');\r\n\tder.endSequence();\r\n\r\n\tder.startSequence(0xa1);\r\n\tutils.writeBitString(der, key.part.A.data);\r\n\tder.endSequence();\r\n}\r\n\r\nfunction writePkcs1EdDSAPublic(der, key) {\r\n\tthrow (new Error('Public keys are not supported for EdDSA PKCS#1'));\r\n}\r\n","// Copyright 2018 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\treadPkcs8: readPkcs8,\r\n\twrite: write,\r\n\twritePkcs8: writePkcs8,\r\n\tpkcs8ToBuffer: pkcs8ToBuffer,\r\n\r\n\treadECDSACurve: readECDSACurve,\r\n\twriteECDSACurve: writeECDSACurve\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar asn1 = require('asn1');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('../algs');\r\nvar utils = require('../utils');\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\nvar pem = require('./pem');\r\n\r\nfunction read(buf, options) {\r\n\treturn (pem.read(buf, options, 'pkcs8'));\r\n}\r\n\r\nfunction write(key, options) {\r\n\treturn (pem.write(key, options, 'pkcs8'));\r\n}\r\n\r\n/* Helper to read in a single mpint */\r\nfunction readMPInt(der, nm) {\r\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\r\n\t    nm + ' is not an Integer');\r\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\r\n}\r\n\r\nfunction readPkcs8(alg, type, der) {\r\n\t/* Private keys in pkcs#8 format have a weird extra int */\r\n\tif (der.peek() === asn1.Ber.Integer) {\r\n\t\tassert.strictEqual(type, 'private',\r\n\t\t    'unexpected Integer at start of public key');\r\n\t\tder.readString(asn1.Ber.Integer, true);\r\n\t}\r\n\r\n\tder.readSequence();\r\n\tvar next = der.offset + der.length;\r\n\r\n\tvar oid = der.readOID();\r\n\tswitch (oid) {\r\n\tcase '1.2.840.113549.1.1.1':\r\n\t\tder._offset = next;\r\n\t\tif (type === 'public')\r\n\t\t\treturn (readPkcs8RSAPublic(der));\r\n\t\telse\r\n\t\t\treturn (readPkcs8RSAPrivate(der));\r\n\tcase '1.2.840.10040.4.1':\r\n\t\tif (type === 'public')\r\n\t\t\treturn (readPkcs8DSAPublic(der));\r\n\t\telse\r\n\t\t\treturn (readPkcs8DSAPrivate(der));\r\n\tcase '1.2.840.10045.2.1':\r\n\t\tif (type === 'public')\r\n\t\t\treturn (readPkcs8ECDSAPublic(der));\r\n\t\telse\r\n\t\t\treturn (readPkcs8ECDSAPrivate(der));\r\n\tcase '1.3.101.112':\r\n\t\tif (type === 'public') {\r\n\t\t\treturn (readPkcs8EdDSAPublic(der));\r\n\t\t} else {\r\n\t\t\treturn (readPkcs8EdDSAPrivate(der));\r\n\t\t}\r\n\tcase '1.3.101.110':\r\n\t\tif (type === 'public') {\r\n\t\t\treturn (readPkcs8X25519Public(der));\r\n\t\t} else {\r\n\t\t\treturn (readPkcs8X25519Private(der));\r\n\t\t}\r\n\tdefault:\r\n\t\tthrow (new Error('Unknown key type OID ' + oid));\r\n\t}\r\n}\r\n\r\nfunction readPkcs8RSAPublic(der) {\r\n\t// bit string sequence\r\n\tder.readSequence(asn1.Ber.BitString);\r\n\tder.readByte();\r\n\tder.readSequence();\r\n\r\n\t// modulus\r\n\tvar n = readMPInt(der, 'modulus');\r\n\tvar e = readMPInt(der, 'exponent');\r\n\r\n\t// now, make the key\r\n\tvar key = {\r\n\t\ttype: 'rsa',\r\n\t\tsource: der.originalInput,\r\n\t\tparts: [\r\n\t\t\t{ name: 'e', data: e },\r\n\t\t\t{ name: 'n', data: n }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new Key(key));\r\n}\r\n\r\nfunction readPkcs8RSAPrivate(der) {\r\n\tder.readSequence(asn1.Ber.OctetString);\r\n\tder.readSequence();\r\n\r\n\tvar ver = readMPInt(der, 'version');\r\n\tassert.equal(ver[0], 0x0, 'unknown RSA private key version');\r\n\r\n\t// modulus then public exponent\r\n\tvar n = readMPInt(der, 'modulus');\r\n\tvar e = readMPInt(der, 'public exponent');\r\n\tvar d = readMPInt(der, 'private exponent');\r\n\tvar p = readMPInt(der, 'prime1');\r\n\tvar q = readMPInt(der, 'prime2');\r\n\tvar dmodp = readMPInt(der, 'exponent1');\r\n\tvar dmodq = readMPInt(der, 'exponent2');\r\n\tvar iqmp = readMPInt(der, 'iqmp');\r\n\r\n\t// now, make the key\r\n\tvar key = {\r\n\t\ttype: 'rsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'n', data: n },\r\n\t\t\t{ name: 'e', data: e },\r\n\t\t\t{ name: 'd', data: d },\r\n\t\t\t{ name: 'iqmp', data: iqmp },\r\n\t\t\t{ name: 'p', data: p },\r\n\t\t\t{ name: 'q', data: q },\r\n\t\t\t{ name: 'dmodp', data: dmodp },\r\n\t\t\t{ name: 'dmodq', data: dmodq }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction readPkcs8DSAPublic(der) {\r\n\tder.readSequence();\r\n\r\n\tvar p = readMPInt(der, 'p');\r\n\tvar q = readMPInt(der, 'q');\r\n\tvar g = readMPInt(der, 'g');\r\n\r\n\t// bit string sequence\r\n\tder.readSequence(asn1.Ber.BitString);\r\n\tder.readByte();\r\n\r\n\tvar y = readMPInt(der, 'y');\r\n\r\n\t// now, make the key\r\n\tvar key = {\r\n\t\ttype: 'dsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'p', data: p },\r\n\t\t\t{ name: 'q', data: q },\r\n\t\t\t{ name: 'g', data: g },\r\n\t\t\t{ name: 'y', data: y }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new Key(key));\r\n}\r\n\r\nfunction readPkcs8DSAPrivate(der) {\r\n\tder.readSequence();\r\n\r\n\tvar p = readMPInt(der, 'p');\r\n\tvar q = readMPInt(der, 'q');\r\n\tvar g = readMPInt(der, 'g');\r\n\r\n\tder.readSequence(asn1.Ber.OctetString);\r\n\tvar x = readMPInt(der, 'x');\r\n\r\n\t/* The pkcs#8 format does not include the public key */\r\n\tvar y = utils.calculateDSAPublic(g, p, x);\r\n\r\n\tvar key = {\r\n\t\ttype: 'dsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'p', data: p },\r\n\t\t\t{ name: 'q', data: q },\r\n\t\t\t{ name: 'g', data: g },\r\n\t\t\t{ name: 'y', data: y },\r\n\t\t\t{ name: 'x', data: x }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction readECDSACurve(der) {\r\n\tvar curveName, curveNames;\r\n\tvar j, c, cd;\r\n\r\n\tif (der.peek() === asn1.Ber.OID) {\r\n\t\tvar oid = der.readOID();\r\n\r\n\t\tcurveNames = Object.keys(algs.curves);\r\n\t\tfor (j = 0; j < curveNames.length; ++j) {\r\n\t\t\tc = curveNames[j];\r\n\t\t\tcd = algs.curves[c];\r\n\t\t\tif (cd.pkcs8oid === oid) {\r\n\t\t\t\tcurveName = c;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} else {\r\n\t\t// ECParameters sequence\r\n\t\tder.readSequence();\r\n\t\tvar version = der.readString(asn1.Ber.Integer, true);\r\n\t\tassert.strictEqual(version[0], 1, 'ECDSA key not version 1');\r\n\r\n\t\tvar curve = {};\r\n\r\n\t\t// FieldID sequence\r\n\t\tder.readSequence();\r\n\t\tvar fieldTypeOid = der.readOID();\r\n\t\tassert.strictEqual(fieldTypeOid, '1.2.840.10045.1.1',\r\n\t\t    'ECDSA key is not from a prime-field');\r\n\t\tvar p = curve.p = utils.mpNormalize(\r\n\t\t    der.readString(asn1.Ber.Integer, true));\r\n\t\t/*\r\n\t\t * p always starts with a 1 bit, so count the zeros to get its\r\n\t\t * real size.\r\n\t\t */\r\n\t\tcurve.size = p.length * 8 - utils.countZeros(p);\r\n\r\n\t\t// Curve sequence\r\n\t\tder.readSequence();\r\n\t\tcurve.a = utils.mpNormalize(\r\n\t\t    der.readString(asn1.Ber.OctetString, true));\r\n\t\tcurve.b = utils.mpNormalize(\r\n\t\t    der.readString(asn1.Ber.OctetString, true));\r\n\t\tif (der.peek() === asn1.Ber.BitString)\r\n\t\t\tcurve.s = der.readString(asn1.Ber.BitString, true);\r\n\r\n\t\t// Combined Gx and Gy\r\n\t\tcurve.G = der.readString(asn1.Ber.OctetString, true);\r\n\t\tassert.strictEqual(curve.G[0], 0x4,\r\n\t\t    'uncompressed G is required');\r\n\r\n\t\tcurve.n = utils.mpNormalize(\r\n\t\t    der.readString(asn1.Ber.Integer, true));\r\n\t\tcurve.h = utils.mpNormalize(\r\n\t\t    der.readString(asn1.Ber.Integer, true));\r\n\t\tassert.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is ' +\r\n\t\t    'required');\r\n\r\n\t\tcurveNames = Object.keys(algs.curves);\r\n\t\tvar ks = Object.keys(curve);\r\n\t\tfor (j = 0; j < curveNames.length; ++j) {\r\n\t\t\tc = curveNames[j];\r\n\t\t\tcd = algs.curves[c];\r\n\t\t\tvar equal = true;\r\n\t\t\tfor (var i = 0; i < ks.length; ++i) {\r\n\t\t\t\tvar k = ks[i];\r\n\t\t\t\tif (cd[k] === undefined)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tif (typeof (cd[k]) === 'object' &&\r\n\t\t\t\t    cd[k].equals !== undefined) {\r\n\t\t\t\t\tif (!cd[k].equals(curve[k])) {\r\n\t\t\t\t\t\tequal = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (Buffer.isBuffer(cd[k])) {\r\n\t\t\t\t\tif (cd[k].toString('binary')\r\n\t\t\t\t\t    !== curve[k].toString('binary')) {\r\n\t\t\t\t\t\tequal = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (cd[k] !== curve[k]) {\r\n\t\t\t\t\t\tequal = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (equal) {\r\n\t\t\t\tcurveName = c;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn (curveName);\r\n}\r\n\r\nfunction readPkcs8ECDSAPrivate(der) {\r\n\tvar curveName = readECDSACurve(der);\r\n\tassert.string(curveName, 'a known elliptic curve');\r\n\r\n\tder.readSequence(asn1.Ber.OctetString);\r\n\tder.readSequence();\r\n\r\n\tvar version = readMPInt(der, 'version');\r\n\tassert.equal(version[0], 1, 'unknown version of ECDSA key');\r\n\r\n\tvar d = der.readString(asn1.Ber.OctetString, true);\r\n\tvar Q;\r\n\r\n\tif (der.peek() == 0xa0) {\r\n\t\tder.readSequence(0xa0);\r\n\t\tder._offset += der.length;\r\n\t}\r\n\tif (der.peek() == 0xa1) {\r\n\t\tder.readSequence(0xa1);\r\n\t\tQ = der.readString(asn1.Ber.BitString, true);\r\n\t\tQ = utils.ecNormalize(Q);\r\n\t}\r\n\r\n\tif (Q === undefined) {\r\n\t\tvar pub = utils.publicFromPrivateECDSA(curveName, d);\r\n\t\tQ = pub.part.Q.data;\r\n\t}\r\n\r\n\tvar key = {\r\n\t\ttype: 'ecdsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\r\n\t\t\t{ name: 'Q', data: Q },\r\n\t\t\t{ name: 'd', data: d }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction readPkcs8ECDSAPublic(der) {\r\n\tvar curveName = readECDSACurve(der);\r\n\tassert.string(curveName, 'a known elliptic curve');\r\n\r\n\tvar Q = der.readString(asn1.Ber.BitString, true);\r\n\tQ = utils.ecNormalize(Q);\r\n\r\n\tvar key = {\r\n\t\ttype: 'ecdsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'curve', data: Buffer.from(curveName) },\r\n\t\t\t{ name: 'Q', data: Q }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new Key(key));\r\n}\r\n\r\nfunction readPkcs8EdDSAPublic(der) {\r\n\tif (der.peek() === 0x00)\r\n\t\tder.readByte();\r\n\r\n\tvar A = utils.readBitString(der);\r\n\r\n\tvar key = {\r\n\t\ttype: 'ed25519',\r\n\t\tparts: [\r\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new Key(key));\r\n}\r\n\r\nfunction readPkcs8X25519Public(der) {\r\n\tvar A = utils.readBitString(der);\r\n\r\n\tvar key = {\r\n\t\ttype: 'curve25519',\r\n\t\tparts: [\r\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new Key(key));\r\n}\r\n\r\nfunction readPkcs8EdDSAPrivate(der) {\r\n\tif (der.peek() === 0x00)\r\n\t\tder.readByte();\r\n\r\n\tder.readSequence(asn1.Ber.OctetString);\r\n\tvar k = der.readString(asn1.Ber.OctetString, true);\r\n\tk = utils.zeroPadToLength(k, 32);\r\n\r\n\tvar A, tag;\r\n\twhile ((tag = der.peek()) !== null) {\r\n\t\tif (tag === (asn1.Ber.Context | 1)) {\r\n\t\t\tA = utils.readBitString(der, tag);\r\n\t\t} else {\r\n\t\t\tder.readSequence(tag);\r\n\t\t\tder._offset += der.length;\r\n\t\t}\r\n\t}\r\n\tif (A === undefined)\r\n\t\tA = utils.calculateED25519Public(k);\r\n\r\n\tvar key = {\r\n\t\ttype: 'ed25519',\r\n\t\tparts: [\r\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\r\n\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction readPkcs8X25519Private(der) {\r\n\tif (der.peek() === 0x00)\r\n\t\tder.readByte();\r\n\r\n\tder.readSequence(asn1.Ber.OctetString);\r\n\tvar k = der.readString(asn1.Ber.OctetString, true);\r\n\tk = utils.zeroPadToLength(k, 32);\r\n\r\n\tvar A = utils.calculateX25519Public(k);\r\n\r\n\tvar key = {\r\n\t\ttype: 'curve25519',\r\n\t\tparts: [\r\n\t\t\t{ name: 'A', data: utils.zeroPadToLength(A, 32) },\r\n\t\t\t{ name: 'k', data: utils.zeroPadToLength(k, 32) }\r\n\t\t]\r\n\t};\r\n\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction pkcs8ToBuffer(key) {\r\n\tvar der = new asn1.BerWriter();\r\n\twritePkcs8(der, key);\r\n\treturn (der.buffer);\r\n}\r\n\r\nfunction writePkcs8(der, key) {\r\n\tder.startSequence();\r\n\r\n\tif (PrivateKey.isPrivateKey(key)) {\r\n\t\tvar version = 0;\r\n\t\tif (key.type === 'ed25519')\r\n\t\t\tversion = 1;\r\n\t\tvar vbuf = Buffer.from([version]);\r\n\t\tder.writeBuffer(vbuf, asn1.Ber.Integer);\r\n\t}\r\n\r\n\tder.startSequence();\r\n\tswitch (key.type) {\r\n\tcase 'rsa':\r\n\t\tder.writeOID('1.2.840.113549.1.1.1');\r\n\t\tif (PrivateKey.isPrivateKey(key))\r\n\t\t\twritePkcs8RSAPrivate(key, der);\r\n\t\telse\r\n\t\t\twritePkcs8RSAPublic(key, der);\r\n\t\tbreak;\r\n\tcase 'dsa':\r\n\t\tder.writeOID('1.2.840.10040.4.1');\r\n\t\tif (PrivateKey.isPrivateKey(key))\r\n\t\t\twritePkcs8DSAPrivate(key, der);\r\n\t\telse\r\n\t\t\twritePkcs8DSAPublic(key, der);\r\n\t\tbreak;\r\n\tcase 'ecdsa':\r\n\t\tder.writeOID('1.2.840.10045.2.1');\r\n\t\tif (PrivateKey.isPrivateKey(key))\r\n\t\t\twritePkcs8ECDSAPrivate(key, der);\r\n\t\telse\r\n\t\t\twritePkcs8ECDSAPublic(key, der);\r\n\t\tbreak;\r\n\tcase 'ed25519':\r\n\t\tder.writeOID('1.3.101.112');\r\n\t\tif (PrivateKey.isPrivateKey(key))\r\n\t\t\twritePkcs8EdDSAPrivate(key, der);\r\n\t\telse\r\n\t\t\twritePkcs8EdDSAPublic(key, der);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tthrow (new Error('Unsupported key type: ' + key.type));\r\n\t}\r\n\r\n\tder.endSequence();\r\n}\r\n\r\nfunction writePkcs8RSAPrivate(key, der) {\r\n\tder.writeNull();\r\n\tder.endSequence();\r\n\r\n\tder.startSequence(asn1.Ber.OctetString);\r\n\tder.startSequence();\r\n\r\n\tvar version = Buffer.from([0]);\r\n\tder.writeBuffer(version, asn1.Ber.Integer);\r\n\r\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.d.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\r\n\tif (!key.part.dmodp || !key.part.dmodq)\r\n\t\tutils.addRSAMissing(key);\r\n\tder.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);\r\n\r\n\tder.endSequence();\r\n\tder.endSequence();\r\n}\r\n\r\nfunction writePkcs8RSAPublic(key, der) {\r\n\tder.writeNull();\r\n\tder.endSequence();\r\n\r\n\tder.startSequence(asn1.Ber.BitString);\r\n\tder.writeByte(0x00);\r\n\r\n\tder.startSequence();\r\n\tder.writeBuffer(key.part.n.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.e.data, asn1.Ber.Integer);\r\n\tder.endSequence();\r\n\r\n\tder.endSequence();\r\n}\r\n\r\nfunction writePkcs8DSAPrivate(key, der) {\r\n\tder.startSequence();\r\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\r\n\tder.endSequence();\r\n\r\n\tder.endSequence();\r\n\r\n\tder.startSequence(asn1.Ber.OctetString);\r\n\tder.writeBuffer(key.part.x.data, asn1.Ber.Integer);\r\n\tder.endSequence();\r\n}\r\n\r\nfunction writePkcs8DSAPublic(key, der) {\r\n\tder.startSequence();\r\n\tder.writeBuffer(key.part.p.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.q.data, asn1.Ber.Integer);\r\n\tder.writeBuffer(key.part.g.data, asn1.Ber.Integer);\r\n\tder.endSequence();\r\n\tder.endSequence();\r\n\r\n\tder.startSequence(asn1.Ber.BitString);\r\n\tder.writeByte(0x00);\r\n\tder.writeBuffer(key.part.y.data, asn1.Ber.Integer);\r\n\tder.endSequence();\r\n}\r\n\r\nfunction writeECDSACurve(key, der) {\r\n\tvar curve = algs.curves[key.curve];\r\n\tif (curve.pkcs8oid) {\r\n\t\t/* This one has a name in pkcs#8, so just write the oid */\r\n\t\tder.writeOID(curve.pkcs8oid);\r\n\r\n\t} else {\r\n\t\t// ECParameters sequence\r\n\t\tder.startSequence();\r\n\r\n\t\tvar version = Buffer.from([1]);\r\n\t\tder.writeBuffer(version, asn1.Ber.Integer);\r\n\r\n\t\t// FieldID sequence\r\n\t\tder.startSequence();\r\n\t\tder.writeOID('1.2.840.10045.1.1'); // prime-field\r\n\t\tder.writeBuffer(curve.p, asn1.Ber.Integer);\r\n\t\tder.endSequence();\r\n\r\n\t\t// Curve sequence\r\n\t\tder.startSequence();\r\n\t\tvar a = curve.p;\r\n\t\tif (a[0] === 0x0)\r\n\t\t\ta = a.slice(1);\r\n\t\tder.writeBuffer(a, asn1.Ber.OctetString);\r\n\t\tder.writeBuffer(curve.b, asn1.Ber.OctetString);\r\n\t\tder.writeBuffer(curve.s, asn1.Ber.BitString);\r\n\t\tder.endSequence();\r\n\r\n\t\tder.writeBuffer(curve.G, asn1.Ber.OctetString);\r\n\t\tder.writeBuffer(curve.n, asn1.Ber.Integer);\r\n\t\tvar h = curve.h;\r\n\t\tif (!h) {\r\n\t\t\th = Buffer.from([1]);\r\n\t\t}\r\n\t\tder.writeBuffer(h, asn1.Ber.Integer);\r\n\r\n\t\t// ECParameters\r\n\t\tder.endSequence();\r\n\t}\r\n}\r\n\r\nfunction writePkcs8ECDSAPublic(key, der) {\r\n\twriteECDSACurve(key, der);\r\n\tder.endSequence();\r\n\r\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\r\n\tder.writeBuffer(Q, asn1.Ber.BitString);\r\n}\r\n\r\nfunction writePkcs8ECDSAPrivate(key, der) {\r\n\twriteECDSACurve(key, der);\r\n\tder.endSequence();\r\n\r\n\tder.startSequence(asn1.Ber.OctetString);\r\n\tder.startSequence();\r\n\r\n\tvar version = Buffer.from([1]);\r\n\tder.writeBuffer(version, asn1.Ber.Integer);\r\n\r\n\tder.writeBuffer(key.part.d.data, asn1.Ber.OctetString);\r\n\r\n\tder.startSequence(0xa1);\r\n\tvar Q = utils.ecNormalize(key.part.Q.data, true);\r\n\tder.writeBuffer(Q, asn1.Ber.BitString);\r\n\tder.endSequence();\r\n\r\n\tder.endSequence();\r\n\tder.endSequence();\r\n}\r\n\r\nfunction writePkcs8EdDSAPublic(key, der) {\r\n\tder.endSequence();\r\n\r\n\tutils.writeBitString(der, key.part.A.data);\r\n}\r\n\r\nfunction writePkcs8EdDSAPrivate(key, der) {\r\n\tder.endSequence();\r\n\r\n\tder.startSequence(asn1.Ber.OctetString);\r\n\tvar k = utils.mpNormalize(key.part.k.data);\r\n\t/* RFCs call for storing exactly 32 bytes, so strip any leading zeros */\r\n\twhile (k.length > 32 && k[0] === 0x00)\r\n\t\tk = k.slice(1);\r\n\tder.writeBuffer(k, asn1.Ber.OctetString);\r\n\tder.endSequence();\r\n\r\n\tutils.writeBitString(der, key.part.A.data, asn1.Ber.Context | 1);\r\n}\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\treadSSHPrivate: readSSHPrivate,\r\n\twrite: write\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar asn1 = require('asn1');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('../algs');\r\nvar utils = require('../utils');\r\nvar crypto = require('crypto');\r\n\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\nvar pem = require('./pem');\r\nvar rfc4253 = require('./rfc4253');\r\nvar SSHBuffer = require('../ssh-buffer');\r\nvar errors = require('../errors');\r\n\r\nvar bcrypt;\r\n\r\nfunction read(buf, options) {\r\n\treturn (pem.read(buf, options));\r\n}\r\n\r\nvar MAGIC = 'openssh-key-v1';\r\n\r\nfunction readSSHPrivate(type, buf, options) {\r\n\tbuf = new SSHBuffer({buffer: buf});\r\n\r\n\tvar magic = buf.readCString();\r\n\tassert.strictEqual(magic, MAGIC, 'bad magic string');\r\n\r\n\tvar cipher = buf.readString();\r\n\tvar kdf = buf.readString();\r\n\tvar kdfOpts = buf.readBuffer();\r\n\r\n\tvar nkeys = buf.readInt();\r\n\tif (nkeys !== 1) {\r\n\t\tthrow (new Error('OpenSSH-format key file contains ' +\r\n\t\t    'multiple keys: this is unsupported.'));\r\n\t}\r\n\r\n\tvar pubKey = buf.readBuffer();\r\n\r\n\tif (type === 'public') {\r\n\t\tassert.ok(buf.atEnd(), 'excess bytes left after key');\r\n\t\treturn (rfc4253.read(pubKey));\r\n\t}\r\n\r\n\tvar privKeyBlob = buf.readBuffer();\r\n\tassert.ok(buf.atEnd(), 'excess bytes left after key');\r\n\r\n\tvar kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });\r\n\tswitch (kdf) {\r\n\tcase 'none':\r\n\t\tif (cipher !== 'none') {\r\n\t\t\tthrow (new Error('OpenSSH-format key uses KDF \"none\" ' +\r\n\t\t\t     'but specifies a cipher other than \"none\"'));\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 'bcrypt':\r\n\t\tvar salt = kdfOptsBuf.readBuffer();\r\n\t\tvar rounds = kdfOptsBuf.readInt();\r\n\t\tvar cinf = utils.opensshCipherInfo(cipher);\r\n\t\tif (bcrypt === undefined) {\r\n\t\t\tbcrypt = require('bcrypt-pbkdf');\r\n\t\t}\r\n\r\n\t\tif (typeof (options.passphrase) === 'string') {\r\n\t\t\toptions.passphrase = Buffer.from(options.passphrase,\r\n\t\t\t    'utf-8');\r\n\t\t}\r\n\t\tif (!Buffer.isBuffer(options.passphrase)) {\r\n\t\t\tthrow (new errors.KeyEncryptedError(\r\n\t\t\t    options.filename, 'OpenSSH'));\r\n\t\t}\r\n\r\n\t\tvar pass = new Uint8Array(options.passphrase);\r\n\t\tvar salti = new Uint8Array(salt);\r\n\t\t/* Use the pbkdf to derive both the key and the IV. */\r\n\t\tvar out = new Uint8Array(cinf.keySize + cinf.blockSize);\r\n\t\tvar res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,\r\n\t\t    out, out.length, rounds);\r\n\t\tif (res !== 0) {\r\n\t\t\tthrow (new Error('bcrypt_pbkdf function returned ' +\r\n\t\t\t    'failure, parameters invalid'));\r\n\t\t}\r\n\t\tout = Buffer.from(out);\r\n\t\tvar ckey = out.slice(0, cinf.keySize);\r\n\t\tvar iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);\r\n\t\tvar cipherStream = crypto.createDecipheriv(cinf.opensslName,\r\n\t\t    ckey, iv);\r\n\t\tcipherStream.setAutoPadding(false);\r\n\t\tvar chunk, chunks = [];\r\n\t\tcipherStream.once('error', function (e) {\r\n\t\t\tif (e.toString().indexOf('bad decrypt') !== -1) {\r\n\t\t\t\tthrow (new Error('Incorrect passphrase ' +\r\n\t\t\t\t    'supplied, could not decrypt key'));\r\n\t\t\t}\r\n\t\t\tthrow (e);\r\n\t\t});\r\n\t\tcipherStream.write(privKeyBlob);\r\n\t\tcipherStream.end();\r\n\t\twhile ((chunk = cipherStream.read()) !== null)\r\n\t\t\tchunks.push(chunk);\r\n\t\tprivKeyBlob = Buffer.concat(chunks);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tthrow (new Error(\r\n\t\t    'OpenSSH-format key uses unknown KDF \"' + kdf + '\"'));\r\n\t}\r\n\r\n\tbuf = new SSHBuffer({buffer: privKeyBlob});\r\n\r\n\tvar checkInt1 = buf.readInt();\r\n\tvar checkInt2 = buf.readInt();\r\n\tif (checkInt1 !== checkInt2) {\r\n\t\tthrow (new Error('Incorrect passphrase supplied, could not ' +\r\n\t\t    'decrypt key'));\r\n\t}\r\n\r\n\tvar ret = {};\r\n\tvar key = rfc4253.readInternal(ret, 'private', buf.remainder());\r\n\r\n\tbuf.skip(ret.consumed);\r\n\r\n\tvar comment = buf.readString();\r\n\tkey.comment = comment;\r\n\r\n\treturn (key);\r\n}\r\n\r\nfunction write(key, options) {\r\n\tvar pubKey;\r\n\tif (PrivateKey.isPrivateKey(key))\r\n\t\tpubKey = key.toPublic();\r\n\telse\r\n\t\tpubKey = key;\r\n\r\n\tvar cipher = 'none';\r\n\tvar kdf = 'none';\r\n\tvar kdfopts = Buffer.alloc(0);\r\n\tvar cinf = { blockSize: 8 };\r\n\tvar passphrase;\r\n\tif (options !== undefined) {\r\n\t\tpassphrase = options.passphrase;\r\n\t\tif (typeof (passphrase) === 'string')\r\n\t\t\tpassphrase = Buffer.from(passphrase, 'utf-8');\r\n\t\tif (passphrase !== undefined) {\r\n\t\t\tassert.buffer(passphrase, 'options.passphrase');\r\n\t\t\tassert.optionalString(options.cipher, 'options.cipher');\r\n\t\t\tcipher = options.cipher;\r\n\t\t\tif (cipher === undefined)\r\n\t\t\t\tcipher = 'aes128-ctr';\r\n\t\t\tcinf = utils.opensshCipherInfo(cipher);\r\n\t\t\tkdf = 'bcrypt';\r\n\t\t}\r\n\t}\r\n\r\n\tvar privBuf;\r\n\tif (PrivateKey.isPrivateKey(key)) {\r\n\t\tprivBuf = new SSHBuffer({});\r\n\t\tvar checkInt = crypto.randomBytes(4).readUInt32BE(0);\r\n\t\tprivBuf.writeInt(checkInt);\r\n\t\tprivBuf.writeInt(checkInt);\r\n\t\tprivBuf.write(key.toBuffer('rfc4253'));\r\n\t\tprivBuf.writeString(key.comment || '');\r\n\r\n\t\tvar n = 1;\r\n\t\twhile (privBuf._offset % cinf.blockSize !== 0)\r\n\t\t\tprivBuf.writeChar(n++);\r\n\t\tprivBuf = privBuf.toBuffer();\r\n\t}\r\n\r\n\tswitch (kdf) {\r\n\tcase 'none':\r\n\t\tbreak;\r\n\tcase 'bcrypt':\r\n\t\tvar salt = crypto.randomBytes(16);\r\n\t\tvar rounds = 16;\r\n\t\tvar kdfssh = new SSHBuffer({});\r\n\t\tkdfssh.writeBuffer(salt);\r\n\t\tkdfssh.writeInt(rounds);\r\n\t\tkdfopts = kdfssh.toBuffer();\r\n\r\n\t\tif (bcrypt === undefined) {\r\n\t\t\tbcrypt = require('bcrypt-pbkdf');\r\n\t\t}\r\n\t\tvar pass = new Uint8Array(passphrase);\r\n\t\tvar salti = new Uint8Array(salt);\r\n\t\t/* Use the pbkdf to derive both the key and the IV. */\r\n\t\tvar out = new Uint8Array(cinf.keySize + cinf.blockSize);\r\n\t\tvar res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,\r\n\t\t    out, out.length, rounds);\r\n\t\tif (res !== 0) {\r\n\t\t\tthrow (new Error('bcrypt_pbkdf function returned ' +\r\n\t\t\t    'failure, parameters invalid'));\r\n\t\t}\r\n\t\tout = Buffer.from(out);\r\n\t\tvar ckey = out.slice(0, cinf.keySize);\r\n\t\tvar iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);\r\n\r\n\t\tvar cipherStream = crypto.createCipheriv(cinf.opensslName,\r\n\t\t    ckey, iv);\r\n\t\tcipherStream.setAutoPadding(false);\r\n\t\tvar chunk, chunks = [];\r\n\t\tcipherStream.once('error', function (e) {\r\n\t\t\tthrow (e);\r\n\t\t});\r\n\t\tcipherStream.write(privBuf);\r\n\t\tcipherStream.end();\r\n\t\twhile ((chunk = cipherStream.read()) !== null)\r\n\t\t\tchunks.push(chunk);\r\n\t\tprivBuf = Buffer.concat(chunks);\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tthrow (new Error('Unsupported kdf ' + kdf));\r\n\t}\r\n\r\n\tvar buf = new SSHBuffer({});\r\n\r\n\tbuf.writeCString(MAGIC);\r\n\tbuf.writeString(cipher);\t/* cipher */\r\n\tbuf.writeString(kdf);\t\t/* kdf */\r\n\tbuf.writeBuffer(kdfopts);\t/* kdfoptions */\r\n\r\n\tbuf.writeInt(1);\t\t/* nkeys */\r\n\tbuf.writeBuffer(pubKey.toBuffer('rfc4253'));\r\n\r\n\tif (privBuf)\r\n\t\tbuf.writeBuffer(privBuf);\r\n\r\n\tbuf = buf.toBuffer();\r\n\r\n\tvar header;\r\n\tif (PrivateKey.isPrivateKey(key))\r\n\t\theader = 'OPENSSH PRIVATE KEY';\r\n\telse\r\n\t\theader = 'OPENSSH PUBLIC KEY';\r\n\r\n\tvar tmp = buf.toString('base64');\r\n\tvar len = tmp.length + (tmp.length / 70) +\r\n\t    18 + 16 + header.length*2 + 10;\r\n\tbuf = Buffer.alloc(len);\r\n\tvar o = 0;\r\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\r\n\tfor (var i = 0; i < tmp.length; ) {\r\n\t\tvar limit = i + 70;\r\n\t\tif (limit > tmp.length)\r\n\t\t\tlimit = tmp.length;\r\n\t\to += buf.write(tmp.slice(i, limit), o);\r\n\t\tbuf[o++] = 10;\r\n\t\ti = limit;\r\n\t}\r\n\to += buf.write('-----END ' + header + '-----\\n', o);\r\n\r\n\treturn (buf.slice(0, o));\r\n}\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read.bind(undefined, false, undefined),\r\n\treadType: read.bind(undefined, false),\r\n\twrite: write,\r\n\t/* semi-private api, used by sshpk-agent */\r\n\treadPartial: read.bind(undefined, true),\r\n\r\n\t/* shared with ssh format */\r\n\treadInternal: read,\r\n\tkeyTypeToAlg: keyTypeToAlg,\r\n\talgToKeyType: algToKeyType\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('../algs');\r\nvar utils = require('../utils');\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\nvar SSHBuffer = require('../ssh-buffer');\r\n\r\nfunction algToKeyType(alg) {\r\n\tassert.string(alg);\r\n\tif (alg === 'ssh-dss')\r\n\t\treturn ('dsa');\r\n\telse if (alg === 'ssh-rsa')\r\n\t\treturn ('rsa');\r\n\telse if (alg === 'ssh-ed25519')\r\n\t\treturn ('ed25519');\r\n\telse if (alg === 'ssh-curve25519')\r\n\t\treturn ('curve25519');\r\n\telse if (alg.match(/^ecdsa-sha2-/))\r\n\t\treturn ('ecdsa');\r\n\telse\r\n\t\tthrow (new Error('Unknown algorithm ' + alg));\r\n}\r\n\r\nfunction keyTypeToAlg(key) {\r\n\tassert.object(key);\r\n\tif (key.type === 'dsa')\r\n\t\treturn ('ssh-dss');\r\n\telse if (key.type === 'rsa')\r\n\t\treturn ('ssh-rsa');\r\n\telse if (key.type === 'ed25519')\r\n\t\treturn ('ssh-ed25519');\r\n\telse if (key.type === 'curve25519')\r\n\t\treturn ('ssh-curve25519');\r\n\telse if (key.type === 'ecdsa')\r\n\t\treturn ('ecdsa-sha2-' + key.part.curve.data.toString());\r\n\telse\r\n\t\tthrow (new Error('Unknown key type ' + key.type));\r\n}\r\n\r\nfunction read(partial, type, buf, options) {\r\n\tif (typeof (buf) === 'string')\r\n\t\tbuf = Buffer.from(buf);\r\n\tassert.buffer(buf, 'buf');\r\n\r\n\tvar key = {};\r\n\r\n\tvar parts = key.parts = [];\r\n\tvar sshbuf = new SSHBuffer({buffer: buf});\r\n\r\n\tvar alg = sshbuf.readString();\r\n\tassert.ok(!sshbuf.atEnd(), 'key must have at least one part');\r\n\r\n\tkey.type = algToKeyType(alg);\r\n\r\n\tvar partCount = algs.info[key.type].parts.length;\r\n\tif (type && type === 'private')\r\n\t\tpartCount = algs.privInfo[key.type].parts.length;\r\n\r\n\twhile (!sshbuf.atEnd() && parts.length < partCount)\r\n\t\tparts.push(sshbuf.readPart());\r\n\twhile (!partial && !sshbuf.atEnd())\r\n\t\tparts.push(sshbuf.readPart());\r\n\r\n\tassert.ok(parts.length >= 1,\r\n\t    'key must have at least one part');\r\n\tassert.ok(partial || sshbuf.atEnd(),\r\n\t    'leftover bytes at end of key');\r\n\r\n\tvar Constructor = Key;\r\n\tvar algInfo = algs.info[key.type];\r\n\tif (type === 'private' || algInfo.parts.length !== parts.length) {\r\n\t\talgInfo = algs.privInfo[key.type];\r\n\t\tConstructor = PrivateKey;\r\n\t}\r\n\tassert.strictEqual(algInfo.parts.length, parts.length);\r\n\r\n\tif (key.type === 'ecdsa') {\r\n\t\tvar res = /^ecdsa-sha2-(.+)$/.exec(alg);\r\n\t\tassert.ok(res !== null);\r\n\t\tassert.strictEqual(res[1], parts[0].data.toString());\r\n\t}\r\n\r\n\tvar normalized = true;\r\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\r\n\t\tvar p = parts[i];\r\n\t\tp.name = algInfo.parts[i];\r\n\t\t/*\r\n\t\t * OpenSSH stores ed25519 \"private\" keys as seed + public key\r\n\t\t * concat'd together (k followed by A). We want to keep them\r\n\t\t * separate for other formats that don't do this.\r\n\t\t */\r\n\t\tif (key.type === 'ed25519' && p.name === 'k')\r\n\t\t\tp.data = p.data.slice(0, 32);\r\n\r\n\t\tif (p.name !== 'curve' && algInfo.normalize !== false) {\r\n\t\t\tvar nd;\r\n\t\t\tif (key.type === 'ed25519') {\r\n\t\t\t\tnd = utils.zeroPadToLength(p.data, 32);\r\n\t\t\t} else {\r\n\t\t\t\tnd = utils.mpNormalize(p.data);\r\n\t\t\t}\r\n\t\t\tif (nd.toString('binary') !==\r\n\t\t\t    p.data.toString('binary')) {\r\n\t\t\t\tp.data = nd;\r\n\t\t\t\tnormalized = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (normalized)\r\n\t\tkey._rfc4253Cache = sshbuf.toBuffer();\r\n\r\n\tif (partial && typeof (partial) === 'object') {\r\n\t\tpartial.remainder = sshbuf.remainder();\r\n\t\tpartial.consumed = sshbuf._offset;\r\n\t}\r\n\r\n\treturn (new Constructor(key));\r\n}\r\n\r\nfunction write(key, options) {\r\n\tassert.object(key);\r\n\r\n\tvar alg = keyTypeToAlg(key);\r\n\tvar i;\r\n\r\n\tvar algInfo = algs.info[key.type];\r\n\tif (PrivateKey.isPrivateKey(key))\r\n\t\talgInfo = algs.privInfo[key.type];\r\n\tvar parts = algInfo.parts;\r\n\r\n\tvar buf = new SSHBuffer({});\r\n\r\n\tbuf.writeString(alg);\r\n\r\n\tfor (i = 0; i < parts.length; ++i) {\r\n\t\tvar data = key.part[parts[i]].data;\r\n\t\tif (algInfo.normalize !== false) {\r\n\t\t\tif (key.type === 'ed25519')\r\n\t\t\t\tdata = utils.zeroPadToLength(data, 32);\r\n\t\t\telse\r\n\t\t\t\tdata = utils.mpNormalize(data);\r\n\t\t}\r\n\t\tif (key.type === 'ed25519' && parts[i] === 'k')\r\n\t\t\tdata = Buffer.concat([data, key.part.A.data]);\r\n\t\tbuf.writeBuffer(data);\r\n\t}\r\n\r\n\treturn (buf.toBuffer());\r\n}\r\n","// Copyright 2015 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\twrite: write\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar rfc4253 = require('./rfc4253');\r\nvar utils = require('../utils');\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\n\r\nvar sshpriv = require('./ssh-private');\r\n\r\n/*JSSTYLED*/\r\nvar SSHKEY_RE = /^([a-z0-9-]+)[ \\t]+([a-zA-Z0-9+\\/]+[=]*)([ \\t]+([^ \\t][^\\n]*[\\n]*)?)?$/;\r\n/*JSSTYLED*/\r\nvar SSHKEY_RE2 = /^([a-z0-9-]+)[ \\t\\n]+([a-zA-Z0-9+\\/][a-zA-Z0-9+\\/ \\t\\n=]*)([^a-zA-Z0-9+\\/ \\t\\n=].*)?$/;\r\n\r\nfunction read(buf, options) {\r\n\tif (typeof (buf) !== 'string') {\r\n\t\tassert.buffer(buf, 'buf');\r\n\t\tbuf = buf.toString('ascii');\r\n\t}\r\n\r\n\tvar trimmed = buf.trim().replace(/[\\\\\\r]/g, '');\r\n\tvar m = trimmed.match(SSHKEY_RE);\r\n\tif (!m)\r\n\t\tm = trimmed.match(SSHKEY_RE2);\r\n\tassert.ok(m, 'key must match regex');\r\n\r\n\tvar type = rfc4253.algToKeyType(m[1]);\r\n\tvar kbuf = Buffer.from(m[2], 'base64');\r\n\r\n\t/*\r\n\t * This is a bit tricky. If we managed to parse the key and locate the\r\n\t * key comment with the regex, then do a non-partial read and assert\r\n\t * that we have consumed all bytes. If we couldn't locate the key\r\n\t * comment, though, there may be whitespace shenanigans going on that\r\n\t * have conjoined the comment to the rest of the key. We do a partial\r\n\t * read in this case to try to make the best out of a sorry situation.\r\n\t */\r\n\tvar key;\r\n\tvar ret = {};\r\n\tif (m[4]) {\r\n\t\ttry {\r\n\t\t\tkey = rfc4253.read(kbuf);\r\n\r\n\t\t} catch (e) {\r\n\t\t\tm = trimmed.match(SSHKEY_RE2);\r\n\t\t\tassert.ok(m, 'key must match regex');\r\n\t\t\tkbuf = Buffer.from(m[2], 'base64');\r\n\t\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\r\n\t\t}\r\n\t} else {\r\n\t\tkey = rfc4253.readInternal(ret, 'public', kbuf);\r\n\t}\r\n\r\n\tassert.strictEqual(type, key.type);\r\n\r\n\tif (m[4] && m[4].length > 0) {\r\n\t\tkey.comment = m[4];\r\n\r\n\t} else if (ret.consumed) {\r\n\t\t/*\r\n\t\t * Now the magic: trying to recover the key comment when it's\r\n\t\t * gotten conjoined to the key or otherwise shenanigan'd.\r\n\t\t *\r\n\t\t * Work out how much base64 we used, then drop all non-base64\r\n\t\t * chars from the beginning up to this point in the the string.\r\n\t\t * Then offset in this and try to make up for missing = chars.\r\n\t\t */\r\n\t\tvar data = m[2] + (m[3] ? m[3] : '');\r\n\t\tvar realOffset = Math.ceil(ret.consumed / 3) * 4;\r\n\t\tdata = data.slice(0, realOffset - 2). /*JSSTYLED*/\r\n\t\t    replace(/[^a-zA-Z0-9+\\/=]/g, '') +\r\n\t\t    data.slice(realOffset - 2);\r\n\r\n\t\tvar padding = ret.consumed % 3;\r\n\t\tif (padding > 0 &&\r\n\t\t    data.slice(realOffset - 1, realOffset) !== '=')\r\n\t\t\trealOffset--;\r\n\t\twhile (data.slice(realOffset, realOffset + 1) === '=')\r\n\t\t\trealOffset++;\r\n\r\n\t\t/* Finally, grab what we think is the comment & clean it up. */\r\n\t\tvar trailer = data.slice(realOffset);\r\n\t\ttrailer = trailer.replace(/[\\r\\n]/g, ' ').\r\n\t\t    replace(/^\\s+/, '');\r\n\t\tif (trailer.match(/^[a-zA-Z0-9]/))\r\n\t\t\tkey.comment = trailer;\r\n\t}\r\n\r\n\treturn (key);\r\n}\r\n\r\nfunction write(key, options) {\r\n\tassert.object(key);\r\n\tif (!Key.isKey(key))\r\n\t\tthrow (new Error('Must be a public key'));\r\n\r\n\tvar parts = [];\r\n\tvar alg = rfc4253.keyTypeToAlg(key);\r\n\tparts.push(alg);\r\n\r\n\tvar buf = rfc4253.write(key);\r\n\tparts.push(buf.toString('base64'));\r\n\r\n\tif (key.comment)\r\n\t\tparts.push(key.comment);\r\n\r\n\treturn (Buffer.from(parts.join(' ')));\r\n}\r\n","// Copyright 2017 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\twrite: write\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\nvar utils = require('../utils');\r\nvar SSHBuffer = require('../ssh-buffer');\r\nvar Dhe = require('../dhe');\r\n\r\nvar supportedAlgos = {\r\n\t'rsa-sha1' : 5,\r\n\t'rsa-sha256' : 8,\r\n\t'rsa-sha512' : 10,\r\n\t'ecdsa-p256-sha256' : 13,\r\n\t'ecdsa-p384-sha384' : 14\r\n\t/*\r\n\t * ed25519 is hypothetically supported with id 15\r\n\t * but the common tools available don't appear to be\r\n\t * capable of generating/using ed25519 keys\r\n\t */\r\n};\r\n\r\nvar supportedAlgosById = {};\r\nObject.keys(supportedAlgos).forEach(function (k) {\r\n\tsupportedAlgosById[supportedAlgos[k]] = k.toUpperCase();\r\n});\r\n\r\nfunction read(buf, options) {\r\n\tif (typeof (buf) !== 'string') {\r\n\t\tassert.buffer(buf, 'buf');\r\n\t\tbuf = buf.toString('ascii');\r\n\t}\r\n\tvar lines = buf.split('\\n');\r\n\tif (lines[0].match(/^Private-key-format\\: v1/)) {\r\n\t\tvar algElems = lines[1].split(' ');\r\n\t\tvar algoNum = parseInt(algElems[1], 10);\r\n\t\tvar algoName = algElems[2];\r\n\t\tif (!supportedAlgosById[algoNum])\r\n\t\t\tthrow (new Error('Unsupported algorithm: ' + algoName));\r\n\t\treturn (readDNSSECPrivateKey(algoNum, lines.slice(2)));\r\n\t}\r\n\r\n\t// skip any comment-lines\r\n\tvar line = 0;\r\n\t/* JSSTYLED */\r\n\twhile (lines[line].match(/^\\;/))\r\n\t\tline++;\r\n\t// we should now have *one single* line left with our KEY on it.\r\n\tif ((lines[line].match(/\\. IN KEY /) ||\r\n\t    lines[line].match(/\\. IN DNSKEY /)) && lines[line+1].length === 0) {\r\n\t\treturn (readRFC3110(lines[line]));\r\n\t}\r\n\tthrow (new Error('Cannot parse dnssec key'));\r\n}\r\n\r\nfunction readRFC3110(keyString) {\r\n\tvar elems = keyString.split(' ');\r\n\t//unused var flags = parseInt(elems[3], 10);\r\n\t//unused var protocol = parseInt(elems[4], 10);\r\n\tvar algorithm = parseInt(elems[5], 10);\r\n\tif (!supportedAlgosById[algorithm])\r\n\t\tthrow (new Error('Unsupported algorithm: ' + algorithm));\r\n\tvar base64key = elems.slice(6, elems.length).join();\r\n\tvar keyBuffer = Buffer.from(base64key, 'base64');\r\n\tif (supportedAlgosById[algorithm].match(/^RSA-/)) {\r\n\t\t// join the rest of the body into a single base64-blob\r\n\t\tvar publicExponentLen = keyBuffer.readUInt8(0);\r\n\t\tif (publicExponentLen != 3 && publicExponentLen != 1)\r\n\t\t\tthrow (new Error('Cannot parse dnssec key: ' +\r\n\t\t\t    'unsupported exponent length'));\r\n\r\n\t\tvar publicExponent = keyBuffer.slice(1, publicExponentLen+1);\r\n\t\tpublicExponent = utils.mpNormalize(publicExponent);\r\n\t\tvar modulus = keyBuffer.slice(1+publicExponentLen);\r\n\t\tmodulus = utils.mpNormalize(modulus);\r\n\t\t// now, make the key\r\n\t\tvar rsaKey = {\r\n\t\t\ttype: 'rsa',\r\n\t\t\tparts: []\r\n\t\t};\r\n\t\trsaKey.parts.push({ name: 'e', data: publicExponent});\r\n\t\trsaKey.parts.push({ name: 'n', data: modulus});\r\n\t\treturn (new Key(rsaKey));\r\n\t}\r\n\tif (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||\r\n\t    supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {\r\n\t\tvar curve = 'nistp384';\r\n\t\tvar size = 384;\r\n\t\tif (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {\r\n\t\t\tcurve = 'nistp256';\r\n\t\t\tsize = 256;\r\n\t\t}\r\n\r\n\t\tvar ecdsaKey = {\r\n\t\t\ttype: 'ecdsa',\r\n\t\t\tcurve: curve,\r\n\t\t\tsize: size,\r\n\t\t\tparts: [\r\n\t\t\t\t{name: 'curve', data: Buffer.from(curve) },\r\n\t\t\t\t{name: 'Q', data: utils.ecNormalize(keyBuffer) }\r\n\t\t\t]\r\n\t\t};\r\n\t\treturn (new Key(ecdsaKey));\r\n\t}\r\n\tthrow (new Error('Unsupported algorithm: ' +\r\n\t    supportedAlgosById[algorithm]));\r\n}\r\n\r\nfunction elementToBuf(e) {\r\n\treturn (Buffer.from(e.split(' ')[1], 'base64'));\r\n}\r\n\r\nfunction readDNSSECRSAPrivateKey(elements) {\r\n\tvar rsaParams = {};\r\n\telements.forEach(function (element) {\r\n\t\tif (element.split(' ')[0] === 'Modulus:')\r\n\t\t\trsaParams['n'] = elementToBuf(element);\r\n\t\telse if (element.split(' ')[0] === 'PublicExponent:')\r\n\t\t\trsaParams['e'] = elementToBuf(element);\r\n\t\telse if (element.split(' ')[0] === 'PrivateExponent:')\r\n\t\t\trsaParams['d'] = elementToBuf(element);\r\n\t\telse if (element.split(' ')[0] === 'Prime1:')\r\n\t\t\trsaParams['p'] = elementToBuf(element);\r\n\t\telse if (element.split(' ')[0] === 'Prime2:')\r\n\t\t\trsaParams['q'] = elementToBuf(element);\r\n\t\telse if (element.split(' ')[0] === 'Exponent1:')\r\n\t\t\trsaParams['dmodp'] = elementToBuf(element);\r\n\t\telse if (element.split(' ')[0] === 'Exponent2:')\r\n\t\t\trsaParams['dmodq'] = elementToBuf(element);\r\n\t\telse if (element.split(' ')[0] === 'Coefficient:')\r\n\t\t\trsaParams['iqmp'] = elementToBuf(element);\r\n\t});\r\n\t// now, make the key\r\n\tvar key = {\r\n\t\ttype: 'rsa',\r\n\t\tparts: [\r\n\t\t\t{ name: 'e', data: utils.mpNormalize(rsaParams['e'])},\r\n\t\t\t{ name: 'n', data: utils.mpNormalize(rsaParams['n'])},\r\n\t\t\t{ name: 'd', data: utils.mpNormalize(rsaParams['d'])},\r\n\t\t\t{ name: 'p', data: utils.mpNormalize(rsaParams['p'])},\r\n\t\t\t{ name: 'q', data: utils.mpNormalize(rsaParams['q'])},\r\n\t\t\t{ name: 'dmodp',\r\n\t\t\t    data: utils.mpNormalize(rsaParams['dmodp'])},\r\n\t\t\t{ name: 'dmodq',\r\n\t\t\t    data: utils.mpNormalize(rsaParams['dmodq'])},\r\n\t\t\t{ name: 'iqmp',\r\n\t\t\t    data: utils.mpNormalize(rsaParams['iqmp'])}\r\n\t\t]\r\n\t};\r\n\treturn (new PrivateKey(key));\r\n}\r\n\r\nfunction readDNSSECPrivateKey(alg, elements) {\r\n\tif (supportedAlgosById[alg].match(/^RSA-/)) {\r\n\t\treturn (readDNSSECRSAPrivateKey(elements));\r\n\t}\r\n\tif (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||\r\n\t    supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\r\n\t\tvar d = Buffer.from(elements[0].split(' ')[1], 'base64');\r\n\t\tvar curve = 'nistp384';\r\n\t\tvar size = 384;\r\n\t\tif (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {\r\n\t\t\tcurve = 'nistp256';\r\n\t\t\tsize = 256;\r\n\t\t}\r\n\t\t// DNSSEC generates the public-key on the fly (go calculate it)\r\n\t\tvar publicKey = utils.publicFromPrivateECDSA(curve, d);\r\n\t\tvar Q = publicKey.part['Q'].data;\r\n\t\tvar ecdsaKey = {\r\n\t\t\ttype: 'ecdsa',\r\n\t\t\tcurve: curve,\r\n\t\t\tsize: size,\r\n\t\t\tparts: [\r\n\t\t\t\t{name: 'curve', data: Buffer.from(curve) },\r\n\t\t\t\t{name: 'd', data: d },\r\n\t\t\t\t{name: 'Q', data: Q }\r\n\t\t\t]\r\n\t\t};\r\n\t\treturn (new PrivateKey(ecdsaKey));\r\n\t}\r\n\tthrow (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));\r\n}\r\n\r\nfunction dnssecTimestamp(date) {\r\n\tvar year = date.getFullYear() + ''; //stringify\r\n\tvar month = (date.getMonth() + 1);\r\n\tvar timestampStr = year + month + date.getUTCDate();\r\n\ttimestampStr += '' + date.getUTCHours() + date.getUTCMinutes();\r\n\ttimestampStr += date.getUTCSeconds();\r\n\treturn (timestampStr);\r\n}\r\n\r\nfunction rsaAlgFromOptions(opts) {\r\n\tif (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')\r\n\t\treturn ('5 (RSASHA1)');\r\n\telse if (opts.hashAlgo === 'sha256')\r\n\t\treturn ('8 (RSASHA256)');\r\n\telse if (opts.hashAlgo === 'sha512')\r\n\t\treturn ('10 (RSASHA512)');\r\n\telse\r\n\t\tthrow (new Error('Unknown or unsupported hash: ' +\r\n\t\t    opts.hashAlgo));\r\n}\r\n\r\nfunction writeRSA(key, options) {\r\n\t// if we're missing parts, add them.\r\n\tif (!key.part.dmodp || !key.part.dmodq) {\r\n\t\tutils.addRSAMissing(key);\r\n\t}\r\n\r\n\tvar out = '';\r\n\tout += 'Private-key-format: v1.3\\n';\r\n\tout += 'Algorithm: ' + rsaAlgFromOptions(options) + '\\n';\r\n\tvar n = utils.mpDenormalize(key.part['n'].data);\r\n\tout += 'Modulus: ' + n.toString('base64') + '\\n';\r\n\tvar e = utils.mpDenormalize(key.part['e'].data);\r\n\tout += 'PublicExponent: ' + e.toString('base64') + '\\n';\r\n\tvar d = utils.mpDenormalize(key.part['d'].data);\r\n\tout += 'PrivateExponent: ' + d.toString('base64') + '\\n';\r\n\tvar p = utils.mpDenormalize(key.part['p'].data);\r\n\tout += 'Prime1: ' + p.toString('base64') + '\\n';\r\n\tvar q = utils.mpDenormalize(key.part['q'].data);\r\n\tout += 'Prime2: ' + q.toString('base64') + '\\n';\r\n\tvar dmodp = utils.mpDenormalize(key.part['dmodp'].data);\r\n\tout += 'Exponent1: ' + dmodp.toString('base64') + '\\n';\r\n\tvar dmodq = utils.mpDenormalize(key.part['dmodq'].data);\r\n\tout += 'Exponent2: ' + dmodq.toString('base64') + '\\n';\r\n\tvar iqmp = utils.mpDenormalize(key.part['iqmp'].data);\r\n\tout += 'Coefficient: ' + iqmp.toString('base64') + '\\n';\r\n\t// Assume that we're valid as-of now\r\n\tvar timestamp = new Date();\r\n\tout += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\r\n\tout += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\r\n\tout += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\r\n\treturn (Buffer.from(out, 'ascii'));\r\n}\r\n\r\nfunction writeECDSA(key, options) {\r\n\tvar out = '';\r\n\tout += 'Private-key-format: v1.3\\n';\r\n\r\n\tif (key.curve === 'nistp256') {\r\n\t\tout += 'Algorithm: 13 (ECDSAP256SHA256)\\n';\r\n\t} else if (key.curve === 'nistp384') {\r\n\t\tout += 'Algorithm: 14 (ECDSAP384SHA384)\\n';\r\n\t} else {\r\n\t\tthrow (new Error('Unsupported curve'));\r\n\t}\r\n\tvar base64Key = key.part['d'].data.toString('base64');\r\n\tout += 'PrivateKey: ' + base64Key + '\\n';\r\n\r\n\t// Assume that we're valid as-of now\r\n\tvar timestamp = new Date();\r\n\tout += 'Created: ' + dnssecTimestamp(timestamp) + '\\n';\r\n\tout += 'Publish: ' + dnssecTimestamp(timestamp) + '\\n';\r\n\tout += 'Activate: ' + dnssecTimestamp(timestamp) + '\\n';\r\n\r\n\treturn (Buffer.from(out, 'ascii'));\r\n}\r\n\r\nfunction write(key, options) {\r\n\tif (PrivateKey.isPrivateKey(key)) {\r\n\t\tif (key.type === 'rsa') {\r\n\t\t\treturn (writeRSA(key, options));\r\n\t\t} else if (key.type === 'ecdsa') {\r\n\t\t\treturn (writeECDSA(key, options));\r\n\t\t} else {\r\n\t\t\tthrow (new Error('Unsupported algorithm: ' + key.type));\r\n\t\t}\r\n\t} else if (Key.isKey(key)) {\r\n\t\t/*\r\n\t\t * RFC3110 requires a keyname, and a keytype, which we\r\n\t\t * don't really have a mechanism for specifying such\r\n\t\t * additional metadata.\r\n\t\t */\r\n\t\tthrow (new Error('Format \"dnssec\" only supports ' +\r\n\t\t    'writing private keys'));\r\n\t} else {\r\n\t\tthrow (new Error('key is not a Key or PrivateKey'));\r\n\t}\r\n}\r\n","// Copyright 2018 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\twrite: write\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar rfc4253 = require('./rfc4253');\r\nvar Key = require('../key');\r\nvar SSHBuffer = require('../ssh-buffer');\r\nvar crypto = require('crypto');\r\nvar PrivateKey = require('../private-key');\r\n\r\nvar errors = require('../errors');\r\n\r\n// https://tartarus.org/~simon/putty-prerel-snapshots/htmldoc/AppendixC.html\r\nfunction read(buf, options) {\r\n\tvar lines = buf.toString('ascii').split(/[\\r\\n]+/);\r\n\tvar found = false;\r\n\tvar parts;\r\n\tvar si = 0;\r\n\tvar formatVersion;\r\n\twhile (si < lines.length) {\r\n\t\tparts = splitHeader(lines[si++]);\r\n\t\tif (parts) {\r\n\t\t\tformatVersion = {\r\n\t\t\t\t'putty-user-key-file-2': 2,\r\n\t\t\t\t'putty-user-key-file-3': 3\r\n\t\t\t}[parts[0].toLowerCase()];\r\n\t\t\tif (formatVersion) {\r\n\t\t\t\tfound = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (!found) {\r\n\t\tthrow (new Error('No PuTTY format first line found'));\r\n\t}\r\n\tvar alg = parts[1];\r\n\r\n\tparts = splitHeader(lines[si++]);\r\n\tassert.equal(parts[0].toLowerCase(), 'encryption');\r\n\tvar encryption = parts[1];\r\n\r\n\tparts = splitHeader(lines[si++]);\r\n\tassert.equal(parts[0].toLowerCase(), 'comment');\r\n\tvar comment = parts[1];\r\n\r\n\tparts = splitHeader(lines[si++]);\r\n\tassert.equal(parts[0].toLowerCase(), 'public-lines');\r\n\tvar publicLines = parseInt(parts[1], 10);\r\n\tif (!isFinite(publicLines) || publicLines < 0 ||\r\n\t    publicLines > lines.length) {\r\n\t\tthrow (new Error('Invalid public-lines count'));\r\n\t}\r\n\r\n\tvar publicBuf = Buffer.from(\r\n\t    lines.slice(si, si + publicLines).join(''), 'base64');\r\n\tvar keyType = rfc4253.algToKeyType(alg);\r\n\tvar key = rfc4253.read(publicBuf);\r\n\tif (key.type !== keyType) {\r\n\t\tthrow (new Error('Outer key algorithm mismatch'));\r\n\t}\r\n\r\n\tsi += publicLines;\r\n\tif (lines[si]) {\r\n\t\tparts = splitHeader(lines[si++]);\r\n\t\tassert.equal(parts[0].toLowerCase(), 'private-lines');\r\n\t\tvar privateLines = parseInt(parts[1], 10);\r\n\t\tif (!isFinite(privateLines) || privateLines < 0 ||\r\n\t\t    privateLines > lines.length) {\r\n\t\t\tthrow (new Error('Invalid private-lines count'));\r\n\t\t}\r\n\r\n\t\tvar privateBuf = Buffer.from(\r\n\t\t\tlines.slice(si, si + privateLines).join(''), 'base64');\r\n\r\n\t\tif (encryption !== 'none' && formatVersion === 3) {\r\n\t\t\tthrow new Error('Encrypted keys arenot supported for' +\r\n\t\t\t' PuTTY format version 3');\r\n\t\t}\r\n\r\n\t\tif (encryption === 'aes256-cbc') {\r\n\t\t\tif (!options.passphrase) {\r\n\t\t\t\tthrow (new errors.KeyEncryptedError(\r\n\t\t\t\t\toptions.filename, 'PEM'));\r\n\t\t\t}\r\n\r\n\t\t\tvar iv = Buffer.alloc(16, 0);\r\n\t\t\tvar decipher = crypto.createDecipheriv(\r\n\t\t\t\t'aes-256-cbc',\r\n\t\t\t\tderivePPK2EncryptionKey(options.passphrase),\r\n\t\t\t\tiv);\r\n\t\t\tdecipher.setAutoPadding(false);\r\n\t\t\tprivateBuf = Buffer.concat([\r\n\t\t\t\tdecipher.update(privateBuf), decipher.final()]);\r\n\t\t}\r\n\r\n\t\tkey = new PrivateKey(key);\r\n\t\tif (key.type !== keyType) {\r\n\t\t\tthrow (new Error('Outer key algorithm mismatch'));\r\n\t\t}\r\n\r\n\t\tvar sshbuf = new SSHBuffer({buffer: privateBuf});\r\n\t\tvar privateKeyParts;\r\n\t\tif (alg === 'ssh-dss') {\r\n\t\t\tprivateKeyParts = [ {\r\n\t\t\t\tname: 'x',\r\n\t\t\t\tdata: sshbuf.readBuffer()\r\n\t\t\t}];\r\n\t\t} else if (alg === 'ssh-rsa') {\r\n\t\t\tprivateKeyParts = [\r\n\t\t\t\t{ name: 'd', data: sshbuf.readBuffer() },\r\n\t\t\t\t{ name: 'p', data: sshbuf.readBuffer() },\r\n\t\t\t\t{ name: 'q', data: sshbuf.readBuffer() },\r\n\t\t\t\t{ name: 'iqmp', data: sshbuf.readBuffer() }\r\n\t\t\t];\r\n\t\t} else if (alg.match(/^ecdsa-sha2-nistp/)) {\r\n\t\t\tprivateKeyParts = [ {\r\n\t\t\t\tname: 'd', data: sshbuf.readBuffer()\r\n\t\t\t} ];\r\n\t\t} else if (alg === 'ssh-ed25519') {\r\n\t\t\tprivateKeyParts = [ {\r\n\t\t\t\tname: 'k', data: sshbuf.readBuffer()\r\n\t\t\t} ];\r\n\t\t} else {\r\n\t\t\tthrow new Error('Unsupported PPK key type: ' + alg);\r\n\t\t}\r\n\r\n\t\tkey = new PrivateKey({\r\n\t\t\ttype: key.type,\r\n\t\t\tparts: key.parts.concat(privateKeyParts)\r\n\t\t});\r\n\t}\r\n\r\n\tkey.comment = comment;\r\n\treturn (key);\r\n}\r\n\r\nfunction derivePPK2EncryptionKey(passphrase) {\r\n\tvar hash1 = crypto.createHash('sha1').update(Buffer.concat([\r\n\t\tBuffer.from([0, 0, 0, 0]),\r\n\t\tBuffer.from(passphrase)\r\n\t])).digest();\r\n\tvar hash2 = crypto.createHash('sha1').update(Buffer.concat([\r\n\t\tBuffer.from([0, 0, 0, 1]),\r\n\t\tBuffer.from(passphrase)\r\n\t])).digest();\r\n\treturn (Buffer.concat([hash1, hash2]).slice(0, 32));\r\n}\r\n\r\nfunction splitHeader(line) {\r\n\tvar idx = line.indexOf(':');\r\n\tif (idx === -1)\r\n\t\treturn (null);\r\n\tvar header = line.slice(0, idx);\r\n\t++idx;\r\n\twhile (line[idx] === ' ')\r\n\t\t++idx;\r\n\tvar rest = line.slice(idx);\r\n\treturn ([header, rest]);\r\n}\r\n\r\nfunction write(key, options) {\r\n\tassert.object(key);\r\n\tif (!Key.isKey(key))\r\n\t\tthrow (new Error('Must be a public key'));\r\n\r\n\tvar alg = rfc4253.keyTypeToAlg(key);\r\n\tvar buf = rfc4253.write(key);\r\n\tvar comment = key.comment || '';\r\n\r\n\tvar b64 = buf.toString('base64');\r\n\tvar lines = wrap(b64, 64);\r\n\r\n\tlines.unshift('Public-Lines: ' + lines.length);\r\n\tlines.unshift('Comment: ' + comment);\r\n\tlines.unshift('Encryption: none');\r\n\tlines.unshift('PuTTY-User-Key-File-2: ' + alg);\r\n\r\n\treturn (Buffer.from(lines.join('\\n') + '\\n'));\r\n}\r\n\r\nfunction wrap(txt, len) {\r\n\tvar lines = [];\r\n\tvar pos = 0;\r\n\twhile (pos < txt.length) {\r\n\t\tlines.push(txt.slice(pos, pos + 64));\r\n\t\tpos += 64;\r\n\t}\r\n\treturn (lines);\r\n}\r\n","// Copyright 2016 Joyent, Inc.\r\n\r\nmodule.exports = Certificate;\r\n\r\nvar assert = require('assert-plus');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('./algs');\r\nvar crypto = require('crypto');\r\nvar Fingerprint = require('./fingerprint');\r\nvar Signature = require('./signature');\r\nvar errs = require('./errors');\r\nvar util = require('util');\r\nvar utils = require('./utils');\r\nvar Key = require('./key');\r\nvar PrivateKey = require('./private-key');\r\nvar Identity = require('./identity');\r\n\r\nvar formats = {};\r\nformats['openssh'] = require('./formats/openssh-cert');\r\nformats['x509'] = require('./formats/x509');\r\nformats['pem'] = require('./formats/x509-pem');\r\n\r\nvar CertificateParseError = errs.CertificateParseError;\r\nvar InvalidAlgorithmError = errs.InvalidAlgorithmError;\r\n\r\nfunction Certificate(opts) {\r\n\tassert.object(opts, 'options');\r\n\tassert.arrayOfObject(opts.subjects, 'options.subjects');\r\n\tutils.assertCompatible(opts.subjects[0], Identity, [1, 0],\r\n\t    'options.subjects');\r\n\tutils.assertCompatible(opts.subjectKey, Key, [1, 0],\r\n\t    'options.subjectKey');\r\n\tutils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');\r\n\tif (opts.issuerKey !== undefined) {\r\n\t\tutils.assertCompatible(opts.issuerKey, Key, [1, 0],\r\n\t\t    'options.issuerKey');\r\n\t}\r\n\tassert.object(opts.signatures, 'options.signatures');\r\n\tassert.buffer(opts.serial, 'options.serial');\r\n\tassert.date(opts.validFrom, 'options.validFrom');\r\n\tassert.date(opts.validUntil, 'optons.validUntil');\r\n\r\n\tassert.optionalArrayOfString(opts.purposes, 'options.purposes');\r\n\r\n\tthis._hashCache = {};\r\n\r\n\tthis.subjects = opts.subjects;\r\n\tthis.issuer = opts.issuer;\r\n\tthis.subjectKey = opts.subjectKey;\r\n\tthis.issuerKey = opts.issuerKey;\r\n\tthis.signatures = opts.signatures;\r\n\tthis.serial = opts.serial;\r\n\tthis.validFrom = opts.validFrom;\r\n\tthis.validUntil = opts.validUntil;\r\n\tthis.purposes = opts.purposes;\r\n}\r\n\r\nCertificate.formats = formats;\r\n\r\nCertificate.prototype.toBuffer = function (format, options) {\r\n\tif (format === undefined)\r\n\t\tformat = 'x509';\r\n\tassert.string(format, 'format');\r\n\tassert.object(formats[format], 'formats[format]');\r\n\tassert.optionalObject(options, 'options');\r\n\r\n\treturn (formats[format].write(this, options));\r\n};\r\n\r\nCertificate.prototype.toString = function (format, options) {\r\n\tif (format === undefined)\r\n\t\tformat = 'pem';\r\n\treturn (this.toBuffer(format, options).toString());\r\n};\r\n\r\nCertificate.prototype.fingerprint = function (algo) {\r\n\tif (algo === undefined)\r\n\t\talgo = 'sha256';\r\n\tassert.string(algo, 'algorithm');\r\n\tvar opts = {\r\n\t\ttype: 'certificate',\r\n\t\thash: this.hash(algo),\r\n\t\talgorithm: algo\r\n\t};\r\n\treturn (new Fingerprint(opts));\r\n};\r\n\r\nCertificate.prototype.hash = function (algo) {\r\n\tassert.string(algo, 'algorithm');\r\n\talgo = algo.toLowerCase();\r\n\tif (algs.hashAlgs[algo] === undefined)\r\n\t\tthrow (new InvalidAlgorithmError(algo));\r\n\r\n\tif (this._hashCache[algo])\r\n\t\treturn (this._hashCache[algo]);\r\n\r\n\tvar hash = crypto.createHash(algo).\r\n\t    update(this.toBuffer('x509')).digest();\r\n\tthis._hashCache[algo] = hash;\r\n\treturn (hash);\r\n};\r\n\r\nCertificate.prototype.isExpired = function (when) {\r\n\tif (when === undefined)\r\n\t\twhen = new Date();\r\n\treturn (!((when.getTime() >= this.validFrom.getTime()) &&\r\n\t\t(when.getTime() < this.validUntil.getTime())));\r\n};\r\n\r\nCertificate.prototype.isSignedBy = function (issuerCert) {\r\n\tutils.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');\r\n\r\n\tif (!this.issuer.equals(issuerCert.subjects[0]))\r\n\t\treturn (false);\r\n\tif (this.issuer.purposes && this.issuer.purposes.length > 0 &&\r\n\t    this.issuer.purposes.indexOf('ca') === -1) {\r\n\t\treturn (false);\r\n\t}\r\n\r\n\treturn (this.isSignedByKey(issuerCert.subjectKey));\r\n};\r\n\r\nCertificate.prototype.getExtension = function (keyOrOid) {\r\n\tassert.string(keyOrOid, 'keyOrOid');\r\n\tvar ext = this.getExtensions().filter(function (maybeExt) {\r\n\t\tif (maybeExt.format === 'x509')\r\n\t\t\treturn (maybeExt.oid === keyOrOid);\r\n\t\tif (maybeExt.format === 'openssh')\r\n\t\t\treturn (maybeExt.name === keyOrOid);\r\n\t\treturn (false);\r\n\t})[0];\r\n\treturn (ext);\r\n};\r\n\r\nCertificate.prototype.getExtensions = function () {\r\n\tvar exts = [];\r\n\tvar x509 = this.signatures.x509;\r\n\tif (x509 && x509.extras && x509.extras.exts) {\r\n\t\tx509.extras.exts.forEach(function (ext) {\r\n\t\t\text.format = 'x509';\r\n\t\t\texts.push(ext);\r\n\t\t});\r\n\t}\r\n\tvar openssh = this.signatures.openssh;\r\n\tif (openssh && openssh.exts) {\r\n\t\topenssh.exts.forEach(function (ext) {\r\n\t\t\text.format = 'openssh';\r\n\t\t\texts.push(ext);\r\n\t\t});\r\n\t}\r\n\treturn (exts);\r\n};\r\n\r\nCertificate.prototype.isSignedByKey = function (issuerKey) {\r\n\tutils.assertCompatible(issuerKey, Key, [1, 2], 'issuerKey');\r\n\r\n\tif (this.issuerKey !== undefined) {\r\n\t\treturn (this.issuerKey.\r\n\t\t    fingerprint('sha512').matches(issuerKey));\r\n\t}\r\n\r\n\tvar fmt = Object.keys(this.signatures)[0];\r\n\tvar valid = formats[fmt].verify(this, issuerKey);\r\n\tif (valid)\r\n\t\tthis.issuerKey = issuerKey;\r\n\treturn (valid);\r\n};\r\n\r\nCertificate.prototype.signWith = function (key) {\r\n\tutils.assertCompatible(key, PrivateKey, [1, 2], 'key');\r\n\tvar fmts = Object.keys(formats);\r\n\tvar didOne = false;\r\n\tfor (var i = 0; i < fmts.length; ++i) {\r\n\t\tif (fmts[i] !== 'pem') {\r\n\t\t\tvar ret = formats[fmts[i]].sign(this, key);\r\n\t\t\tif (ret === true)\r\n\t\t\t\tdidOne = true;\r\n\t\t}\r\n\t}\r\n\tif (!didOne) {\r\n\t\tthrow (new Error('Failed to sign the certificate for any ' +\r\n\t\t    'available certificate formats'));\r\n\t}\r\n};\r\n\r\nCertificate.createSelfSigned = function (subjectOrSubjects, key, options) {\r\n\tvar subjects;\r\n\tif (Array.isArray(subjectOrSubjects))\r\n\t\tsubjects = subjectOrSubjects;\r\n\telse\r\n\t\tsubjects = [subjectOrSubjects];\r\n\r\n\tassert.arrayOfObject(subjects);\r\n\tsubjects.forEach(function (subject) {\r\n\t\tutils.assertCompatible(subject, Identity, [1, 0], 'subject');\r\n\t});\r\n\r\n\tutils.assertCompatible(key, PrivateKey, [1, 2], 'private key');\r\n\r\n\tassert.optionalObject(options, 'options');\r\n\tif (options === undefined)\r\n\t\toptions = {};\r\n\tassert.optionalObject(options.validFrom, 'options.validFrom');\r\n\tassert.optionalObject(options.validUntil, 'options.validUntil');\r\n\tvar validFrom = options.validFrom;\r\n\tvar validUntil = options.validUntil;\r\n\tif (validFrom === undefined)\r\n\t\tvalidFrom = new Date();\r\n\tif (validUntil === undefined) {\r\n\t\tassert.optionalNumber(options.lifetime, 'options.lifetime');\r\n\t\tvar lifetime = options.lifetime;\r\n\t\tif (lifetime === undefined)\r\n\t\t\tlifetime = 10*365*24*3600;\r\n\t\tvalidUntil = new Date();\r\n\t\tvalidUntil.setTime(validUntil.getTime() + lifetime*1000);\r\n\t}\r\n\tassert.optionalBuffer(options.serial, 'options.serial');\r\n\tvar serial = options.serial;\r\n\tif (serial === undefined)\r\n\t\tserial = Buffer.from('0000000000000001', 'hex');\r\n\r\n\tvar purposes = options.purposes;\r\n\tif (purposes === undefined)\r\n\t\tpurposes = [];\r\n\r\n\tif (purposes.indexOf('signature') === -1)\r\n\t\tpurposes.push('signature');\r\n\r\n\t/* Self-signed certs are always CAs. */\r\n\tif (purposes.indexOf('ca') === -1)\r\n\t\tpurposes.push('ca');\r\n\tif (purposes.indexOf('crl') === -1)\r\n\t\tpurposes.push('crl');\r\n\r\n\t/*\r\n\t * If we weren't explicitly given any other purposes, do the sensible\r\n\t * thing and add some basic ones depending on the subject type.\r\n\t */\r\n\tif (purposes.length <= 3) {\r\n\t\tvar hostSubjects = subjects.filter(function (subject) {\r\n\t\t\treturn (subject.type === 'host');\r\n\t\t});\r\n\t\tvar userSubjects = subjects.filter(function (subject) {\r\n\t\t\treturn (subject.type === 'user');\r\n\t\t});\r\n\t\tif (hostSubjects.length > 0) {\r\n\t\t\tif (purposes.indexOf('serverAuth') === -1)\r\n\t\t\t\tpurposes.push('serverAuth');\r\n\t\t}\r\n\t\tif (userSubjects.length > 0) {\r\n\t\t\tif (purposes.indexOf('clientAuth') === -1)\r\n\t\t\t\tpurposes.push('clientAuth');\r\n\t\t}\r\n\t\tif (userSubjects.length > 0 || hostSubjects.length > 0) {\r\n\t\t\tif (purposes.indexOf('keyAgreement') === -1)\r\n\t\t\t\tpurposes.push('keyAgreement');\r\n\t\t\tif (key.type === 'rsa' &&\r\n\t\t\t    purposes.indexOf('encryption') === -1)\r\n\t\t\t\tpurposes.push('encryption');\r\n\t\t}\r\n\t}\r\n\r\n\tvar cert = new Certificate({\r\n\t\tsubjects: subjects,\r\n\t\tissuer: subjects[0],\r\n\t\tsubjectKey: key.toPublic(),\r\n\t\tissuerKey: key.toPublic(),\r\n\t\tsignatures: {},\r\n\t\tserial: serial,\r\n\t\tvalidFrom: validFrom,\r\n\t\tvalidUntil: validUntil,\r\n\t\tpurposes: purposes\r\n\t});\r\n\tcert.signWith(key);\r\n\r\n\treturn (cert);\r\n};\r\n\r\nCertificate.create =\r\n    function (subjectOrSubjects, key, issuer, issuerKey, options) {\r\n\tvar subjects;\r\n\tif (Array.isArray(subjectOrSubjects))\r\n\t\tsubjects = subjectOrSubjects;\r\n\telse\r\n\t\tsubjects = [subjectOrSubjects];\r\n\r\n\tassert.arrayOfObject(subjects);\r\n\tsubjects.forEach(function (subject) {\r\n\t\tutils.assertCompatible(subject, Identity, [1, 0], 'subject');\r\n\t});\r\n\r\n\tutils.assertCompatible(key, Key, [1, 0], 'key');\r\n\tif (PrivateKey.isPrivateKey(key))\r\n\t\tkey = key.toPublic();\r\n\tutils.assertCompatible(issuer, Identity, [1, 0], 'issuer');\r\n\tutils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');\r\n\r\n\tassert.optionalObject(options, 'options');\r\n\tif (options === undefined)\r\n\t\toptions = {};\r\n\tassert.optionalObject(options.validFrom, 'options.validFrom');\r\n\tassert.optionalObject(options.validUntil, 'options.validUntil');\r\n\tvar validFrom = options.validFrom;\r\n\tvar validUntil = options.validUntil;\r\n\tif (validFrom === undefined)\r\n\t\tvalidFrom = new Date();\r\n\tif (validUntil === undefined) {\r\n\t\tassert.optionalNumber(options.lifetime, 'options.lifetime');\r\n\t\tvar lifetime = options.lifetime;\r\n\t\tif (lifetime === undefined)\r\n\t\t\tlifetime = 10*365*24*3600;\r\n\t\tvalidUntil = new Date();\r\n\t\tvalidUntil.setTime(validUntil.getTime() + lifetime*1000);\r\n\t}\r\n\tassert.optionalBuffer(options.serial, 'options.serial');\r\n\tvar serial = options.serial;\r\n\tif (serial === undefined)\r\n\t\tserial = Buffer.from('0000000000000001', 'hex');\r\n\r\n\tvar purposes = options.purposes;\r\n\tif (purposes === undefined)\r\n\t\tpurposes = [];\r\n\r\n\tif (purposes.indexOf('signature') === -1)\r\n\t\tpurposes.push('signature');\r\n\r\n\tif (options.ca === true) {\r\n\t\tif (purposes.indexOf('ca') === -1)\r\n\t\t\tpurposes.push('ca');\r\n\t\tif (purposes.indexOf('crl') === -1)\r\n\t\t\tpurposes.push('crl');\r\n\t}\r\n\r\n\tvar hostSubjects = subjects.filter(function (subject) {\r\n\t\treturn (subject.type === 'host');\r\n\t});\r\n\tvar userSubjects = subjects.filter(function (subject) {\r\n\t\treturn (subject.type === 'user');\r\n\t});\r\n\tif (hostSubjects.length > 0) {\r\n\t\tif (purposes.indexOf('serverAuth') === -1)\r\n\t\t\tpurposes.push('serverAuth');\r\n\t}\r\n\tif (userSubjects.length > 0) {\r\n\t\tif (purposes.indexOf('clientAuth') === -1)\r\n\t\t\tpurposes.push('clientAuth');\r\n\t}\r\n\tif (userSubjects.length > 0 || hostSubjects.length > 0) {\r\n\t\tif (purposes.indexOf('keyAgreement') === -1)\r\n\t\t\tpurposes.push('keyAgreement');\r\n\t\tif (key.type === 'rsa' &&\r\n\t\t    purposes.indexOf('encryption') === -1)\r\n\t\t\tpurposes.push('encryption');\r\n\t}\r\n\r\n\tvar cert = new Certificate({\r\n\t\tsubjects: subjects,\r\n\t\tissuer: issuer,\r\n\t\tsubjectKey: key,\r\n\t\tissuerKey: issuerKey.toPublic(),\r\n\t\tsignatures: {},\r\n\t\tserial: serial,\r\n\t\tvalidFrom: validFrom,\r\n\t\tvalidUntil: validUntil,\r\n\t\tpurposes: purposes\r\n\t});\r\n\tcert.signWith(issuerKey);\r\n\r\n\treturn (cert);\r\n};\r\n\r\nCertificate.parse = function (data, format, options) {\r\n\tif (typeof (data) !== 'string')\r\n\t\tassert.buffer(data, 'data');\r\n\tif (format === undefined)\r\n\t\tformat = 'auto';\r\n\tassert.string(format, 'format');\r\n\tif (typeof (options) === 'string')\r\n\t\toptions = { filename: options };\r\n\tassert.optionalObject(options, 'options');\r\n\tif (options === undefined)\r\n\t\toptions = {};\r\n\tassert.optionalString(options.filename, 'options.filename');\r\n\tif (options.filename === undefined)\r\n\t\toptions.filename = '(unnamed)';\r\n\r\n\tassert.object(formats[format], 'formats[format]');\r\n\r\n\ttry {\r\n\t\tvar k = formats[format].read(data, options);\r\n\t\treturn (k);\r\n\t} catch (e) {\r\n\t\tthrow (new CertificateParseError(options.filename, format, e));\r\n\t}\r\n};\r\n\r\nCertificate.isCertificate = function (obj, ver) {\r\n\treturn (utils.isCompatible(obj, Certificate, ver));\r\n};\r\n\r\n/*\r\n * API versions for Certificate:\r\n * [1,0] -- initial ver\r\n * [1,1] -- openssh format now unpacks extensions\r\n */\r\nCertificate.prototype._sshpkApiVersion = [1, 1];\r\n\r\nCertificate._oldVersionDetect = function (obj) {\r\n\treturn ([1, 0]);\r\n};\r\n","// Copyright 2017 Joyent, Inc.\r\n\r\nmodule.exports = Identity;\r\n\r\nvar assert = require('assert-plus');\r\nvar algs = require('./algs');\r\nvar crypto = require('crypto');\r\nvar Fingerprint = require('./fingerprint');\r\nvar Signature = require('./signature');\r\nvar errs = require('./errors');\r\nvar util = require('util');\r\nvar utils = require('./utils');\r\nvar asn1 = require('asn1');\r\nvar Buffer = require('safer-buffer').Buffer;\r\n\r\n/*JSSTYLED*/\r\nvar DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\\-]{0,62})(?:\\.([*]|[a-z0-9][a-z0-9\\-]{0,62}))*$/i;\r\n\r\nvar oids = {};\r\noids.cn = '2.5.4.3';\r\noids.o = '2.5.4.10';\r\noids.ou = '2.5.4.11';\r\noids.l = '2.5.4.7';\r\noids.s = '2.5.4.8';\r\noids.c = '2.5.4.6';\r\noids.sn = '2.5.4.4';\r\noids.postalCode = '2.5.4.17';\r\noids.serialNumber = '2.5.4.5';\r\noids.street = '2.5.4.9';\r\noids.x500UniqueIdentifier = '2.5.4.45';\r\noids.role = '2.5.4.72';\r\noids.telephoneNumber = '2.5.4.20';\r\noids.description = '2.5.4.13';\r\noids.dc = '0.9.2342.19200300.100.1.25';\r\noids.uid = '0.9.2342.19200300.100.1.1';\r\noids.mail = '0.9.2342.19200300.100.1.3';\r\noids.title = '2.5.4.12';\r\noids.gn = '2.5.4.42';\r\noids.initials = '2.5.4.43';\r\noids.pseudonym = '2.5.4.65';\r\noids.emailAddress = '1.2.840.113549.1.9.1';\r\n\r\nvar unoids = {};\r\nObject.keys(oids).forEach(function (k) {\r\n\tunoids[oids[k]] = k;\r\n});\r\n\r\nfunction Identity(opts) {\r\n\tvar self = this;\r\n\tassert.object(opts, 'options');\r\n\tassert.arrayOfObject(opts.components, 'options.components');\r\n\tthis.components = opts.components;\r\n\tthis.componentLookup = {};\r\n\tthis.components.forEach(function (c) {\r\n\t\tif (c.name && !c.oid)\r\n\t\t\tc.oid = oids[c.name];\r\n\t\tif (c.oid && !c.name)\r\n\t\t\tc.name = unoids[c.oid];\r\n\t\tif (self.componentLookup[c.name] === undefined)\r\n\t\t\tself.componentLookup[c.name] = [];\r\n\t\tself.componentLookup[c.name].push(c);\r\n\t});\r\n\tif (this.componentLookup.cn && this.componentLookup.cn.length > 0) {\r\n\t\tthis.cn = this.componentLookup.cn[0].value;\r\n\t}\r\n\tassert.optionalString(opts.type, 'options.type');\r\n\tif (opts.type === undefined) {\r\n\t\tif (this.components.length === 1 &&\r\n\t\t    this.componentLookup.cn &&\r\n\t\t    this.componentLookup.cn.length === 1 &&\r\n\t\t    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {\r\n\t\t\tthis.type = 'host';\r\n\t\t\tthis.hostname = this.componentLookup.cn[0].value;\r\n\r\n\t\t} else if (this.componentLookup.dc &&\r\n\t\t    this.components.length === this.componentLookup.dc.length) {\r\n\t\t\tthis.type = 'host';\r\n\t\t\tthis.hostname = this.componentLookup.dc.map(\r\n\t\t\t    function (c) {\r\n\t\t\t\treturn (c.value);\r\n\t\t\t}).join('.');\r\n\r\n\t\t} else if (this.componentLookup.uid &&\r\n\t\t    this.components.length ===\r\n\t\t    this.componentLookup.uid.length) {\r\n\t\t\tthis.type = 'user';\r\n\t\t\tthis.uid = this.componentLookup.uid[0].value;\r\n\r\n\t\t} else if (this.componentLookup.cn &&\r\n\t\t    this.componentLookup.cn.length === 1 &&\r\n\t\t    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {\r\n\t\t\tthis.type = 'host';\r\n\t\t\tthis.hostname = this.componentLookup.cn[0].value;\r\n\r\n\t\t} else if (this.componentLookup.uid &&\r\n\t\t    this.componentLookup.uid.length === 1) {\r\n\t\t\tthis.type = 'user';\r\n\t\t\tthis.uid = this.componentLookup.uid[0].value;\r\n\r\n\t\t} else if (this.componentLookup.mail &&\r\n\t\t    this.componentLookup.mail.length === 1) {\r\n\t\t\tthis.type = 'email';\r\n\t\t\tthis.email = this.componentLookup.mail[0].value;\r\n\r\n\t\t} else if (this.componentLookup.cn &&\r\n\t\t    this.componentLookup.cn.length === 1) {\r\n\t\t\tthis.type = 'user';\r\n\t\t\tthis.uid = this.componentLookup.cn[0].value;\r\n\r\n\t\t} else {\r\n\t\t\tthis.type = 'unknown';\r\n\t\t}\r\n\t} else {\r\n\t\tthis.type = opts.type;\r\n\t\tif (this.type === 'host')\r\n\t\t\tthis.hostname = opts.hostname;\r\n\t\telse if (this.type === 'user')\r\n\t\t\tthis.uid = opts.uid;\r\n\t\telse if (this.type === 'email')\r\n\t\t\tthis.email = opts.email;\r\n\t\telse\r\n\t\t\tthrow (new Error('Unknown type ' + this.type));\r\n\t}\r\n}\r\n\r\nIdentity.prototype.toString = function () {\r\n\treturn (this.components.map(function (c) {\r\n\t\tvar n = c.name.toUpperCase();\r\n\t\t/*JSSTYLED*/\r\n\t\tn = n.replace(/=/g, '\\\\=');\r\n\t\tvar v = c.value;\r\n\t\t/*JSSTYLED*/\r\n\t\tv = v.replace(/,/g, '\\\\,');\r\n\t\treturn (n + '=' + v);\r\n\t}).join(', '));\r\n};\r\n\r\nIdentity.prototype.get = function (name, asArray) {\r\n\tassert.string(name, 'name');\r\n\tvar arr = this.componentLookup[name];\r\n\tif (arr === undefined || arr.length === 0)\r\n\t\treturn (undefined);\r\n\tif (!asArray && arr.length > 1)\r\n\t\tthrow (new Error('Multiple values for attribute ' + name));\r\n\tif (!asArray)\r\n\t\treturn (arr[0].value);\r\n\treturn (arr.map(function (c) {\r\n\t\treturn (c.value);\r\n\t}));\r\n};\r\n\r\nIdentity.prototype.toArray = function (idx) {\r\n\treturn (this.components.map(function (c) {\r\n\t\treturn ({\r\n\t\t\tname: c.name,\r\n\t\t\tvalue: c.value\r\n\t\t});\r\n\t}));\r\n};\r\n\r\n/*\r\n * These are from X.680 -- PrintableString allowed chars are in section 37.4\r\n * table 8. Spec for IA5Strings is \"1,6 + SPACE + DEL\" where 1 refers to\r\n * ISO IR #001 (standard ASCII control characters) and 6 refers to ISO IR #006\r\n * (the basic ASCII character set).\r\n */\r\n/* JSSTYLED */\r\nvar NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\\/:=?-]/;\r\n/* JSSTYLED */\r\nvar NOT_IA5 = /[^\\x00-\\x7f]/;\r\n\r\nIdentity.prototype.toAsn1 = function (der, tag) {\r\n\tder.startSequence(tag);\r\n\tthis.components.forEach(function (c) {\r\n\t\tder.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);\r\n\t\tder.startSequence();\r\n\t\tder.writeOID(c.oid);\r\n\t\t/*\r\n\t\t * If we fit in a PrintableString, use that. Otherwise use an\r\n\t\t * IA5String or UTF8String.\r\n\t\t *\r\n\t\t * If this identity was parsed from a DN, use the ASN.1 types\r\n\t\t * from the original representation (otherwise this might not\r\n\t\t * be a full match for the original in some validators).\r\n\t\t */\r\n\t\tif (c.asn1type === asn1.Ber.Utf8String ||\r\n\t\t    c.value.match(NOT_IA5)) {\r\n\t\t\tvar v = Buffer.from(c.value, 'utf8');\r\n\t\t\tder.writeBuffer(v, asn1.Ber.Utf8String);\r\n\r\n\t\t} else if (c.asn1type === asn1.Ber.IA5String ||\r\n\t\t    c.value.match(NOT_PRINTABLE)) {\r\n\t\t\tder.writeString(c.value, asn1.Ber.IA5String);\r\n\r\n\t\t} else {\r\n\t\t\tvar type = asn1.Ber.PrintableString;\r\n\t\t\tif (c.asn1type !== undefined)\r\n\t\t\t\ttype = c.asn1type;\r\n\t\t\tder.writeString(c.value, type);\r\n\t\t}\r\n\t\tder.endSequence();\r\n\t\tder.endSequence();\r\n\t});\r\n\tder.endSequence();\r\n};\r\n\r\nfunction globMatch(a, b) {\r\n\tif (a === '**' || b === '**')\r\n\t\treturn (true);\r\n\tvar aParts = a.split('.');\r\n\tvar bParts = b.split('.');\r\n\tif (aParts.length !== bParts.length)\r\n\t\treturn (false);\r\n\tfor (var i = 0; i < aParts.length; ++i) {\r\n\t\tif (aParts[i] === '*' || bParts[i] === '*')\r\n\t\t\tcontinue;\r\n\t\tif (aParts[i] !== bParts[i])\r\n\t\t\treturn (false);\r\n\t}\r\n\treturn (true);\r\n}\r\n\r\nIdentity.prototype.equals = function (other) {\r\n\tif (!Identity.isIdentity(other, [1, 0]))\r\n\t\treturn (false);\r\n\tif (other.components.length !== this.components.length)\r\n\t\treturn (false);\r\n\tfor (var i = 0; i < this.components.length; ++i) {\r\n\t\tif (this.components[i].oid !== other.components[i].oid)\r\n\t\t\treturn (false);\r\n\t\tif (!globMatch(this.components[i].value,\r\n\t\t    other.components[i].value)) {\r\n\t\t\treturn (false);\r\n\t\t}\r\n\t}\r\n\treturn (true);\r\n};\r\n\r\nIdentity.forHost = function (hostname) {\r\n\tassert.string(hostname, 'hostname');\r\n\treturn (new Identity({\r\n\t\ttype: 'host',\r\n\t\thostname: hostname,\r\n\t\tcomponents: [ { name: 'cn', value: hostname } ]\r\n\t}));\r\n};\r\n\r\nIdentity.forUser = function (uid) {\r\n\tassert.string(uid, 'uid');\r\n\treturn (new Identity({\r\n\t\ttype: 'user',\r\n\t\tuid: uid,\r\n\t\tcomponents: [ { name: 'uid', value: uid } ]\r\n\t}));\r\n};\r\n\r\nIdentity.forEmail = function (email) {\r\n\tassert.string(email, 'email');\r\n\treturn (new Identity({\r\n\t\ttype: 'email',\r\n\t\temail: email,\r\n\t\tcomponents: [ { name: 'mail', value: email } ]\r\n\t}));\r\n};\r\n\r\nIdentity.parseDN = function (dn) {\r\n\tassert.string(dn, 'dn');\r\n\tvar parts = [''];\r\n\tvar idx = 0;\r\n\tvar rem = dn;\r\n\twhile (rem.length > 0) {\r\n\t\tvar m;\r\n\t\t/*JSSTYLED*/\r\n\t\tif ((m = /^,/.exec(rem)) !== null) {\r\n\t\t\tparts[++idx] = '';\r\n\t\t\trem = rem.slice(m[0].length);\r\n\t\t/*JSSTYLED*/\r\n\t\t} else if ((m = /^\\\\,/.exec(rem)) !== null) {\r\n\t\t\tparts[idx] += ',';\r\n\t\t\trem = rem.slice(m[0].length);\r\n\t\t/*JSSTYLED*/\r\n\t\t} else if ((m = /^\\\\./.exec(rem)) !== null) {\r\n\t\t\tparts[idx] += m[0];\r\n\t\t\trem = rem.slice(m[0].length);\r\n\t\t/*JSSTYLED*/\r\n\t\t} else if ((m = /^[^\\\\,]+/.exec(rem)) !== null) {\r\n\t\t\tparts[idx] += m[0];\r\n\t\t\trem = rem.slice(m[0].length);\r\n\t\t} else {\r\n\t\t\tthrow (new Error('Failed to parse DN'));\r\n\t\t}\r\n\t}\r\n\tvar cmps = parts.map(function (c) {\r\n\t\tc = c.trim();\r\n\t\tvar eqPos = c.indexOf('=');\r\n\t\twhile (eqPos > 0 && c.charAt(eqPos - 1) === '\\\\')\r\n\t\t\teqPos = c.indexOf('=', eqPos + 1);\r\n\t\tif (eqPos === -1) {\r\n\t\t\tthrow (new Error('Failed to parse DN'));\r\n\t\t}\r\n\t\t/*JSSTYLED*/\r\n\t\tvar name = c.slice(0, eqPos).toLowerCase().replace(/\\\\=/g, '=');\r\n\t\tvar value = c.slice(eqPos + 1);\r\n\t\treturn ({ name: name, value: value });\r\n\t});\r\n\treturn (new Identity({ components: cmps }));\r\n};\r\n\r\nIdentity.fromArray = function (components) {\r\n\tassert.arrayOfObject(components, 'components');\r\n\tcomponents.forEach(function (cmp) {\r\n\t\tassert.object(cmp, 'component');\r\n\t\tassert.string(cmp.name, 'component.name');\r\n\t\tif (!Buffer.isBuffer(cmp.value) &&\r\n\t\t    !(typeof (cmp.value) === 'string')) {\r\n\t\t\tthrow (new Error('Invalid component value'));\r\n\t\t}\r\n\t});\r\n\treturn (new Identity({ components: components }));\r\n};\r\n\r\nIdentity.parseAsn1 = function (der, top) {\r\n\tvar components = [];\r\n\tder.readSequence(top);\r\n\tvar end = der.offset + der.length;\r\n\twhile (der.offset < end) {\r\n\t\tder.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);\r\n\t\tvar after = der.offset + der.length;\r\n\t\tder.readSequence();\r\n\t\tvar oid = der.readOID();\r\n\t\tvar type = der.peek();\r\n\t\tvar value;\r\n\t\tswitch (type) {\r\n\t\tcase asn1.Ber.PrintableString:\r\n\t\tcase asn1.Ber.IA5String:\r\n\t\tcase asn1.Ber.OctetString:\r\n\t\tcase asn1.Ber.T61String:\r\n\t\t\tvalue = der.readString(type);\r\n\t\t\tbreak;\r\n\t\tcase asn1.Ber.Utf8String:\r\n\t\t\tvalue = der.readString(type, true);\r\n\t\t\tvalue = value.toString('utf8');\r\n\t\t\tbreak;\r\n\t\tcase asn1.Ber.CharacterString:\r\n\t\tcase asn1.Ber.BMPString:\r\n\t\t\tvalue = der.readString(type, true);\r\n\t\t\tvalue = value.toString('utf16le');\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow (new Error('Unknown asn1 type ' + type));\r\n\t\t}\r\n\t\tcomponents.push({ oid: oid, asn1type: type, value: value });\r\n\t\tder._offset = after;\r\n\t}\r\n\tder._offset = end;\r\n\treturn (new Identity({\r\n\t\tcomponents: components\r\n\t}));\r\n};\r\n\r\nIdentity.isIdentity = function (obj, ver) {\r\n\treturn (utils.isCompatible(obj, Identity, ver));\r\n};\r\n\r\n/*\r\n * API versions for Identity:\r\n * [1,0] -- initial ver\r\n */\r\nIdentity.prototype._sshpkApiVersion = [1, 0];\r\n\r\nIdentity._oldVersionDetect = function (obj) {\r\n\treturn ([1, 0]);\r\n};\r\n","// Copyright 2017 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\tverify: verify,\r\n\tsign: sign,\r\n\tsignAsync: signAsync,\r\n\twrite: write,\r\n\r\n\t/* Internal private API */\r\n\tfromBuffer: fromBuffer,\r\n\ttoBuffer: toBuffer\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar SSHBuffer = require('../ssh-buffer');\r\nvar crypto = require('crypto');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('../algs');\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\nvar Identity = require('../identity');\r\nvar rfc4253 = require('./rfc4253');\r\nvar Signature = require('../signature');\r\nvar utils = require('../utils');\r\nvar Certificate = require('../certificate');\r\n\r\nfunction verify(cert, key) {\r\n\t/*\r\n\t * We always give an issuerKey, so if our verify() is being called then\r\n\t * there was no signature. Return false.\r\n\t */\r\n\treturn (false);\r\n}\r\n\r\nvar TYPES = {\r\n\t'user': 1,\r\n\t'host': 2\r\n};\r\nObject.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });\r\n\r\nvar ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;\r\n\r\nfunction read(buf, options) {\r\n\tif (Buffer.isBuffer(buf))\r\n\t\tbuf = buf.toString('ascii');\r\n\tvar parts = buf.trim().split(/[ \\t\\n]+/g);\r\n\tif (parts.length < 2 || parts.length > 3)\r\n\t\tthrow (new Error('Not a valid SSH certificate line'));\r\n\r\n\tvar algo = parts[0];\r\n\tvar data = parts[1];\r\n\r\n\tdata = Buffer.from(data, 'base64');\r\n\treturn (fromBuffer(data, algo));\r\n}\r\n\r\nfunction fromBuffer(data, algo, partial) {\r\n\tvar sshbuf = new SSHBuffer({ buffer: data });\r\n\tvar innerAlgo = sshbuf.readString();\r\n\tif (algo !== undefined && innerAlgo !== algo)\r\n\t\tthrow (new Error('SSH certificate algorithm mismatch'));\r\n\tif (algo === undefined)\r\n\t\talgo = innerAlgo;\r\n\r\n\tvar cert = {};\r\n\tcert.signatures = {};\r\n\tcert.signatures.openssh = {};\r\n\r\n\tcert.signatures.openssh.nonce = sshbuf.readBuffer();\r\n\r\n\tvar key = {};\r\n\tvar parts = (key.parts = []);\r\n\tkey.type = getAlg(algo);\r\n\r\n\tvar partCount = algs.info[key.type].parts.length;\r\n\twhile (parts.length < partCount)\r\n\t\tparts.push(sshbuf.readPart());\r\n\tassert.ok(parts.length >= 1, 'key must have at least one part');\r\n\r\n\tvar algInfo = algs.info[key.type];\r\n\tif (key.type === 'ecdsa') {\r\n\t\tvar res = ECDSA_ALGO.exec(algo);\r\n\t\tassert.ok(res !== null);\r\n\t\tassert.strictEqual(res[1], parts[0].data.toString());\r\n\t}\r\n\r\n\tfor (var i = 0; i < algInfo.parts.length; ++i) {\r\n\t\tparts[i].name = algInfo.parts[i];\r\n\t\tif (parts[i].name !== 'curve' &&\r\n\t\t    algInfo.normalize !== false) {\r\n\t\t\tvar p = parts[i];\r\n\t\t\tp.data = utils.mpNormalize(p.data);\r\n\t\t}\r\n\t}\r\n\r\n\tcert.subjectKey = new Key(key);\r\n\r\n\tcert.serial = sshbuf.readInt64();\r\n\r\n\tvar type = TYPES[sshbuf.readInt()];\r\n\tassert.string(type, 'valid cert type');\r\n\r\n\tcert.signatures.openssh.keyId = sshbuf.readString();\r\n\r\n\tvar principals = [];\r\n\tvar pbuf = sshbuf.readBuffer();\r\n\tvar psshbuf = new SSHBuffer({ buffer: pbuf });\r\n\twhile (!psshbuf.atEnd())\r\n\t\tprincipals.push(psshbuf.readString());\r\n\tif (principals.length === 0)\r\n\t\tprincipals = ['*'];\r\n\r\n\tcert.subjects = principals.map(function (pr) {\r\n\t\tif (type === 'user')\r\n\t\t\treturn (Identity.forUser(pr));\r\n\t\telse if (type === 'host')\r\n\t\t\treturn (Identity.forHost(pr));\r\n\t\tthrow (new Error('Unknown identity type ' + type));\r\n\t});\r\n\r\n\tcert.validFrom = int64ToDate(sshbuf.readInt64());\r\n\tcert.validUntil = int64ToDate(sshbuf.readInt64());\r\n\r\n\tvar exts = [];\r\n\tvar extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\r\n\tvar ext;\r\n\twhile (!extbuf.atEnd()) {\r\n\t\text = { critical: true };\r\n\t\text.name = extbuf.readString();\r\n\t\text.data = extbuf.readBuffer();\r\n\t\texts.push(ext);\r\n\t}\r\n\textbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });\r\n\twhile (!extbuf.atEnd()) {\r\n\t\text = { critical: false };\r\n\t\text.name = extbuf.readString();\r\n\t\text.data = extbuf.readBuffer();\r\n\t\texts.push(ext);\r\n\t}\r\n\tcert.signatures.openssh.exts = exts;\r\n\r\n\t/* reserved */\r\n\tsshbuf.readBuffer();\r\n\r\n\tvar signingKeyBuf = sshbuf.readBuffer();\r\n\tcert.issuerKey = rfc4253.read(signingKeyBuf);\r\n\r\n\t/*\r\n\t * OpenSSH certs don't give the identity of the issuer, just their\r\n\t * public key. So, we use an Identity that matches anything. The\r\n\t * isSignedBy() function will later tell you if the key matches.\r\n\t */\r\n\tcert.issuer = Identity.forHost('**');\r\n\r\n\tvar sigBuf = sshbuf.readBuffer();\r\n\tcert.signatures.openssh.signature =\r\n\t    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');\r\n\r\n\tif (partial !== undefined) {\r\n\t\tpartial.remainder = sshbuf.remainder();\r\n\t\tpartial.consumed = sshbuf._offset;\r\n\t}\r\n\r\n\treturn (new Certificate(cert));\r\n}\r\n\r\nfunction int64ToDate(buf) {\r\n\tvar i = buf.readUInt32BE(0) * 4294967296;\r\n\ti += buf.readUInt32BE(4);\r\n\tvar d = new Date();\r\n\td.setTime(i * 1000);\r\n\td.sourceInt64 = buf;\r\n\treturn (d);\r\n}\r\n\r\nfunction dateToInt64(date) {\r\n\tif (date.sourceInt64 !== undefined)\r\n\t\treturn (date.sourceInt64);\r\n\tvar i = Math.round(date.getTime() / 1000);\r\n\tvar upper = Math.floor(i / 4294967296);\r\n\tvar lower = Math.floor(i % 4294967296);\r\n\tvar buf = Buffer.alloc(8);\r\n\tbuf.writeUInt32BE(upper, 0);\r\n\tbuf.writeUInt32BE(lower, 4);\r\n\treturn (buf);\r\n}\r\n\r\nfunction sign(cert, key) {\r\n\tif (cert.signatures.openssh === undefined)\r\n\t\tcert.signatures.openssh = {};\r\n\ttry {\r\n\t\tvar blob = toBuffer(cert, true);\r\n\t} catch (e) {\r\n\t\tdelete (cert.signatures.openssh);\r\n\t\treturn (false);\r\n\t}\r\n\tvar sig = cert.signatures.openssh;\r\n\tvar hashAlgo = undefined;\r\n\tif (key.type === 'rsa' || key.type === 'dsa')\r\n\t\thashAlgo = 'sha1';\r\n\tvar signer = key.createSign(hashAlgo);\r\n\tsigner.write(blob);\r\n\tsig.signature = signer.sign();\r\n\treturn (true);\r\n}\r\n\r\nfunction signAsync(cert, signer, done) {\r\n\tif (cert.signatures.openssh === undefined)\r\n\t\tcert.signatures.openssh = {};\r\n\ttry {\r\n\t\tvar blob = toBuffer(cert, true);\r\n\t} catch (e) {\r\n\t\tdelete (cert.signatures.openssh);\r\n\t\tdone(e);\r\n\t\treturn;\r\n\t}\r\n\tvar sig = cert.signatures.openssh;\r\n\r\n\tsigner(blob, function (err, signature) {\r\n\t\tif (err) {\r\n\t\t\tdone(err);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\t/*\r\n\t\t\t * This will throw if the signature isn't of a\r\n\t\t\t * type/algo that can be used for SSH.\r\n\t\t\t */\r\n\t\t\tsignature.toBuffer('ssh');\r\n\t\t} catch (e) {\r\n\t\t\tdone(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsig.signature = signature;\r\n\t\tdone();\r\n\t});\r\n}\r\n\r\nfunction write(cert, options) {\r\n\tif (options === undefined)\r\n\t\toptions = {};\r\n\r\n\tvar blob = toBuffer(cert);\r\n\tvar out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');\r\n\tif (options.comment)\r\n\t\tout = out + ' ' + options.comment;\r\n\treturn (out);\r\n}\r\n\r\n\r\nfunction toBuffer(cert, noSig) {\r\n\tassert.object(cert.signatures.openssh, 'signature for openssh format');\r\n\tvar sig = cert.signatures.openssh;\r\n\r\n\tif (sig.nonce === undefined)\r\n\t\tsig.nonce = crypto.randomBytes(16);\r\n\tvar buf = new SSHBuffer({});\r\n\tbuf.writeString(getCertType(cert.subjectKey));\r\n\tbuf.writeBuffer(sig.nonce);\r\n\r\n\tvar key = cert.subjectKey;\r\n\tvar algInfo = algs.info[key.type];\r\n\talgInfo.parts.forEach(function (part) {\r\n\t\tbuf.writePart(key.part[part]);\r\n\t});\r\n\r\n\tbuf.writeInt64(cert.serial);\r\n\r\n\tvar type = cert.subjects[0].type;\r\n\tassert.notStrictEqual(type, 'unknown');\r\n\tcert.subjects.forEach(function (id) {\r\n\t\tassert.strictEqual(id.type, type);\r\n\t});\r\n\ttype = TYPES[type];\r\n\tbuf.writeInt(type);\r\n\r\n\tif (sig.keyId === undefined) {\r\n\t\tsig.keyId = cert.subjects[0].type + '_' +\r\n\t\t    (cert.subjects[0].uid || cert.subjects[0].hostname);\r\n\t}\r\n\tbuf.writeString(sig.keyId);\r\n\r\n\tvar sub = new SSHBuffer({});\r\n\tcert.subjects.forEach(function (id) {\r\n\t\tif (type === TYPES.host)\r\n\t\t\tsub.writeString(id.hostname);\r\n\t\telse if (type === TYPES.user)\r\n\t\t\tsub.writeString(id.uid);\r\n\t});\r\n\tbuf.writeBuffer(sub.toBuffer());\r\n\r\n\tbuf.writeInt64(dateToInt64(cert.validFrom));\r\n\tbuf.writeInt64(dateToInt64(cert.validUntil));\r\n\r\n\tvar exts = sig.exts;\r\n\tif (exts === undefined)\r\n\t\texts = [];\r\n\r\n\tvar extbuf = new SSHBuffer({});\r\n\texts.forEach(function (ext) {\r\n\t\tif (ext.critical !== true)\r\n\t\t\treturn;\r\n\t\textbuf.writeString(ext.name);\r\n\t\textbuf.writeBuffer(ext.data);\r\n\t});\r\n\tbuf.writeBuffer(extbuf.toBuffer());\r\n\r\n\textbuf = new SSHBuffer({});\r\n\texts.forEach(function (ext) {\r\n\t\tif (ext.critical === true)\r\n\t\t\treturn;\r\n\t\textbuf.writeString(ext.name);\r\n\t\textbuf.writeBuffer(ext.data);\r\n\t});\r\n\tbuf.writeBuffer(extbuf.toBuffer());\r\n\r\n\t/* reserved */\r\n\tbuf.writeBuffer(Buffer.alloc(0));\r\n\r\n\tsub = rfc4253.write(cert.issuerKey);\r\n\tbuf.writeBuffer(sub);\r\n\r\n\tif (!noSig)\r\n\t\tbuf.writeBuffer(sig.signature.toBuffer('ssh'));\r\n\r\n\treturn (buf.toBuffer());\r\n}\r\n\r\nfunction getAlg(certType) {\r\n\tif (certType === 'ssh-rsa-cert-v01@openssh.com')\r\n\t\treturn ('rsa');\r\n\tif (certType === 'ssh-dss-cert-v01@openssh.com')\r\n\t\treturn ('dsa');\r\n\tif (certType.match(ECDSA_ALGO))\r\n\t\treturn ('ecdsa');\r\n\tif (certType === 'ssh-ed25519-cert-v01@openssh.com')\r\n\t\treturn ('ed25519');\r\n\tthrow (new Error('Unsupported cert type ' + certType));\r\n}\r\n\r\nfunction getCertType(key) {\r\n\tif (key.type === 'rsa')\r\n\t\treturn ('ssh-rsa-cert-v01@openssh.com');\r\n\tif (key.type === 'dsa')\r\n\t\treturn ('ssh-dss-cert-v01@openssh.com');\r\n\tif (key.type === 'ecdsa')\r\n\t\treturn ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');\r\n\tif (key.type === 'ed25519')\r\n\t\treturn ('ssh-ed25519-cert-v01@openssh.com');\r\n\tthrow (new Error('Unsupported key type ' + key.type));\r\n}\r\n","// Copyright 2017 Joyent, Inc.\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\tverify: verify,\r\n\tsign: sign,\r\n\tsignAsync: signAsync,\r\n\twrite: write\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar asn1 = require('asn1');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('../algs');\r\nvar utils = require('../utils');\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\nvar pem = require('./pem');\r\nvar Identity = require('../identity');\r\nvar Signature = require('../signature');\r\nvar Certificate = require('../certificate');\r\nvar pkcs8 = require('./pkcs8');\r\n\r\n/*\r\n * This file is based on RFC5280 (X.509).\r\n */\r\n\r\n/* Helper to read in a single mpint */\r\nfunction readMPInt(der, nm) {\r\n\tassert.strictEqual(der.peek(), asn1.Ber.Integer,\r\n\t    nm + ' is not an Integer');\r\n\treturn (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));\r\n}\r\n\r\nfunction verify(cert, key) {\r\n\tvar sig = cert.signatures.x509;\r\n\tassert.object(sig, 'x509 signature');\r\n\r\n\tvar algParts = sig.algo.split('-');\r\n\tif (algParts[0] !== key.type)\r\n\t\treturn (false);\r\n\r\n\tvar blob = sig.cache;\r\n\tif (blob === undefined) {\r\n\t\tvar der = new asn1.BerWriter();\r\n\t\twriteTBSCert(cert, der);\r\n\t\tblob = der.buffer;\r\n\t}\r\n\r\n\tvar verifier = key.createVerify(algParts[1]);\r\n\tverifier.write(blob);\r\n\treturn (verifier.verify(sig.signature));\r\n}\r\n\r\nfunction Local(i) {\r\n\treturn (asn1.Ber.Context | asn1.Ber.Constructor | i);\r\n}\r\n\r\nfunction Context(i) {\r\n\treturn (asn1.Ber.Context | i);\r\n}\r\n\r\nvar SIGN_ALGS = {\r\n\t'rsa-md5': '1.2.840.113549.1.1.4',\r\n\t'rsa-sha1': '1.2.840.113549.1.1.5',\r\n\t'rsa-sha256': '1.2.840.113549.1.1.11',\r\n\t'rsa-sha384': '1.2.840.113549.1.1.12',\r\n\t'rsa-sha512': '1.2.840.113549.1.1.13',\r\n\t'dsa-sha1': '1.2.840.10040.4.3',\r\n\t'dsa-sha256': '2.16.840.1.101.3.4.3.2',\r\n\t'ecdsa-sha1': '1.2.840.10045.4.1',\r\n\t'ecdsa-sha256': '1.2.840.10045.4.3.2',\r\n\t'ecdsa-sha384': '1.2.840.10045.4.3.3',\r\n\t'ecdsa-sha512': '1.2.840.10045.4.3.4',\r\n\t'ed25519-sha512': '1.3.101.112'\r\n};\r\nObject.keys(SIGN_ALGS).forEach(function (k) {\r\n\tSIGN_ALGS[SIGN_ALGS[k]] = k;\r\n});\r\nSIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';\r\nSIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';\r\n\r\nvar EXTS = {\r\n\t'issuerKeyId': '2.5.29.35',\r\n\t'altName': '2.5.29.17',\r\n\t'basicConstraints': '2.5.29.19',\r\n\t'keyUsage': '2.5.29.15',\r\n\t'extKeyUsage': '2.5.29.37'\r\n};\r\n\r\nfunction read(buf, options) {\r\n\tif (typeof (buf) === 'string') {\r\n\t\tbuf = Buffer.from(buf, 'binary');\r\n\t}\r\n\tassert.buffer(buf, 'buf');\r\n\r\n\tvar der = new asn1.BerReader(buf);\r\n\r\n\tder.readSequence();\r\n\tif (Math.abs(der.length - der.remain) > 1) {\r\n\t\tthrow (new Error('DER sequence does not contain whole byte ' +\r\n\t\t    'stream'));\r\n\t}\r\n\r\n\tvar tbsStart = der.offset;\r\n\tder.readSequence();\r\n\tvar sigOffset = der.offset + der.length;\r\n\tvar tbsEnd = sigOffset;\r\n\r\n\tif (der.peek() === Local(0)) {\r\n\t\tder.readSequence(Local(0));\r\n\t\tvar version = der.readInt();\r\n\t\tassert.ok(version <= 3,\r\n\t\t    'only x.509 versions up to v3 supported');\r\n\t}\r\n\r\n\tvar cert = {};\r\n\tcert.signatures = {};\r\n\tvar sig = (cert.signatures.x509 = {});\r\n\tsig.extras = {};\r\n\r\n\tcert.serial = readMPInt(der, 'serial');\r\n\r\n\tder.readSequence();\r\n\tvar after = der.offset + der.length;\r\n\tvar certAlgOid = der.readOID();\r\n\tvar certAlg = SIGN_ALGS[certAlgOid];\r\n\tif (certAlg === undefined)\r\n\t\tthrow (new Error('unknown signature algorithm ' + certAlgOid));\r\n\r\n\tder._offset = after;\r\n\tcert.issuer = Identity.parseAsn1(der);\r\n\r\n\tder.readSequence();\r\n\tcert.validFrom = readDate(der);\r\n\tcert.validUntil = readDate(der);\r\n\r\n\tcert.subjects = [Identity.parseAsn1(der)];\r\n\r\n\tder.readSequence();\r\n\tafter = der.offset + der.length;\r\n\tcert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);\r\n\tder._offset = after;\r\n\r\n\t/* issuerUniqueID */\r\n\tif (der.peek() === Local(1)) {\r\n\t\tder.readSequence(Local(1));\r\n\t\tsig.extras.issuerUniqueID =\r\n\t\t    buf.slice(der.offset, der.offset + der.length);\r\n\t\tder._offset += der.length;\r\n\t}\r\n\r\n\t/* subjectUniqueID */\r\n\tif (der.peek() === Local(2)) {\r\n\t\tder.readSequence(Local(2));\r\n\t\tsig.extras.subjectUniqueID =\r\n\t\t    buf.slice(der.offset, der.offset + der.length);\r\n\t\tder._offset += der.length;\r\n\t}\r\n\r\n\t/* extensions */\r\n\tif (der.peek() === Local(3)) {\r\n\t\tder.readSequence(Local(3));\r\n\t\tvar extEnd = der.offset + der.length;\r\n\t\tder.readSequence();\r\n\r\n\t\twhile (der.offset < extEnd)\r\n\t\t\treadExtension(cert, buf, der);\r\n\r\n\t\tassert.strictEqual(der.offset, extEnd);\r\n\t}\r\n\r\n\tassert.strictEqual(der.offset, sigOffset);\r\n\r\n\tder.readSequence();\r\n\tafter = der.offset + der.length;\r\n\tvar sigAlgOid = der.readOID();\r\n\tvar sigAlg = SIGN_ALGS[sigAlgOid];\r\n\tif (sigAlg === undefined)\r\n\t\tthrow (new Error('unknown signature algorithm ' + sigAlgOid));\r\n\tder._offset = after;\r\n\r\n\tvar sigData = der.readString(asn1.Ber.BitString, true);\r\n\tif (sigData[0] === 0)\r\n\t\tsigData = sigData.slice(1);\r\n\tvar algParts = sigAlg.split('-');\r\n\r\n\tsig.signature = Signature.parse(sigData, algParts[0], 'asn1');\r\n\tsig.signature.hashAlgorithm = algParts[1];\r\n\tsig.algo = sigAlg;\r\n\tsig.cache = buf.slice(tbsStart, tbsEnd);\r\n\r\n\treturn (new Certificate(cert));\r\n}\r\n\r\nfunction readDate(der) {\r\n\tif (der.peek() === asn1.Ber.UTCTime) {\r\n\t\treturn (utcTimeToDate(der.readString(asn1.Ber.UTCTime)));\r\n\t} else if (der.peek() === asn1.Ber.GeneralizedTime) {\r\n\t\treturn (gTimeToDate(der.readString(asn1.Ber.GeneralizedTime)));\r\n\t} else {\r\n\t\tthrow (new Error('Unsupported date format'));\r\n\t}\r\n}\r\n\r\nfunction writeDate(der, date) {\r\n\tif (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {\r\n\t\tder.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);\r\n\t} else {\r\n\t\tder.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);\r\n\t}\r\n}\r\n\r\n/* RFC5280, section 4.2.1.6 (GeneralName type) */\r\nvar ALTNAME = {\r\n\tOtherName: Local(0),\r\n\tRFC822Name: Context(1),\r\n\tDNSName: Context(2),\r\n\tX400Address: Local(3),\r\n\tDirectoryName: Local(4),\r\n\tEDIPartyName: Local(5),\r\n\tURI: Context(6),\r\n\tIPAddress: Context(7),\r\n\tOID: Context(8)\r\n};\r\n\r\n/* RFC5280, section 4.2.1.12 (KeyPurposeId) */\r\nvar EXTPURPOSE = {\r\n\t'serverAuth': '1.3.6.1.5.5.7.3.1',\r\n\t'clientAuth': '1.3.6.1.5.5.7.3.2',\r\n\t'codeSigning': '1.3.6.1.5.5.7.3.3',\r\n\r\n\t/* See https://github.com/joyent/oid-docs/blob/master/root.md */\r\n\t'joyentDocker': '1.3.6.1.4.1.38678.1.4.1',\r\n\t'joyentCmon': '1.3.6.1.4.1.38678.1.4.2'\r\n};\r\nvar EXTPURPOSE_REV = {};\r\nObject.keys(EXTPURPOSE).forEach(function (k) {\r\n\tEXTPURPOSE_REV[EXTPURPOSE[k]] = k;\r\n});\r\n\r\nvar KEYUSEBITS = [\r\n\t'signature', 'identity', 'keyEncryption',\r\n\t'encryption', 'keyAgreement', 'ca', 'crl'\r\n];\r\n\r\nfunction readExtension(cert, buf, der) {\r\n\tder.readSequence();\r\n\tvar after = der.offset + der.length;\r\n\tvar extId = der.readOID();\r\n\tvar id;\r\n\tvar sig = cert.signatures.x509;\r\n\tif (!sig.extras.exts)\r\n\t\tsig.extras.exts = [];\r\n\r\n\tvar critical;\r\n\tif (der.peek() === asn1.Ber.Boolean)\r\n\t\tcritical = der.readBoolean();\r\n\r\n\tswitch (extId) {\r\n\tcase (EXTS.basicConstraints):\r\n\t\tder.readSequence(asn1.Ber.OctetString);\r\n\t\tder.readSequence();\r\n\t\tvar bcEnd = der.offset + der.length;\r\n\t\tvar ca = false;\r\n\t\tif (der.peek() === asn1.Ber.Boolean)\r\n\t\t\tca = der.readBoolean();\r\n\t\tif (cert.purposes === undefined)\r\n\t\t\tcert.purposes = [];\r\n\t\tif (ca === true)\r\n\t\t\tcert.purposes.push('ca');\r\n\t\tvar bc = { oid: extId, critical: critical };\r\n\t\tif (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)\r\n\t\t\tbc.pathLen = der.readInt();\r\n\t\tsig.extras.exts.push(bc);\r\n\t\tbreak;\r\n\tcase (EXTS.extKeyUsage):\r\n\t\tder.readSequence(asn1.Ber.OctetString);\r\n\t\tder.readSequence();\r\n\t\tif (cert.purposes === undefined)\r\n\t\t\tcert.purposes = [];\r\n\t\tvar ekEnd = der.offset + der.length;\r\n\t\twhile (der.offset < ekEnd) {\r\n\t\t\tvar oid = der.readOID();\r\n\t\t\tcert.purposes.push(EXTPURPOSE_REV[oid] || oid);\r\n\t\t}\r\n\t\t/*\r\n\t\t * This is a bit of a hack: in the case where we have a cert\r\n\t\t * that's only allowed to do serverAuth or clientAuth (and not\r\n\t\t * the other), we want to make sure all our Subjects are of\r\n\t\t * the right type. But we already parsed our Subjects and\r\n\t\t * decided if they were hosts or users earlier (since it appears\r\n\t\t * first in the cert).\r\n\t\t *\r\n\t\t * So we go through and mutate them into the right kind here if\r\n\t\t * it doesn't match. This might not be hugely beneficial, as it\r\n\t\t * seems that single-purpose certs are not often seen in the\r\n\t\t * wild.\r\n\t\t */\r\n\t\tif (cert.purposes.indexOf('serverAuth') !== -1 &&\r\n\t\t    cert.purposes.indexOf('clientAuth') === -1) {\r\n\t\t\tcert.subjects.forEach(function (ide) {\r\n\t\t\t\tif (ide.type !== 'host') {\r\n\t\t\t\t\tide.type = 'host';\r\n\t\t\t\t\tide.hostname = ide.uid ||\r\n\t\t\t\t\t    ide.email ||\r\n\t\t\t\t\t    ide.components[0].value;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else if (cert.purposes.indexOf('clientAuth') !== -1 &&\r\n\t\t    cert.purposes.indexOf('serverAuth') === -1) {\r\n\t\t\tcert.subjects.forEach(function (ide) {\r\n\t\t\t\tif (ide.type !== 'user') {\r\n\t\t\t\t\tide.type = 'user';\r\n\t\t\t\t\tide.uid = ide.hostname ||\r\n\t\t\t\t\t    ide.email ||\r\n\t\t\t\t\t    ide.components[0].value;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tsig.extras.exts.push({ oid: extId, critical: critical });\r\n\t\tbreak;\r\n\tcase (EXTS.keyUsage):\r\n\t\tder.readSequence(asn1.Ber.OctetString);\r\n\t\tvar bits = der.readString(asn1.Ber.BitString, true);\r\n\t\tvar setBits = readBitField(bits, KEYUSEBITS);\r\n\t\tsetBits.forEach(function (bit) {\r\n\t\t\tif (cert.purposes === undefined)\r\n\t\t\t\tcert.purposes = [];\r\n\t\t\tif (cert.purposes.indexOf(bit) === -1)\r\n\t\t\t\tcert.purposes.push(bit);\r\n\t\t});\r\n\t\tsig.extras.exts.push({ oid: extId, critical: critical,\r\n\t\t    bits: bits });\r\n\t\tbreak;\r\n\tcase (EXTS.altName):\r\n\t\tder.readSequence(asn1.Ber.OctetString);\r\n\t\tder.readSequence();\r\n\t\tvar aeEnd = der.offset + der.length;\r\n\t\twhile (der.offset < aeEnd) {\r\n\t\t\tswitch (der.peek()) {\r\n\t\t\tcase ALTNAME.OtherName:\r\n\t\t\tcase ALTNAME.EDIPartyName:\r\n\t\t\t\tder.readSequence();\r\n\t\t\t\tder._offset += der.length;\r\n\t\t\t\tbreak;\r\n\t\t\tcase ALTNAME.OID:\r\n\t\t\t\tder.readOID(ALTNAME.OID);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ALTNAME.RFC822Name:\r\n\t\t\t\t/* RFC822 specifies email addresses */\r\n\t\t\t\tvar email = der.readString(ALTNAME.RFC822Name);\r\n\t\t\t\tid = Identity.forEmail(email);\r\n\t\t\t\tif (!cert.subjects[0].equals(id))\r\n\t\t\t\t\tcert.subjects.push(id);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ALTNAME.DirectoryName:\r\n\t\t\t\tder.readSequence(ALTNAME.DirectoryName);\r\n\t\t\t\tid = Identity.parseAsn1(der);\r\n\t\t\t\tif (!cert.subjects[0].equals(id))\r\n\t\t\t\t\tcert.subjects.push(id);\r\n\t\t\t\tbreak;\r\n\t\t\tcase ALTNAME.DNSName:\r\n\t\t\t\tvar host = der.readString(\r\n\t\t\t\t    ALTNAME.DNSName);\r\n\t\t\t\tid = Identity.forHost(host);\r\n\t\t\t\tif (!cert.subjects[0].equals(id))\r\n\t\t\t\t\tcert.subjects.push(id);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tder.readString(der.peek());\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsig.extras.exts.push({ oid: extId, critical: critical });\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tsig.extras.exts.push({\r\n\t\t\toid: extId,\r\n\t\t\tcritical: critical,\r\n\t\t\tdata: der.readString(asn1.Ber.OctetString, true)\r\n\t\t});\r\n\t\tbreak;\r\n\t}\r\n\r\n\tder._offset = after;\r\n}\r\n\r\nvar UTCTIME_RE =\r\n    /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\r\nfunction utcTimeToDate(t) {\r\n\tvar m = t.match(UTCTIME_RE);\r\n\tassert.ok(m, 'timestamps must be in UTC');\r\n\tvar d = new Date();\r\n\r\n\tvar thisYear = d.getUTCFullYear();\r\n\tvar century = Math.floor(thisYear / 100) * 100;\r\n\r\n\tvar year = parseInt(m[1], 10);\r\n\tif (thisYear % 100 < 50 && year >= 60)\r\n\t\tyear += (century - 1);\r\n\telse\r\n\t\tyear += century;\r\n\td.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));\r\n\td.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\r\n\tif (m[6] && m[6].length > 0)\r\n\t\td.setUTCSeconds(parseInt(m[6], 10));\r\n\treturn (d);\r\n}\r\n\r\nvar GTIME_RE =\r\n    /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;\r\nfunction gTimeToDate(t) {\r\n\tvar m = t.match(GTIME_RE);\r\n\tassert.ok(m);\r\n\tvar d = new Date();\r\n\r\n\td.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1,\r\n\t    parseInt(m[3], 10));\r\n\td.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));\r\n\tif (m[6] && m[6].length > 0)\r\n\t\td.setUTCSeconds(parseInt(m[6], 10));\r\n\treturn (d);\r\n}\r\n\r\nfunction zeroPad(n, m) {\r\n\tif (m === undefined)\r\n\t\tm = 2;\r\n\tvar s = '' + n;\r\n\twhile (s.length < m)\r\n\t\ts = '0' + s;\r\n\treturn (s);\r\n}\r\n\r\nfunction dateToUTCTime(d) {\r\n\tvar s = '';\r\n\ts += zeroPad(d.getUTCFullYear() % 100);\r\n\ts += zeroPad(d.getUTCMonth() + 1);\r\n\ts += zeroPad(d.getUTCDate());\r\n\ts += zeroPad(d.getUTCHours());\r\n\ts += zeroPad(d.getUTCMinutes());\r\n\ts += zeroPad(d.getUTCSeconds());\r\n\ts += 'Z';\r\n\treturn (s);\r\n}\r\n\r\nfunction dateToGTime(d) {\r\n\tvar s = '';\r\n\ts += zeroPad(d.getUTCFullYear(), 4);\r\n\ts += zeroPad(d.getUTCMonth() + 1);\r\n\ts += zeroPad(d.getUTCDate());\r\n\ts += zeroPad(d.getUTCHours());\r\n\ts += zeroPad(d.getUTCMinutes());\r\n\ts += zeroPad(d.getUTCSeconds());\r\n\ts += 'Z';\r\n\treturn (s);\r\n}\r\n\r\nfunction sign(cert, key) {\r\n\tif (cert.signatures.x509 === undefined)\r\n\t\tcert.signatures.x509 = {};\r\n\tvar sig = cert.signatures.x509;\r\n\r\n\tsig.algo = key.type + '-' + key.defaultHashAlgorithm();\r\n\tif (SIGN_ALGS[sig.algo] === undefined)\r\n\t\treturn (false);\r\n\r\n\tvar der = new asn1.BerWriter();\r\n\twriteTBSCert(cert, der);\r\n\tvar blob = der.buffer;\r\n\tsig.cache = blob;\r\n\r\n\tvar signer = key.createSign();\r\n\tsigner.write(blob);\r\n\tcert.signatures.x509.signature = signer.sign();\r\n\r\n\treturn (true);\r\n}\r\n\r\nfunction signAsync(cert, signer, done) {\r\n\tif (cert.signatures.x509 === undefined)\r\n\t\tcert.signatures.x509 = {};\r\n\tvar sig = cert.signatures.x509;\r\n\r\n\tvar der = new asn1.BerWriter();\r\n\twriteTBSCert(cert, der);\r\n\tvar blob = der.buffer;\r\n\tsig.cache = blob;\r\n\r\n\tsigner(blob, function (err, signature) {\r\n\t\tif (err) {\r\n\t\t\tdone(err);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsig.algo = signature.type + '-' + signature.hashAlgorithm;\r\n\t\tif (SIGN_ALGS[sig.algo] === undefined) {\r\n\t\t\tdone(new Error('Invalid signing algorithm \"' +\r\n\t\t\t    sig.algo + '\"'));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsig.signature = signature;\r\n\t\tdone();\r\n\t});\r\n}\r\n\r\nfunction write(cert, options) {\r\n\tvar sig = cert.signatures.x509;\r\n\tassert.object(sig, 'x509 signature');\r\n\r\n\tvar der = new asn1.BerWriter();\r\n\tder.startSequence();\r\n\tif (sig.cache) {\r\n\t\tder._ensure(sig.cache.length);\r\n\t\tsig.cache.copy(der._buf, der._offset);\r\n\t\tder._offset += sig.cache.length;\r\n\t} else {\r\n\t\twriteTBSCert(cert, der);\r\n\t}\r\n\r\n\tder.startSequence();\r\n\tder.writeOID(SIGN_ALGS[sig.algo]);\r\n\tif (sig.algo.match(/^rsa-/))\r\n\t\tder.writeNull();\r\n\tder.endSequence();\r\n\r\n\tvar sigData = sig.signature.toBuffer('asn1');\r\n\tvar data = Buffer.alloc(sigData.length + 1);\r\n\tdata[0] = 0;\r\n\tsigData.copy(data, 1);\r\n\tder.writeBuffer(data, asn1.Ber.BitString);\r\n\tder.endSequence();\r\n\r\n\treturn (der.buffer);\r\n}\r\n\r\nfunction writeTBSCert(cert, der) {\r\n\tvar sig = cert.signatures.x509;\r\n\tassert.object(sig, 'x509 signature');\r\n\r\n\tder.startSequence();\r\n\r\n\tder.startSequence(Local(0));\r\n\tder.writeInt(2);\r\n\tder.endSequence();\r\n\r\n\tder.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);\r\n\r\n\tder.startSequence();\r\n\tder.writeOID(SIGN_ALGS[sig.algo]);\r\n\tif (sig.algo.match(/^rsa-/))\r\n\t\tder.writeNull();\r\n\tder.endSequence();\r\n\r\n\tcert.issuer.toAsn1(der);\r\n\r\n\tder.startSequence();\r\n\twriteDate(der, cert.validFrom);\r\n\twriteDate(der, cert.validUntil);\r\n\tder.endSequence();\r\n\r\n\tvar subject = cert.subjects[0];\r\n\tvar altNames = cert.subjects.slice(1);\r\n\tsubject.toAsn1(der);\r\n\r\n\tpkcs8.writePkcs8(der, cert.subjectKey);\r\n\r\n\tif (sig.extras && sig.extras.issuerUniqueID) {\r\n\t\tder.writeBuffer(sig.extras.issuerUniqueID, Local(1));\r\n\t}\r\n\r\n\tif (sig.extras && sig.extras.subjectUniqueID) {\r\n\t\tder.writeBuffer(sig.extras.subjectUniqueID, Local(2));\r\n\t}\r\n\r\n\tif (altNames.length > 0 || subject.type === 'host' ||\r\n\t    (cert.purposes !== undefined && cert.purposes.length > 0) ||\r\n\t    (sig.extras && sig.extras.exts)) {\r\n\t\tder.startSequence(Local(3));\r\n\t\tder.startSequence();\r\n\r\n\t\tvar exts = [];\r\n\t\tif (cert.purposes !== undefined && cert.purposes.length > 0) {\r\n\t\t\texts.push({\r\n\t\t\t\toid: EXTS.basicConstraints,\r\n\t\t\t\tcritical: true\r\n\t\t\t});\r\n\t\t\texts.push({\r\n\t\t\t\toid: EXTS.keyUsage,\r\n\t\t\t\tcritical: true\r\n\t\t\t});\r\n\t\t\texts.push({\r\n\t\t\t\toid: EXTS.extKeyUsage,\r\n\t\t\t\tcritical: true\r\n\t\t\t});\r\n\t\t}\r\n\t\texts.push({ oid: EXTS.altName });\r\n\t\tif (sig.extras && sig.extras.exts)\r\n\t\t\texts = sig.extras.exts;\r\n\r\n\t\tfor (var i = 0; i < exts.length; ++i) {\r\n\t\t\tder.startSequence();\r\n\t\t\tder.writeOID(exts[i].oid);\r\n\r\n\t\t\tif (exts[i].critical !== undefined)\r\n\t\t\t\tder.writeBoolean(exts[i].critical);\r\n\r\n\t\t\tif (exts[i].oid === EXTS.altName) {\r\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\r\n\t\t\t\tder.startSequence();\r\n\t\t\t\tif (subject.type === 'host') {\r\n\t\t\t\t\tder.writeString(subject.hostname,\r\n\t\t\t\t\t    Context(2));\r\n\t\t\t\t}\r\n\t\t\t\tfor (var j = 0; j < altNames.length; ++j) {\r\n\t\t\t\t\tif (altNames[j].type === 'host') {\r\n\t\t\t\t\t\tder.writeString(\r\n\t\t\t\t\t\t    altNames[j].hostname,\r\n\t\t\t\t\t\t    ALTNAME.DNSName);\r\n\t\t\t\t\t} else if (altNames[j].type ===\r\n\t\t\t\t\t    'email') {\r\n\t\t\t\t\t\tder.writeString(\r\n\t\t\t\t\t\t    altNames[j].email,\r\n\t\t\t\t\t\t    ALTNAME.RFC822Name);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t * Encode anything else as a\r\n\t\t\t\t\t\t * DN style name for now.\r\n\t\t\t\t\t\t */\r\n\t\t\t\t\t\tder.startSequence(\r\n\t\t\t\t\t\t    ALTNAME.DirectoryName);\r\n\t\t\t\t\t\taltNames[j].toAsn1(der);\r\n\t\t\t\t\t\tder.endSequence();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tder.endSequence();\r\n\t\t\t\tder.endSequence();\r\n\t\t\t} else if (exts[i].oid === EXTS.basicConstraints) {\r\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\r\n\t\t\t\tder.startSequence();\r\n\t\t\t\tvar ca = (cert.purposes.indexOf('ca') !== -1);\r\n\t\t\t\tvar pathLen = exts[i].pathLen;\r\n\t\t\t\tder.writeBoolean(ca);\r\n\t\t\t\tif (pathLen !== undefined)\r\n\t\t\t\t\tder.writeInt(pathLen);\r\n\t\t\t\tder.endSequence();\r\n\t\t\t\tder.endSequence();\r\n\t\t\t} else if (exts[i].oid === EXTS.extKeyUsage) {\r\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\r\n\t\t\t\tder.startSequence();\r\n\t\t\t\tcert.purposes.forEach(function (purpose) {\r\n\t\t\t\t\tif (purpose === 'ca')\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tif (KEYUSEBITS.indexOf(purpose) !== -1)\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tvar oid = purpose;\r\n\t\t\t\t\tif (EXTPURPOSE[purpose] !== undefined)\r\n\t\t\t\t\t\toid = EXTPURPOSE[purpose];\r\n\t\t\t\t\tder.writeOID(oid);\r\n\t\t\t\t});\r\n\t\t\t\tder.endSequence();\r\n\t\t\t\tder.endSequence();\r\n\t\t\t} else if (exts[i].oid === EXTS.keyUsage) {\r\n\t\t\t\tder.startSequence(asn1.Ber.OctetString);\r\n\t\t\t\t/*\r\n\t\t\t\t * If we parsed this certificate from a byte\r\n\t\t\t\t * stream (i.e. we didn't generate it in sshpk)\r\n\t\t\t\t * then we'll have a \".bits\" property on the\r\n\t\t\t\t * ext with the original raw byte contents.\r\n\t\t\t\t *\r\n\t\t\t\t * If we have this, use it here instead of\r\n\t\t\t\t * regenerating it. This guarantees we output\r\n\t\t\t\t * the same data we parsed, so signatures still\r\n\t\t\t\t * validate.\r\n\t\t\t\t */\r\n\t\t\t\tif (exts[i].bits !== undefined) {\r\n\t\t\t\t\tder.writeBuffer(exts[i].bits,\r\n\t\t\t\t\t    asn1.Ber.BitString);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar bits = writeBitField(cert.purposes,\r\n\t\t\t\t\t    KEYUSEBITS);\r\n\t\t\t\t\tder.writeBuffer(bits,\r\n\t\t\t\t\t    asn1.Ber.BitString);\r\n\t\t\t\t}\r\n\t\t\t\tder.endSequence();\r\n\t\t\t} else {\r\n\t\t\t\tder.writeBuffer(exts[i].data,\r\n\t\t\t\t    asn1.Ber.OctetString);\r\n\t\t\t}\r\n\r\n\t\t\tder.endSequence();\r\n\t\t}\r\n\r\n\t\tder.endSequence();\r\n\t\tder.endSequence();\r\n\t}\r\n\r\n\tder.endSequence();\r\n}\r\n\r\n/*\r\n * Reads an ASN.1 BER bitfield out of the Buffer produced by doing\r\n * `BerReader#readString(asn1.Ber.BitString)`. That function gives us the raw\r\n * contents of the BitString tag, which is a count of unused bits followed by\r\n * the bits as a right-padded byte string.\r\n *\r\n * `bits` is the Buffer, `bitIndex` should contain an array of string names\r\n * for the bits in the string, ordered starting with bit #0 in the ASN.1 spec.\r\n *\r\n * Returns an array of Strings, the names of the bits that were set to 1.\r\n */\r\nfunction readBitField(bits, bitIndex) {\r\n\tvar bitLen = 8 * (bits.length - 1) - bits[0];\r\n\tvar setBits = {};\r\n\tfor (var i = 0; i < bitLen; ++i) {\r\n\t\tvar byteN = 1 + Math.floor(i / 8);\r\n\t\tvar bit = 7 - (i % 8);\r\n\t\tvar mask = 1 << bit;\r\n\t\tvar bitVal = ((bits[byteN] & mask) !== 0);\r\n\t\tvar name = bitIndex[i];\r\n\t\tif (bitVal && typeof (name) === 'string') {\r\n\t\t\tsetBits[name] = true;\r\n\t\t}\r\n\t}\r\n\treturn (Object.keys(setBits));\r\n}\r\n\r\n/*\r\n * `setBits` is an array of strings, containing the names for each bit that\r\n * sould be set to 1. `bitIndex` is same as in `readBitField()`.\r\n *\r\n * Returns a Buffer, ready to be written out with `BerWriter#writeString()`.\r\n */\r\nfunction writeBitField(setBits, bitIndex) {\r\n\tvar bitLen = bitIndex.length;\r\n\tvar blen = Math.ceil(bitLen / 8);\r\n\tvar unused = blen * 8 - bitLen;\r\n\tvar bits = Buffer.alloc(1 + blen); // zero-filled\r\n\tbits[0] = unused;\r\n\tfor (var i = 0; i < bitLen; ++i) {\r\n\t\tvar byteN = 1 + Math.floor(i / 8);\r\n\t\tvar bit = 7 - (i % 8);\r\n\t\tvar mask = 1 << bit;\r\n\t\tvar name = bitIndex[i];\r\n\t\tif (name === undefined)\r\n\t\t\tcontinue;\r\n\t\tvar bitVal = (setBits.indexOf(name) !== -1);\r\n\t\tif (bitVal) {\r\n\t\t\tbits[byteN] |= mask;\r\n\t\t}\r\n\t}\r\n\treturn (bits);\r\n}\r\n","// Copyright 2016 Joyent, Inc.\r\n\r\nvar x509 = require('./x509');\r\n\r\nmodule.exports = {\r\n\tread: read,\r\n\tverify: x509.verify,\r\n\tsign: x509.sign,\r\n\twrite: write\r\n};\r\n\r\nvar assert = require('assert-plus');\r\nvar asn1 = require('asn1');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar algs = require('../algs');\r\nvar utils = require('../utils');\r\nvar Key = require('../key');\r\nvar PrivateKey = require('../private-key');\r\nvar pem = require('./pem');\r\nvar Identity = require('../identity');\r\nvar Signature = require('../signature');\r\nvar Certificate = require('../certificate');\r\n\r\nfunction read(buf, options) {\r\n\tif (typeof (buf) !== 'string') {\r\n\t\tassert.buffer(buf, 'buf');\r\n\t\tbuf = buf.toString('ascii');\r\n\t}\r\n\r\n\tvar lines = buf.trim().split(/[\\r\\n]+/g);\r\n\r\n\tvar m;\r\n\tvar si = -1;\r\n\twhile (!m && si < lines.length) {\r\n\t\tm = lines[++si].match(/*JSSTYLED*/\r\n\t\t    /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);\r\n\t}\r\n\tassert.ok(m, 'invalid PEM header');\r\n\r\n\tvar m2;\r\n\tvar ei = lines.length;\r\n\twhile (!m2 && ei > 0) {\r\n\t\tm2 = lines[--ei].match(/*JSSTYLED*/\r\n\t\t    /[-]+[ ]*END CERTIFICATE[ ]*[-]+/);\r\n\t}\r\n\tassert.ok(m2, 'invalid PEM footer');\r\n\r\n\tlines = lines.slice(si, ei + 1);\r\n\r\n\tvar headers = {};\r\n\twhile (true) {\r\n\t\tlines = lines.slice(1);\r\n\t\tm = lines[0].match(/*JSSTYLED*/\r\n\t\t    /^([A-Za-z0-9-]+): (.+)$/);\r\n\t\tif (!m)\r\n\t\t\tbreak;\r\n\t\theaders[m[1].toLowerCase()] = m[2];\r\n\t}\r\n\r\n\t/* Chop off the first and last lines */\r\n\tlines = lines.slice(0, -1).join('');\r\n\tbuf = Buffer.from(lines, 'base64');\r\n\r\n\treturn (x509.read(buf, options));\r\n}\r\n\r\nfunction write(cert, options) {\r\n\tvar dbuf = x509.write(cert, options);\r\n\r\n\tvar header = 'CERTIFICATE';\r\n\tvar tmp = dbuf.toString('base64');\r\n\tvar len = tmp.length + (tmp.length / 64) +\r\n\t    18 + 16 + header.length*2 + 10;\r\n\tvar buf = Buffer.alloc(len);\r\n\tvar o = 0;\r\n\to += buf.write('-----BEGIN ' + header + '-----\\n', o);\r\n\tfor (var i = 0; i < tmp.length; ) {\r\n\t\tvar limit = i + 64;\r\n\t\tif (limit > tmp.length)\r\n\t\t\tlimit = tmp.length;\r\n\t\to += buf.write(tmp.slice(i, limit), o);\r\n\t\tbuf[o++] = 10;\r\n\t\ti = limit;\r\n\t}\r\n\to += buf.write('-----END ' + header + '-----\\n', o);\r\n\r\n\treturn (buf.slice(0, o));\r\n}\r\n"]}