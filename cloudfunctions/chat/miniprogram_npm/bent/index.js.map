{"version":3,"sources":["nodejs.js","core.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nconst http = require('http')\r\nconst https = require('https')\r\nconst { URL } = require('url')\r\nconst isStream = require('is-stream')\r\nconst caseless = require('caseless')\r\nconst bytes = require('bytesish')\r\nconst bent = require('./core')\r\nconst zlib = require('zlib')\r\nconst { PassThrough } = require('stream')\r\n\r\nconst compression = {}\r\n\r\n/* istanbul ignore else */\r\nif (zlib.createBrotliDecompress) compression.br = () => zlib.createBrotliDecompress()\r\n/* istanbul ignore else */\r\nif (zlib.createGunzip) compression.gzip = () => zlib.createGunzip()\r\n/* istanbul ignore else */\r\nif (zlib.createInflate) compression.deflate = () => zlib.createInflate()\r\n\r\nconst acceptEncoding = Object.keys(compression).join(', ')\r\n\r\nconst getResponse = resp => {\r\n  const ret = new PassThrough()\r\n  ret.statusCode = resp.statusCode\r\n  ret.status = resp.statusCode\r\n  ret.statusMessage = resp.statusMessage\r\n  ret.headers = resp.headers\r\n  ret._response = resp\r\n  if (ret.headers['content-encoding']) {\r\n    const encodings = ret.headers['content-encoding'].split(', ').reverse()\r\n    while (encodings.length) {\r\n      const enc = encodings.shift()\r\n      if (compression[enc]) {\r\n        const decompress = compression[enc]()\r\n        decompress.on('error', (e) => ret.emit('error', new Error('ZBufError', e)))\r\n        resp = resp.pipe(decompress)\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n  }\r\n  return resp.pipe(ret)\r\n}\r\n\r\nclass StatusError extends Error {\r\n  constructor (res, ...params) {\r\n    super(...params)\r\n\r\n    Error.captureStackTrace(this, StatusError)\r\n    this.name = 'StatusError'\r\n    this.message = res.statusMessage\r\n    this.statusCode = res.statusCode\r\n    this.json = res.json\r\n    this.text = res.text\r\n    this.arrayBuffer = res.arrayBuffer\r\n    this.headers = res.headers\r\n    let buffer\r\n    const get = () => {\r\n      if (!buffer) buffer = this.arrayBuffer()\r\n      return buffer\r\n    }\r\n    Object.defineProperty(this, 'responseBody', { get })\r\n  }\r\n}\r\n\r\nconst getBuffer = stream => new Promise((resolve, reject) => {\r\n  const parts = []\r\n  stream.on('error', reject)\r\n  stream.on('end', () => resolve(Buffer.concat(parts)))\r\n  stream.on('data', d => parts.push(d))\r\n})\r\n\r\nconst decodings = res => {\r\n  let _buffer\r\n  res.arrayBuffer = () => {\r\n    if (!_buffer) {\r\n      _buffer = getBuffer(res)\r\n      return _buffer\r\n    } else {\r\n      throw new Error('body stream is locked')\r\n    }\r\n  }\r\n  res.text = () => res.arrayBuffer().then(buff => buff.toString())\r\n  res.json = async () => {\r\n    const str = await res.text()\r\n    try {\r\n      return JSON.parse(str)\r\n    } catch (e) {\r\n      e.message += `str\"${str}\"`\r\n      throw e\r\n    }\r\n  }\r\n}\r\n\r\nconst mkrequest = (statusCodes, method, encoding, headers, baseurl) => (_url, body = null, _headers = {}) => {\r\n  _url = baseurl + (_url || '')\r\n  const parsed = new URL(_url)\r\n  let h\r\n  if (parsed.protocol === 'https:') {\r\n    h = https\r\n  } else if (parsed.protocol === 'http:') {\r\n    h = http\r\n  } else {\r\n    throw new Error(`Unknown protocol, ${parsed.protocol}`)\r\n  }\r\n  const request = {\r\n    path: parsed.pathname + parsed.search,\r\n    port: parsed.port,\r\n    method: method,\r\n    headers: { ...(headers || {}), ..._headers },\r\n    hostname: parsed.hostname\r\n  }\r\n  if (parsed.username || parsed.password) {\r\n    request.auth = [parsed.username, parsed.password].join(':')\r\n  }\r\n  const c = caseless(request.headers)\r\n  if (encoding === 'json') {\r\n    if (!c.get('accept')) {\r\n      c.set('accept', 'application/json')\r\n    }\r\n  }\r\n  if (!c.has('accept-encoding')) {\r\n    c.set('accept-encoding', acceptEncoding)\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    const req = h.request(request, async res => {\r\n      res = getResponse(res)\r\n      res.on('error', reject)\r\n      decodings(res)\r\n      res.status = res.statusCode\r\n      if (!statusCodes.has(res.statusCode)) {\r\n        return reject(new StatusError(res))\r\n      }\r\n\r\n      if (!encoding) return resolve(res)\r\n      else {\r\n        /* istanbul ignore else */\r\n        if (encoding === 'buffer') {\r\n          resolve(res.arrayBuffer())\r\n        } else if (encoding === 'json') {\r\n          resolve(res.json())\r\n        } else if (encoding === 'string') {\r\n          resolve(res.text())\r\n        }\r\n      }\r\n    })\r\n    req.on('error', reject)\r\n    if (body) {\r\n      if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\r\n        body = bytes.native(body)\r\n      }\r\n      if (Buffer.isBuffer(body)) {\r\n        // noop\r\n      } else if (typeof body === 'string') {\r\n        body = Buffer.from(body)\r\n      } else if (isStream(body)) {\r\n        body.pipe(req)\r\n        body = null\r\n      } else if (typeof body === 'object') {\r\n        if (!c.has('content-type')) {\r\n          req.setHeader('content-type', 'application/json')\r\n        }\r\n        body = Buffer.from(JSON.stringify(body))\r\n      } else {\r\n        reject(new Error('Unknown body type.'))\r\n      }\r\n      if (body) {\r\n        req.setHeader('content-length', body.length)\r\n        req.end(body)\r\n      }\r\n    } else {\r\n      req.end()\r\n    }\r\n  })\r\n}\r\n\r\nmodule.exports = bent(mkrequest)\r\n","\r\nconst encodings = new Set(['json', 'buffer', 'string'])\r\n\r\nmodule.exports = mkrequest => (...args) => {\r\n  const statusCodes = new Set()\r\n  let method\r\n  let encoding\r\n  let headers\r\n  let baseurl = ''\r\n\r\n  args.forEach(arg => {\r\n    if (typeof arg === 'string') {\r\n      if (arg.toUpperCase() === arg) {\r\n        if (method) {\r\n          const msg = `Can't set method to ${arg}, already set to ${method}.`\r\n          throw new Error(msg)\r\n        } else {\r\n          method = arg\r\n        }\r\n      } else if (arg.startsWith('http:') || arg.startsWith('https:')) {\r\n        baseurl = arg\r\n      } else {\r\n        if (encodings.has(arg)) {\r\n          encoding = arg\r\n        } else {\r\n          throw new Error(`Unknown encoding, ${arg}`)\r\n        }\r\n      }\r\n    } else if (typeof arg === 'number') {\r\n      statusCodes.add(arg)\r\n    } else if (typeof arg === 'object') {\r\n      if (Array.isArray(arg) || arg instanceof Set) {\r\n        arg.forEach(code => statusCodes.add(code))\r\n      } else {\r\n        if (headers) {\r\n          throw new Error('Cannot set headers twice.')\r\n        }\r\n        headers = arg\r\n      }\r\n    } else {\r\n      throw new Error(`Unknown type: ${typeof arg}`)\r\n    }\r\n  })\r\n\r\n  if (!method) method = 'GET'\r\n  if (statusCodes.size === 0) {\r\n    statusCodes.add(200)\r\n  }\r\n\r\n  return mkrequest(statusCodes, method, encoding, headers, baseurl)\r\n}\r\n"]}