{"version":3,"sources":["cookie.js","pubsuffix-psl.js","store.js","memstore.js","permuteDomain.js","pathMatch.js","version.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AFOA,AGTA,ACHA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA,AIZA;ANmBA,AGTA,AENA,ADGA,AHSA,ACHA,AIZA;ANmBA,AGTA,AENA,ADGA,AHSA,ACHA,AIZA;ANmBA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AHSA,ACHA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,ADGA,AFMA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA,ADGA;AFOA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\r\n * Copyright (c) 2015, Salesforce.com, Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n * this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n * this list of conditions and the following disclaimer in the documentation\r\n * and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\r\n * be used to endorse or promote products derived from this software without\r\n * specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar net = require('net');\r\nvar urlParse = require('url').parse;\r\nvar util = require('util');\r\nvar pubsuffix = require('./pubsuffix-psl');\r\nvar Store = require('./store').Store;\r\nvar MemoryCookieStore = require('./memstore').MemoryCookieStore;\r\nvar pathMatch = require('./pathMatch').pathMatch;\r\nvar VERSION = require('./version');\r\n\r\nvar punycode;\r\ntry {\r\n  punycode = require('punycode');\r\n} catch(e) {\r\n  console.warn(\"tough-cookie: can't load punycode; won't use punycode for domain normalization\");\r\n}\r\n\r\n// From RFC6265 S4.1.1\r\n// note that it excludes \\x3B \";\"\r\nvar COOKIE_OCTETS = /^[\\x21\\x23-\\x2B\\x2D-\\x3A\\x3C-\\x5B\\x5D-\\x7E]+$/;\r\n\r\nvar CONTROL_CHARS = /[\\x00-\\x1F]/;\r\n\r\n// From Chromium // '\\r', '\\n' and '\\0' should be treated as a terminator in\r\n// the \"relaxed\" mode, see:\r\n// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60\r\nvar TERMINATORS = ['\\n', '\\r', '\\0'];\r\n\r\n// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or \";\"'\r\n// Note ';' is \\x3B\r\nvar PATH_VALUE = /[\\x20-\\x3A\\x3C-\\x7E]+/;\r\n\r\n// date-time parsing constants (RFC6265 S5.1.1)\r\n\r\nvar DATE_DELIM = /[\\x09\\x20-\\x2F\\x3B-\\x40\\x5B-\\x60\\x7B-\\x7E]/;\r\n\r\nvar MONTH_TO_NUM = {\r\n  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,\r\n  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11\r\n};\r\nvar NUM_TO_MONTH = [\r\n  'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'\r\n];\r\nvar NUM_TO_DAY = [\r\n  'Sun','Mon','Tue','Wed','Thu','Fri','Sat'\r\n];\r\n\r\nvar MAX_TIME = 2147483647000; // 31-bit max\r\nvar MIN_TIME = 0; // 31-bit min\r\n\r\n/*\r\n * Parses a Natural number (i.e., non-negative integer) with either the\r\n *    <min>*<max>DIGIT ( non-digit *OCTET )\r\n * or\r\n *    <min>*<max>DIGIT\r\n * grammar (RFC6265 S5.1.1).\r\n *\r\n * The \"trailingOK\" boolean controls if the grammar accepts a\r\n * \"( non-digit *OCTET )\" trailer.\r\n */\r\nfunction parseDigits(token, minDigits, maxDigits, trailingOK) {\r\n  var count = 0;\r\n  while (count < token.length) {\r\n    var c = token.charCodeAt(count);\r\n    // \"non-digit = %x00-2F / %x3A-FF\"\r\n    if (c <= 0x2F || c >= 0x3A) {\r\n      break;\r\n    }\r\n    count++;\r\n  }\r\n\r\n  // constrain to a minimum and maximum number of digits.\r\n  if (count < minDigits || count > maxDigits) {\r\n    return null;\r\n  }\r\n\r\n  if (!trailingOK && count != token.length) {\r\n    return null;\r\n  }\r\n\r\n  return parseInt(token.substr(0,count), 10);\r\n}\r\n\r\nfunction parseTime(token) {\r\n  var parts = token.split(':');\r\n  var result = [0,0,0];\r\n\r\n  /* RF6256 S5.1.1:\r\n   *      time            = hms-time ( non-digit *OCTET )\r\n   *      hms-time        = time-field \":\" time-field \":\" time-field\r\n   *      time-field      = 1*2DIGIT\r\n   */\r\n\r\n  if (parts.length !== 3) {\r\n    return null;\r\n  }\r\n\r\n  for (var i = 0; i < 3; i++) {\r\n    // \"time-field\" must be strictly \"1*2DIGIT\", HOWEVER, \"hms-time\" can be\r\n    // followed by \"( non-digit *OCTET )\" so therefore the last time-field can\r\n    // have a trailer\r\n    var trailingOK = (i == 2);\r\n    var num = parseDigits(parts[i], 1, 2, trailingOK);\r\n    if (num === null) {\r\n      return null;\r\n    }\r\n    result[i] = num;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction parseMonth(token) {\r\n  token = String(token).substr(0,3).toLowerCase();\r\n  var num = MONTH_TO_NUM[token];\r\n  return num >= 0 ? num : null;\r\n}\r\n\r\n/*\r\n * RFC6265 S5.1.1 date parser (see RFC for full grammar)\r\n */\r\nfunction parseDate(str) {\r\n  if (!str) {\r\n    return;\r\n  }\r\n\r\n  /* RFC6265 S5.1.1:\r\n   * 2. Process each date-token sequentially in the order the date-tokens\r\n   * appear in the cookie-date\r\n   */\r\n  var tokens = str.split(DATE_DELIM);\r\n  if (!tokens) {\r\n    return;\r\n  }\r\n\r\n  var hour = null;\r\n  var minute = null;\r\n  var second = null;\r\n  var dayOfMonth = null;\r\n  var month = null;\r\n  var year = null;\r\n\r\n  for (var i=0; i<tokens.length; i++) {\r\n    var token = tokens[i].trim();\r\n    if (!token.length) {\r\n      continue;\r\n    }\r\n\r\n    var result;\r\n\r\n    /* 2.1. If the found-time flag is not set and the token matches the time\r\n     * production, set the found-time flag and set the hour- value,\r\n     * minute-value, and second-value to the numbers denoted by the digits in\r\n     * the date-token, respectively.  Skip the remaining sub-steps and continue\r\n     * to the next date-token.\r\n     */\r\n    if (second === null) {\r\n      result = parseTime(token);\r\n      if (result) {\r\n        hour = result[0];\r\n        minute = result[1];\r\n        second = result[2];\r\n        continue;\r\n      }\r\n    }\r\n\r\n    /* 2.2. If the found-day-of-month flag is not set and the date-token matches\r\n     * the day-of-month production, set the found-day-of- month flag and set\r\n     * the day-of-month-value to the number denoted by the date-token.  Skip\r\n     * the remaining sub-steps and continue to the next date-token.\r\n     */\r\n    if (dayOfMonth === null) {\r\n      // \"day-of-month = 1*2DIGIT ( non-digit *OCTET )\"\r\n      result = parseDigits(token, 1, 2, true);\r\n      if (result !== null) {\r\n        dayOfMonth = result;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    /* 2.3. If the found-month flag is not set and the date-token matches the\r\n     * month production, set the found-month flag and set the month-value to\r\n     * the month denoted by the date-token.  Skip the remaining sub-steps and\r\n     * continue to the next date-token.\r\n     */\r\n    if (month === null) {\r\n      result = parseMonth(token);\r\n      if (result !== null) {\r\n        month = result;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    /* 2.4. If the found-year flag is not set and the date-token matches the\r\n     * year production, set the found-year flag and set the year-value to the\r\n     * number denoted by the date-token.  Skip the remaining sub-steps and\r\n     * continue to the next date-token.\r\n     */\r\n    if (year === null) {\r\n      // \"year = 2*4DIGIT ( non-digit *OCTET )\"\r\n      result = parseDigits(token, 2, 4, true);\r\n      if (result !== null) {\r\n        year = result;\r\n        /* From S5.1.1:\r\n         * 3.  If the year-value is greater than or equal to 70 and less\r\n         * than or equal to 99, increment the year-value by 1900.\r\n         * 4.  If the year-value is greater than or equal to 0 and less\r\n         * than or equal to 69, increment the year-value by 2000.\r\n         */\r\n        if (year >= 70 && year <= 99) {\r\n          year += 1900;\r\n        } else if (year >= 0 && year <= 69) {\r\n          year += 2000;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* RFC 6265 S5.1.1\r\n   * \"5. Abort these steps and fail to parse the cookie-date if:\r\n   *     *  at least one of the found-day-of-month, found-month, found-\r\n   *        year, or found-time flags is not set,\r\n   *     *  the day-of-month-value is less than 1 or greater than 31,\r\n   *     *  the year-value is less than 1601,\r\n   *     *  the hour-value is greater than 23,\r\n   *     *  the minute-value is greater than 59, or\r\n   *     *  the second-value is greater than 59.\r\n   *     (Note that leap seconds cannot be represented in this syntax.)\"\r\n   *\r\n   * So, in order as above:\r\n   */\r\n  if (\r\n    dayOfMonth === null || month === null || year === null || second === null ||\r\n    dayOfMonth < 1 || dayOfMonth > 31 ||\r\n    year < 1601 ||\r\n    hour > 23 ||\r\n    minute > 59 ||\r\n    second > 59\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));\r\n}\r\n\r\nfunction formatDate(date) {\r\n  var d = date.getUTCDate(); d = d >= 10 ? d : '0'+d;\r\n  var h = date.getUTCHours(); h = h >= 10 ? h : '0'+h;\r\n  var m = date.getUTCMinutes(); m = m >= 10 ? m : '0'+m;\r\n  var s = date.getUTCSeconds(); s = s >= 10 ? s : '0'+s;\r\n  return NUM_TO_DAY[date.getUTCDay()] + ', ' +\r\n    d+' '+ NUM_TO_MONTH[date.getUTCMonth()] +' '+ date.getUTCFullYear() +' '+\r\n    h+':'+m+':'+s+' GMT';\r\n}\r\n\r\n// S5.1.2 Canonicalized Host Names\r\nfunction canonicalDomain(str) {\r\n  if (str == null) {\r\n    return null;\r\n  }\r\n  str = str.trim().replace(/^\\./,''); // S4.1.2.3 & S5.2.3: ignore leading .\r\n\r\n  // convert to IDN if any non-ASCII characters\r\n  if (punycode && /[^\\u0001-\\u007f]/.test(str)) {\r\n    str = punycode.toASCII(str);\r\n  }\r\n\r\n  return str.toLowerCase();\r\n}\r\n\r\n// S5.1.3 Domain Matching\r\nfunction domainMatch(str, domStr, canonicalize) {\r\n  if (str == null || domStr == null) {\r\n    return null;\r\n  }\r\n  if (canonicalize !== false) {\r\n    str = canonicalDomain(str);\r\n    domStr = canonicalDomain(domStr);\r\n  }\r\n\r\n  /*\r\n   * \"The domain string and the string are identical. (Note that both the\r\n   * domain string and the string will have been canonicalized to lower case at\r\n   * this point)\"\r\n   */\r\n  if (str == domStr) {\r\n    return true;\r\n  }\r\n\r\n  /* \"All of the following [three] conditions hold:\" (order adjusted from the RFC) */\r\n\r\n  /* \"* The string is a host name (i.e., not an IP address).\" */\r\n  if (net.isIP(str)) {\r\n    return false;\r\n  }\r\n\r\n  /* \"* The domain string is a suffix of the string\" */\r\n  var idx = str.indexOf(domStr);\r\n  if (idx <= 0) {\r\n    return false; // it's a non-match (-1) or prefix (0)\r\n  }\r\n\r\n  // e.g \"a.b.c\".indexOf(\"b.c\") === 2\r\n  // 5 === 3+2\r\n  if (str.length !== domStr.length + idx) { // it's not a suffix\r\n    return false;\r\n  }\r\n\r\n  /* \"* The last character of the string that is not included in the domain\r\n  * string is a %x2E (\".\") character.\" */\r\n  if (str.substr(idx-1,1) !== '.') {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n\r\n// RFC6265 S5.1.4 Paths and Path-Match\r\n\r\n/*\r\n * \"The user agent MUST use an algorithm equivalent to the following algorithm\r\n * to compute the default-path of a cookie:\"\r\n *\r\n * Assumption: the path (and not query part or absolute uri) is passed in.\r\n */\r\nfunction defaultPath(path) {\r\n  // \"2. If the uri-path is empty or if the first character of the uri-path is not\r\n  // a %x2F (\"/\") character, output %x2F (\"/\") and skip the remaining steps.\r\n  if (!path || path.substr(0,1) !== \"/\") {\r\n    return \"/\";\r\n  }\r\n\r\n  // \"3. If the uri-path contains no more than one %x2F (\"/\") character, output\r\n  // %x2F (\"/\") and skip the remaining step.\"\r\n  if (path === \"/\") {\r\n    return path;\r\n  }\r\n\r\n  var rightSlash = path.lastIndexOf(\"/\");\r\n  if (rightSlash === 0) {\r\n    return \"/\";\r\n  }\r\n\r\n  // \"4. Output the characters of the uri-path from the first character up to,\r\n  // but not including, the right-most %x2F (\"/\").\"\r\n  return path.slice(0, rightSlash);\r\n}\r\n\r\nfunction trimTerminator(str) {\r\n  for (var t = 0; t < TERMINATORS.length; t++) {\r\n    var terminatorIdx = str.indexOf(TERMINATORS[t]);\r\n    if (terminatorIdx !== -1) {\r\n      str = str.substr(0,terminatorIdx);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\nfunction parseCookiePair(cookiePair, looseMode) {\r\n  cookiePair = trimTerminator(cookiePair);\r\n\r\n  var firstEq = cookiePair.indexOf('=');\r\n  if (looseMode) {\r\n    if (firstEq === 0) { // '=' is immediately at start\r\n      cookiePair = cookiePair.substr(1);\r\n      firstEq = cookiePair.indexOf('='); // might still need to split on '='\r\n    }\r\n  } else { // non-loose mode\r\n    if (firstEq <= 0) { // no '=' or is at start\r\n      return; // needs to have non-empty \"cookie-name\"\r\n    }\r\n  }\r\n\r\n  var cookieName, cookieValue;\r\n  if (firstEq <= 0) {\r\n    cookieName = \"\";\r\n    cookieValue = cookiePair.trim();\r\n  } else {\r\n    cookieName = cookiePair.substr(0, firstEq).trim();\r\n    cookieValue = cookiePair.substr(firstEq+1).trim();\r\n  }\r\n\r\n  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {\r\n    return;\r\n  }\r\n\r\n  var c = new Cookie();\r\n  c.key = cookieName;\r\n  c.value = cookieValue;\r\n  return c;\r\n}\r\n\r\nfunction parse(str, options) {\r\n  if (!options || typeof options !== 'object') {\r\n    options = {};\r\n  }\r\n  str = str.trim();\r\n\r\n  // We use a regex to parse the \"name-value-pair\" part of S5.2\r\n  var firstSemi = str.indexOf(';'); // S5.2 step 1\r\n  var cookiePair = (firstSemi === -1) ? str : str.substr(0, firstSemi);\r\n  var c = parseCookiePair(cookiePair, !!options.loose);\r\n  if (!c) {\r\n    return;\r\n  }\r\n\r\n  if (firstSemi === -1) {\r\n    return c;\r\n  }\r\n\r\n  // S5.2.3 \"unparsed-attributes consist of the remainder of the set-cookie-string\r\n  // (including the %x3B (\";\") in question).\" plus later on in the same section\r\n  // \"discard the first \";\" and trim\".\r\n  var unparsed = str.slice(firstSemi + 1).trim();\r\n\r\n  // \"If the unparsed-attributes string is empty, skip the rest of these\r\n  // steps.\"\r\n  if (unparsed.length === 0) {\r\n    return c;\r\n  }\r\n\r\n  /*\r\n   * S5.2 says that when looping over the items \"[p]rocess the attribute-name\r\n   * and attribute-value according to the requirements in the following\r\n   * subsections\" for every item.  Plus, for many of the individual attributes\r\n   * in S5.3 it says to use the \"attribute-value of the last attribute in the\r\n   * cookie-attribute-list\".  Therefore, in this implementation, we overwrite\r\n   * the previous value.\r\n   */\r\n  var cookie_avs = unparsed.split(';');\r\n  while (cookie_avs.length) {\r\n    var av = cookie_avs.shift().trim();\r\n    if (av.length === 0) { // happens if \";;\" appears\r\n      continue;\r\n    }\r\n    var av_sep = av.indexOf('=');\r\n    var av_key, av_value;\r\n\r\n    if (av_sep === -1) {\r\n      av_key = av;\r\n      av_value = null;\r\n    } else {\r\n      av_key = av.substr(0,av_sep);\r\n      av_value = av.substr(av_sep+1);\r\n    }\r\n\r\n    av_key = av_key.trim().toLowerCase();\r\n\r\n    if (av_value) {\r\n      av_value = av_value.trim();\r\n    }\r\n\r\n    switch(av_key) {\r\n    case 'expires': // S5.2.1\r\n      if (av_value) {\r\n        var exp = parseDate(av_value);\r\n        // \"If the attribute-value failed to parse as a cookie date, ignore the\r\n        // cookie-av.\"\r\n        if (exp) {\r\n          // over and underflow not realistically a concern: V8's getTime() seems to\r\n          // store something larger than a 32-bit time_t (even with 32-bit node)\r\n          c.expires = exp;\r\n        }\r\n      }\r\n      break;\r\n\r\n    case 'max-age': // S5.2.2\r\n      if (av_value) {\r\n        // \"If the first character of the attribute-value is not a DIGIT or a \"-\"\r\n        // character ...[or]... If the remainder of attribute-value contains a\r\n        // non-DIGIT character, ignore the cookie-av.\"\r\n        if (/^-?[0-9]+$/.test(av_value)) {\r\n          var delta = parseInt(av_value, 10);\r\n          // \"If delta-seconds is less than or equal to zero (0), let expiry-time\r\n          // be the earliest representable date and time.\"\r\n          c.setMaxAge(delta);\r\n        }\r\n      }\r\n      break;\r\n\r\n    case 'domain': // S5.2.3\r\n      // \"If the attribute-value is empty, the behavior is undefined.  However,\r\n      // the user agent SHOULD ignore the cookie-av entirely.\"\r\n      if (av_value) {\r\n        // S5.2.3 \"Let cookie-domain be the attribute-value without the leading %x2E\r\n        // (\".\") character.\"\r\n        var domain = av_value.trim().replace(/^\\./, '');\r\n        if (domain) {\r\n          // \"Convert the cookie-domain to lower case.\"\r\n          c.domain = domain.toLowerCase();\r\n        }\r\n      }\r\n      break;\r\n\r\n    case 'path': // S5.2.4\r\n      /*\r\n       * \"If the attribute-value is empty or if the first character of the\r\n       * attribute-value is not %x2F (\"/\"):\r\n       *   Let cookie-path be the default-path.\r\n       * Otherwise:\r\n       *   Let cookie-path be the attribute-value.\"\r\n       *\r\n       * We'll represent the default-path as null since it depends on the\r\n       * context of the parsing.\r\n       */\r\n      c.path = av_value && av_value[0] === \"/\" ? av_value : null;\r\n      break;\r\n\r\n    case 'secure': // S5.2.5\r\n      /*\r\n       * \"If the attribute-name case-insensitively matches the string \"Secure\",\r\n       * the user agent MUST append an attribute to the cookie-attribute-list\r\n       * with an attribute-name of Secure and an empty attribute-value.\"\r\n       */\r\n      c.secure = true;\r\n      break;\r\n\r\n    case 'httponly': // S5.2.6 -- effectively the same as 'secure'\r\n      c.httpOnly = true;\r\n      break;\r\n\r\n    default:\r\n      c.extensions = c.extensions || [];\r\n      c.extensions.push(av);\r\n      break;\r\n    }\r\n  }\r\n\r\n  return c;\r\n}\r\n\r\n// avoid the V8 deoptimization monster!\r\nfunction jsonParse(str) {\r\n  var obj;\r\n  try {\r\n    obj = JSON.parse(str);\r\n  } catch (e) {\r\n    return e;\r\n  }\r\n  return obj;\r\n}\r\n\r\nfunction fromJSON(str) {\r\n  if (!str) {\r\n    return null;\r\n  }\r\n\r\n  var obj;\r\n  if (typeof str === 'string') {\r\n    obj = jsonParse(str);\r\n    if (obj instanceof Error) {\r\n      return null;\r\n    }\r\n  } else {\r\n    // assume it's an Object\r\n    obj = str;\r\n  }\r\n\r\n  var c = new Cookie();\r\n  for (var i=0; i<Cookie.serializableProperties.length; i++) {\r\n    var prop = Cookie.serializableProperties[i];\r\n    if (obj[prop] === undefined ||\r\n        obj[prop] === Cookie.prototype[prop])\r\n    {\r\n      continue; // leave as prototype default\r\n    }\r\n\r\n    if (prop === 'expires' ||\r\n        prop === 'creation' ||\r\n        prop === 'lastAccessed')\r\n    {\r\n      if (obj[prop] === null) {\r\n        c[prop] = null;\r\n      } else {\r\n        c[prop] = obj[prop] == \"Infinity\" ?\r\n          \"Infinity\" : new Date(obj[prop]);\r\n      }\r\n    } else {\r\n      c[prop] = obj[prop];\r\n    }\r\n  }\r\n\r\n  return c;\r\n}\r\n\r\n/* Section 5.4 part 2:\r\n * \"*  Cookies with longer paths are listed before cookies with\r\n *     shorter paths.\r\n *\r\n *  *  Among cookies that have equal-length path fields, cookies with\r\n *     earlier creation-times are listed before cookies with later\r\n *     creation-times.\"\r\n */\r\n\r\nfunction cookieCompare(a,b) {\r\n  var cmp = 0;\r\n\r\n  // descending for length: b CMP a\r\n  var aPathLen = a.path ? a.path.length : 0;\r\n  var bPathLen = b.path ? b.path.length : 0;\r\n  cmp = bPathLen - aPathLen;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  // ascending for time: a CMP b\r\n  var aTime = a.creation ? a.creation.getTime() : MAX_TIME;\r\n  var bTime = b.creation ? b.creation.getTime() : MAX_TIME;\r\n  cmp = aTime - bTime;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  // break ties for the same millisecond (precision of JavaScript's clock)\r\n  cmp = a.creationIndex - b.creationIndex;\r\n\r\n  return cmp;\r\n}\r\n\r\n// Gives the permutation of all possible pathMatch()es of a given path. The\r\n// array is in longest-to-shortest order.  Handy for indexing.\r\nfunction permutePath(path) {\r\n  if (path === '/') {\r\n    return ['/'];\r\n  }\r\n  if (path.lastIndexOf('/') === path.length-1) {\r\n    path = path.substr(0,path.length-1);\r\n  }\r\n  var permutations = [path];\r\n  while (path.length > 1) {\r\n    var lindex = path.lastIndexOf('/');\r\n    if (lindex === 0) {\r\n      break;\r\n    }\r\n    path = path.substr(0,lindex);\r\n    permutations.push(path);\r\n  }\r\n  permutations.push('/');\r\n  return permutations;\r\n}\r\n\r\nfunction getCookieContext(url) {\r\n  if (url instanceof Object) {\r\n    return url;\r\n  }\r\n  // NOTE: decodeURI will throw on malformed URIs (see GH-32).\r\n  // Therefore, we will just skip decoding for such URIs.\r\n  try {\r\n    url = decodeURI(url);\r\n  }\r\n  catch(err) {\r\n    // Silently swallow error\r\n  }\r\n\r\n  return urlParse(url);\r\n}\r\n\r\nfunction Cookie(options) {\r\n  options = options || {};\r\n\r\n  Object.keys(options).forEach(function(prop) {\r\n    if (Cookie.prototype.hasOwnProperty(prop) &&\r\n        Cookie.prototype[prop] !== options[prop] &&\r\n        prop.substr(0,1) !== '_')\r\n    {\r\n      this[prop] = options[prop];\r\n    }\r\n  }, this);\r\n\r\n  this.creation = this.creation || new Date();\r\n\r\n  // used to break creation ties in cookieCompare():\r\n  Object.defineProperty(this, 'creationIndex', {\r\n    configurable: false,\r\n    enumerable: false, // important for assert.deepEqual checks\r\n    writable: true,\r\n    value: ++Cookie.cookiesCreated\r\n  });\r\n}\r\n\r\nCookie.cookiesCreated = 0; // incremented each time a cookie is created\r\n\r\nCookie.parse = parse;\r\nCookie.fromJSON = fromJSON;\r\n\r\nCookie.prototype.key = \"\";\r\nCookie.prototype.value = \"\";\r\n\r\n// the order in which the RFC has them:\r\nCookie.prototype.expires = \"Infinity\"; // coerces to literal Infinity\r\nCookie.prototype.maxAge = null; // takes precedence over expires for TTL\r\nCookie.prototype.domain = null;\r\nCookie.prototype.path = null;\r\nCookie.prototype.secure = false;\r\nCookie.prototype.httpOnly = false;\r\nCookie.prototype.extensions = null;\r\n\r\n// set by the CookieJar:\r\nCookie.prototype.hostOnly = null; // boolean when set\r\nCookie.prototype.pathIsDefault = null; // boolean when set\r\nCookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse\r\nCookie.prototype.lastAccessed = null; // Date when set\r\nObject.defineProperty(Cookie.prototype, 'creationIndex', {\r\n  configurable: true,\r\n  enumerable: false,\r\n  writable: true,\r\n  value: 0\r\n});\r\n\r\nCookie.serializableProperties = Object.keys(Cookie.prototype)\r\n  .filter(function(prop) {\r\n    return !(\r\n      Cookie.prototype[prop] instanceof Function ||\r\n      prop === 'creationIndex' ||\r\n      prop.substr(0,1) === '_'\r\n    );\r\n  });\r\n\r\nCookie.prototype.inspect = function inspect() {\r\n  var now = Date.now();\r\n  return 'Cookie=\"'+this.toString() +\r\n    '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?') +\r\n    '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime())+'ms' : '?') +\r\n    '; cAge='+(this.creation ? (now-this.creation.getTime())+'ms' : '?') +\r\n    '\"';\r\n};\r\n\r\n// Use the new custom inspection symbol to add the custom inspect function if\r\n// available.\r\nif (util.inspect.custom) {\r\n  Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect;\r\n}\r\n\r\nCookie.prototype.toJSON = function() {\r\n  var obj = {};\r\n\r\n  var props = Cookie.serializableProperties;\r\n  for (var i=0; i<props.length; i++) {\r\n    var prop = props[i];\r\n    if (this[prop] === Cookie.prototype[prop]) {\r\n      continue; // leave as prototype default\r\n    }\r\n\r\n    if (prop === 'expires' ||\r\n        prop === 'creation' ||\r\n        prop === 'lastAccessed')\r\n    {\r\n      if (this[prop] === null) {\r\n        obj[prop] = null;\r\n      } else {\r\n        obj[prop] = this[prop] == \"Infinity\" ? // intentionally not ===\r\n          \"Infinity\" : this[prop].toISOString();\r\n      }\r\n    } else if (prop === 'maxAge') {\r\n      if (this[prop] !== null) {\r\n        // again, intentionally not ===\r\n        obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?\r\n          this[prop].toString() : this[prop];\r\n      }\r\n    } else {\r\n      if (this[prop] !== Cookie.prototype[prop]) {\r\n        obj[prop] = this[prop];\r\n      }\r\n    }\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\nCookie.prototype.clone = function() {\r\n  return fromJSON(this.toJSON());\r\n};\r\n\r\nCookie.prototype.validate = function validate() {\r\n  if (!COOKIE_OCTETS.test(this.value)) {\r\n    return false;\r\n  }\r\n  if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {\r\n    return false;\r\n  }\r\n  if (this.maxAge != null && this.maxAge <= 0) {\r\n    return false; // \"Max-Age=\" non-zero-digit *DIGIT\r\n  }\r\n  if (this.path != null && !PATH_VALUE.test(this.path)) {\r\n    return false;\r\n  }\r\n\r\n  var cdomain = this.cdomain();\r\n  if (cdomain) {\r\n    if (cdomain.match(/\\.$/)) {\r\n      return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this\r\n    }\r\n    var suffix = pubsuffix.getPublicSuffix(cdomain);\r\n    if (suffix == null) { // it's a public suffix\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nCookie.prototype.setExpires = function setExpires(exp) {\r\n  if (exp instanceof Date) {\r\n    this.expires = exp;\r\n  } else {\r\n    this.expires = parseDate(exp) || \"Infinity\";\r\n  }\r\n};\r\n\r\nCookie.prototype.setMaxAge = function setMaxAge(age) {\r\n  if (age === Infinity || age === -Infinity) {\r\n    this.maxAge = age.toString(); // so JSON.stringify() works\r\n  } else {\r\n    this.maxAge = age;\r\n  }\r\n};\r\n\r\n// gives Cookie header format\r\nCookie.prototype.cookieString = function cookieString() {\r\n  var val = this.value;\r\n  if (val == null) {\r\n    val = '';\r\n  }\r\n  if (this.key === '') {\r\n    return val;\r\n  }\r\n  return this.key+'='+val;\r\n};\r\n\r\n// gives Set-Cookie header format\r\nCookie.prototype.toString = function toString() {\r\n  var str = this.cookieString();\r\n\r\n  if (this.expires != Infinity) {\r\n    if (this.expires instanceof Date) {\r\n      str += '; Expires='+formatDate(this.expires);\r\n    } else {\r\n      str += '; Expires='+this.expires;\r\n    }\r\n  }\r\n\r\n  if (this.maxAge != null && this.maxAge != Infinity) {\r\n    str += '; Max-Age='+this.maxAge;\r\n  }\r\n\r\n  if (this.domain && !this.hostOnly) {\r\n    str += '; Domain='+this.domain;\r\n  }\r\n  if (this.path) {\r\n    str += '; Path='+this.path;\r\n  }\r\n\r\n  if (this.secure) {\r\n    str += '; Secure';\r\n  }\r\n  if (this.httpOnly) {\r\n    str += '; HttpOnly';\r\n  }\r\n  if (this.extensions) {\r\n    this.extensions.forEach(function(ext) {\r\n      str += '; '+ext;\r\n    });\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\n// TTL() partially replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\r\n// elsewhere)\r\n// S5.3 says to give the \"latest representable date\" for which we use Infinity\r\n// For \"expired\" we use 0\r\nCookie.prototype.TTL = function TTL(now) {\r\n  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires\r\n   * attribute, the Max-Age attribute has precedence and controls the\r\n   * expiration date of the cookie.\r\n   * (Concurs with S5.3 step 3)\r\n   */\r\n  if (this.maxAge != null) {\r\n    return this.maxAge<=0 ? 0 : this.maxAge*1000;\r\n  }\r\n\r\n  var expires = this.expires;\r\n  if (expires != Infinity) {\r\n    if (!(expires instanceof Date)) {\r\n      expires = parseDate(expires) || Infinity;\r\n    }\r\n\r\n    if (expires == Infinity) {\r\n      return Infinity;\r\n    }\r\n\r\n    return expires.getTime() - (now || Date.now());\r\n  }\r\n\r\n  return Infinity;\r\n};\r\n\r\n// expiryTime() replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\r\n// elsewhere)\r\nCookie.prototype.expiryTime = function expiryTime(now) {\r\n  if (this.maxAge != null) {\r\n    var relativeTo = now || this.creation || new Date();\r\n    var age = (this.maxAge <= 0) ? -Infinity : this.maxAge*1000;\r\n    return relativeTo.getTime() + age;\r\n  }\r\n\r\n  if (this.expires == Infinity) {\r\n    return Infinity;\r\n  }\r\n  return this.expires.getTime();\r\n};\r\n\r\n// expiryDate() replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\r\n// elsewhere), except it returns a Date\r\nCookie.prototype.expiryDate = function expiryDate(now) {\r\n  var millisec = this.expiryTime(now);\r\n  if (millisec == Infinity) {\r\n    return new Date(MAX_TIME);\r\n  } else if (millisec == -Infinity) {\r\n    return new Date(MIN_TIME);\r\n  } else {\r\n    return new Date(millisec);\r\n  }\r\n};\r\n\r\n// This replaces the \"persistent-flag\" parts of S5.3 step 3\r\nCookie.prototype.isPersistent = function isPersistent() {\r\n  return (this.maxAge != null || this.expires != Infinity);\r\n};\r\n\r\n// Mostly S5.1.2 and S5.2.3:\r\nCookie.prototype.cdomain =\r\nCookie.prototype.canonicalizedDomain = function canonicalizedDomain() {\r\n  if (this.domain == null) {\r\n    return null;\r\n  }\r\n  return canonicalDomain(this.domain);\r\n};\r\n\r\nfunction CookieJar(store, options) {\r\n  if (typeof options === \"boolean\") {\r\n    options = {rejectPublicSuffixes: options};\r\n  } else if (options == null) {\r\n    options = {};\r\n  }\r\n  if (options.rejectPublicSuffixes != null) {\r\n    this.rejectPublicSuffixes = options.rejectPublicSuffixes;\r\n  }\r\n  if (options.looseMode != null) {\r\n    this.enableLooseMode = options.looseMode;\r\n  }\r\n\r\n  if (!store) {\r\n    store = new MemoryCookieStore();\r\n  }\r\n  this.store = store;\r\n}\r\nCookieJar.prototype.store = null;\r\nCookieJar.prototype.rejectPublicSuffixes = true;\r\nCookieJar.prototype.enableLooseMode = false;\r\nvar CAN_BE_SYNC = [];\r\n\r\nCAN_BE_SYNC.push('setCookie');\r\nCookieJar.prototype.setCookie = function(cookie, url, options, cb) {\r\n  var err;\r\n  var context = getCookieContext(url);\r\n  if (options instanceof Function) {\r\n    cb = options;\r\n    options = {};\r\n  }\r\n\r\n  var host = canonicalDomain(context.hostname);\r\n  var loose = this.enableLooseMode;\r\n  if (options.loose != null) {\r\n    loose = options.loose;\r\n  }\r\n\r\n  // S5.3 step 1\r\n  if (!(cookie instanceof Cookie)) {\r\n    cookie = Cookie.parse(cookie, { loose: loose });\r\n  }\r\n  if (!cookie) {\r\n    err = new Error(\"Cookie failed to parse\");\r\n    return cb(options.ignoreError ? null : err);\r\n  }\r\n\r\n  // S5.3 step 2\r\n  var now = options.now || new Date(); // will assign later to save effort in the face of errors\r\n\r\n  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()\r\n\r\n  // S5.3 step 4: NOOP; domain is null by default\r\n\r\n  // S5.3 step 5: public suffixes\r\n  if (this.rejectPublicSuffixes && cookie.domain) {\r\n    var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());\r\n    if (suffix == null) { // e.g. \"com\"\r\n      err = new Error(\"Cookie has domain set to a public suffix\");\r\n      return cb(options.ignoreError ? null : err);\r\n    }\r\n  }\r\n\r\n  // S5.3 step 6:\r\n  if (cookie.domain) {\r\n    if (!domainMatch(host, cookie.cdomain(), false)) {\r\n      err = new Error(\"Cookie not in this host's domain. Cookie:\"+cookie.cdomain()+\" Request:\"+host);\r\n      return cb(options.ignoreError ? null : err);\r\n    }\r\n\r\n    if (cookie.hostOnly == null) { // don't reset if already set\r\n      cookie.hostOnly = false;\r\n    }\r\n\r\n  } else {\r\n    cookie.hostOnly = true;\r\n    cookie.domain = host;\r\n  }\r\n\r\n  //S5.2.4 If the attribute-value is empty or if the first character of the\r\n  //attribute-value is not %x2F (\"/\"):\r\n  //Let cookie-path be the default-path.\r\n  if (!cookie.path || cookie.path[0] !== '/') {\r\n    cookie.path = defaultPath(context.pathname);\r\n    cookie.pathIsDefault = true;\r\n  }\r\n\r\n  // S5.3 step 8: NOOP; secure attribute\r\n  // S5.3 step 9: NOOP; httpOnly attribute\r\n\r\n  // S5.3 step 10\r\n  if (options.http === false && cookie.httpOnly) {\r\n    err = new Error(\"Cookie is HttpOnly and this isn't an HTTP API\");\r\n    return cb(options.ignoreError ? null : err);\r\n  }\r\n\r\n  var store = this.store;\r\n\r\n  if (!store.updateCookie) {\r\n    store.updateCookie = function(oldCookie, newCookie, cb) {\r\n      this.putCookie(newCookie, cb);\r\n    };\r\n  }\r\n\r\n  function withCookie(err, oldCookie) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n\r\n    var next = function(err) {\r\n      if (err) {\r\n        return cb(err);\r\n      } else {\r\n        cb(null, cookie);\r\n      }\r\n    };\r\n\r\n    if (oldCookie) {\r\n      // S5.3 step 11 - \"If the cookie store contains a cookie with the same name,\r\n      // domain, and path as the newly created cookie:\"\r\n      if (options.http === false && oldCookie.httpOnly) { // step 11.2\r\n        err = new Error(\"old Cookie is HttpOnly and this isn't an HTTP API\");\r\n        return cb(options.ignoreError ? null : err);\r\n      }\r\n      cookie.creation = oldCookie.creation; // step 11.3\r\n      cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker\r\n      cookie.lastAccessed = now;\r\n      // Step 11.4 (delete cookie) is implied by just setting the new one:\r\n      store.updateCookie(oldCookie, cookie, next); // step 12\r\n\r\n    } else {\r\n      cookie.creation = cookie.lastAccessed = now;\r\n      store.putCookie(cookie, next); // step 12\r\n    }\r\n  }\r\n\r\n  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);\r\n};\r\n\r\n// RFC6365 S5.4\r\nCAN_BE_SYNC.push('getCookies');\r\nCookieJar.prototype.getCookies = function(url, options, cb) {\r\n  var context = getCookieContext(url);\r\n  if (options instanceof Function) {\r\n    cb = options;\r\n    options = {};\r\n  }\r\n\r\n  var host = canonicalDomain(context.hostname);\r\n  var path = context.pathname || '/';\r\n\r\n  var secure = options.secure;\r\n  if (secure == null && context.protocol &&\r\n      (context.protocol == 'https:' || context.protocol == 'wss:'))\r\n  {\r\n    secure = true;\r\n  }\r\n\r\n  var http = options.http;\r\n  if (http == null) {\r\n    http = true;\r\n  }\r\n\r\n  var now = options.now || Date.now();\r\n  var expireCheck = options.expire !== false;\r\n  var allPaths = !!options.allPaths;\r\n  var store = this.store;\r\n\r\n  function matchingCookie(c) {\r\n    // \"Either:\r\n    //   The cookie's host-only-flag is true and the canonicalized\r\n    //   request-host is identical to the cookie's domain.\r\n    // Or:\r\n    //   The cookie's host-only-flag is false and the canonicalized\r\n    //   request-host domain-matches the cookie's domain.\"\r\n    if (c.hostOnly) {\r\n      if (c.domain != host) {\r\n        return false;\r\n      }\r\n    } else {\r\n      if (!domainMatch(host, c.domain, false)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // \"The request-uri's path path-matches the cookie's path.\"\r\n    if (!allPaths && !pathMatch(path, c.path)) {\r\n      return false;\r\n    }\r\n\r\n    // \"If the cookie's secure-only-flag is true, then the request-uri's\r\n    // scheme must denote a \"secure\" protocol\"\r\n    if (c.secure && !secure) {\r\n      return false;\r\n    }\r\n\r\n    // \"If the cookie's http-only-flag is true, then exclude the cookie if the\r\n    // cookie-string is being generated for a \"non-HTTP\" API\"\r\n    if (c.httpOnly && !http) {\r\n      return false;\r\n    }\r\n\r\n    // deferred from S5.3\r\n    // non-RFC: allow retention of expired cookies by choice\r\n    if (expireCheck && c.expiryTime() <= now) {\r\n      store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  store.findCookies(host, allPaths ? null : path, function(err,cookies) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n\r\n    cookies = cookies.filter(matchingCookie);\r\n\r\n    // sorting of S5.4 part 2\r\n    if (options.sort !== false) {\r\n      cookies = cookies.sort(cookieCompare);\r\n    }\r\n\r\n    // S5.4 part 3\r\n    var now = new Date();\r\n    cookies.forEach(function(c) {\r\n      c.lastAccessed = now;\r\n    });\r\n    // TODO persist lastAccessed\r\n\r\n    cb(null,cookies);\r\n  });\r\n};\r\n\r\nCAN_BE_SYNC.push('getCookieString');\r\nCookieJar.prototype.getCookieString = function(/*..., cb*/) {\r\n  var args = Array.prototype.slice.call(arguments,0);\r\n  var cb = args.pop();\r\n  var next = function(err,cookies) {\r\n    if (err) {\r\n      cb(err);\r\n    } else {\r\n      cb(null, cookies\r\n        .sort(cookieCompare)\r\n        .map(function(c){\r\n          return c.cookieString();\r\n        })\r\n        .join('; '));\r\n    }\r\n  };\r\n  args.push(next);\r\n  this.getCookies.apply(this,args);\r\n};\r\n\r\nCAN_BE_SYNC.push('getSetCookieStrings');\r\nCookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {\r\n  var args = Array.prototype.slice.call(arguments,0);\r\n  var cb = args.pop();\r\n  var next = function(err,cookies) {\r\n    if (err) {\r\n      cb(err);\r\n    } else {\r\n      cb(null, cookies.map(function(c){\r\n        return c.toString();\r\n      }));\r\n    }\r\n  };\r\n  args.push(next);\r\n  this.getCookies.apply(this,args);\r\n};\r\n\r\nCAN_BE_SYNC.push('serialize');\r\nCookieJar.prototype.serialize = function(cb) {\r\n  var type = this.store.constructor.name;\r\n  if (type === 'Object') {\r\n    type = null;\r\n  }\r\n\r\n  // update README.md \"Serialization Format\" if you change this, please!\r\n  var serialized = {\r\n    // The version of tough-cookie that serialized this jar. Generally a good\r\n    // practice since future versions can make data import decisions based on\r\n    // known past behavior. When/if this matters, use `semver`.\r\n    version: 'tough-cookie@'+VERSION,\r\n\r\n    // add the store type, to make humans happy:\r\n    storeType: type,\r\n\r\n    // CookieJar configuration:\r\n    rejectPublicSuffixes: !!this.rejectPublicSuffixes,\r\n\r\n    // this gets filled from getAllCookies:\r\n    cookies: []\r\n  };\r\n\r\n  if (!(this.store.getAllCookies &&\r\n        typeof this.store.getAllCookies === 'function'))\r\n  {\r\n    return cb(new Error('store does not support getAllCookies and cannot be serialized'));\r\n  }\r\n\r\n  this.store.getAllCookies(function(err,cookies) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n\r\n    serialized.cookies = cookies.map(function(cookie) {\r\n      // convert to serialized 'raw' cookies\r\n      cookie = (cookie instanceof Cookie) ? cookie.toJSON() : cookie;\r\n\r\n      // Remove the index so new ones get assigned during deserialization\r\n      delete cookie.creationIndex;\r\n\r\n      return cookie;\r\n    });\r\n\r\n    return cb(null, serialized);\r\n  });\r\n};\r\n\r\n// well-known name that JSON.stringify calls\r\nCookieJar.prototype.toJSON = function() {\r\n  return this.serializeSync();\r\n};\r\n\r\n// use the class method CookieJar.deserialize instead of calling this directly\r\nCAN_BE_SYNC.push('_importCookies');\r\nCookieJar.prototype._importCookies = function(serialized, cb) {\r\n  var jar = this;\r\n  var cookies = serialized.cookies;\r\n  if (!cookies || !Array.isArray(cookies)) {\r\n    return cb(new Error('serialized jar has no cookies array'));\r\n  }\r\n  cookies = cookies.slice(); // do not modify the original\r\n\r\n  function putNext(err) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n\r\n    if (!cookies.length) {\r\n      return cb(err, jar);\r\n    }\r\n\r\n    var cookie;\r\n    try {\r\n      cookie = fromJSON(cookies.shift());\r\n    } catch (e) {\r\n      return cb(e);\r\n    }\r\n\r\n    if (cookie === null) {\r\n      return putNext(null); // skip this cookie\r\n    }\r\n\r\n    jar.store.putCookie(cookie, putNext);\r\n  }\r\n\r\n  putNext();\r\n};\r\n\r\nCookieJar.deserialize = function(strOrObj, store, cb) {\r\n  if (arguments.length !== 3) {\r\n    // store is optional\r\n    cb = store;\r\n    store = null;\r\n  }\r\n\r\n  var serialized;\r\n  if (typeof strOrObj === 'string') {\r\n    serialized = jsonParse(strOrObj);\r\n    if (serialized instanceof Error) {\r\n      return cb(serialized);\r\n    }\r\n  } else {\r\n    serialized = strOrObj;\r\n  }\r\n\r\n  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);\r\n  jar._importCookies(serialized, function(err) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n    cb(null, jar);\r\n  });\r\n};\r\n\r\nCookieJar.deserializeSync = function(strOrObj, store) {\r\n  var serialized = typeof strOrObj === 'string' ?\r\n    JSON.parse(strOrObj) : strOrObj;\r\n  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);\r\n\r\n  // catch this mistake early:\r\n  if (!jar.store.synchronous) {\r\n    throw new Error('CookieJar store is not synchronous; use async API instead.');\r\n  }\r\n\r\n  jar._importCookiesSync(serialized);\r\n  return jar;\r\n};\r\nCookieJar.fromJSON = CookieJar.deserializeSync;\r\n\r\nCookieJar.prototype.clone = function(newStore, cb) {\r\n  if (arguments.length === 1) {\r\n    cb = newStore;\r\n    newStore = null;\r\n  }\r\n\r\n  this.serialize(function(err,serialized) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n    CookieJar.deserialize(serialized, newStore, cb);\r\n  });\r\n};\r\n\r\nCAN_BE_SYNC.push('removeAllCookies');\r\nCookieJar.prototype.removeAllCookies = function(cb) {\r\n  var store = this.store;\r\n\r\n  // Check that the store implements its own removeAllCookies(). The default\r\n  // implementation in Store will immediately call the callback with a \"not\r\n  // implemented\" Error.\r\n  if (store.removeAllCookies instanceof Function &&\r\n      store.removeAllCookies !== Store.prototype.removeAllCookies)\r\n  {\r\n    return store.removeAllCookies(cb);\r\n  }\r\n\r\n  store.getAllCookies(function(err, cookies) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n\r\n    if (cookies.length === 0) {\r\n      return cb(null);\r\n    }\r\n\r\n    var completedCount = 0;\r\n    var removeErrors = [];\r\n\r\n    function removeCookieCb(removeErr) {\r\n      if (removeErr) {\r\n        removeErrors.push(removeErr);\r\n      }\r\n\r\n      completedCount++;\r\n\r\n      if (completedCount === cookies.length) {\r\n        return cb(removeErrors.length ? removeErrors[0] : null);\r\n      }\r\n    }\r\n\r\n    cookies.forEach(function(cookie) {\r\n      store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);\r\n    });\r\n  });\r\n};\r\n\r\nCookieJar.prototype._cloneSync = syncWrap('clone');\r\nCookieJar.prototype.cloneSync = function(newStore) {\r\n  if (!newStore.synchronous) {\r\n    throw new Error('CookieJar clone destination store is not synchronous; use async API instead.');\r\n  }\r\n  return this._cloneSync(newStore);\r\n};\r\n\r\n// Use a closure to provide a true imperative API for synchronous stores.\r\nfunction syncWrap(method) {\r\n  return function() {\r\n    if (!this.store.synchronous) {\r\n      throw new Error('CookieJar store is not synchronous; use async API instead.');\r\n    }\r\n\r\n    var args = Array.prototype.slice.call(arguments);\r\n    var syncErr, syncResult;\r\n    args.push(function syncCb(err, result) {\r\n      syncErr = err;\r\n      syncResult = result;\r\n    });\r\n    this[method].apply(this, args);\r\n\r\n    if (syncErr) {\r\n      throw syncErr;\r\n    }\r\n    return syncResult;\r\n  };\r\n}\r\n\r\n// wrap all declared CAN_BE_SYNC methods in the sync wrapper\r\nCAN_BE_SYNC.forEach(function(method) {\r\n  CookieJar.prototype[method+'Sync'] = syncWrap(method);\r\n});\r\n\r\nexports.version = VERSION;\r\nexports.CookieJar = CookieJar;\r\nexports.Cookie = Cookie;\r\nexports.Store = Store;\r\nexports.MemoryCookieStore = MemoryCookieStore;\r\nexports.parseDate = parseDate;\r\nexports.formatDate = formatDate;\r\nexports.parse = parse;\r\nexports.fromJSON = fromJSON;\r\nexports.domainMatch = domainMatch;\r\nexports.defaultPath = defaultPath;\r\nexports.pathMatch = pathMatch;\r\nexports.getPublicSuffix = pubsuffix.getPublicSuffix;\r\nexports.cookieCompare = cookieCompare;\r\nexports.permuteDomain = require('./permuteDomain').permuteDomain;\r\nexports.permutePath = permutePath;\r\nexports.canonicalDomain = canonicalDomain;\r\n","/*!\r\n * Copyright (c) 2018, Salesforce.com, Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n * this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n * this list of conditions and the following disclaimer in the documentation\r\n * and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\r\n * be used to endorse or promote products derived from this software without\r\n * specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar psl = require('psl');\r\n\r\nfunction getPublicSuffix(domain) {\r\n  return psl.get(domain);\r\n}\r\n\r\nexports.getPublicSuffix = getPublicSuffix;\r\n","/*!\r\n * Copyright (c) 2015, Salesforce.com, Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n * this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n * this list of conditions and the following disclaimer in the documentation\r\n * and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\r\n * be used to endorse or promote products derived from this software without\r\n * specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*jshint unused:false */\r\n\r\nfunction Store() {\r\n}\r\nexports.Store = Store;\r\n\r\n// Stores may be synchronous, but are still required to use a\r\n// Continuation-Passing Style API.  The CookieJar itself will expose a \"*Sync\"\r\n// API that converts from synchronous-callbacks to imperative style.\r\nStore.prototype.synchronous = false;\r\n\r\nStore.prototype.findCookie = function(domain, path, key, cb) {\r\n  throw new Error('findCookie is not implemented');\r\n};\r\n\r\nStore.prototype.findCookies = function(domain, path, cb) {\r\n  throw new Error('findCookies is not implemented');\r\n};\r\n\r\nStore.prototype.putCookie = function(cookie, cb) {\r\n  throw new Error('putCookie is not implemented');\r\n};\r\n\r\nStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {\r\n  // recommended default implementation:\r\n  // return this.putCookie(newCookie, cb);\r\n  throw new Error('updateCookie is not implemented');\r\n};\r\n\r\nStore.prototype.removeCookie = function(domain, path, key, cb) {\r\n  throw new Error('removeCookie is not implemented');\r\n};\r\n\r\nStore.prototype.removeCookies = function(domain, path, cb) {\r\n  throw new Error('removeCookies is not implemented');\r\n};\r\n\r\nStore.prototype.removeAllCookies = function(cb) {\r\n  throw new Error('removeAllCookies is not implemented');\r\n}\r\n\r\nStore.prototype.getAllCookies = function(cb) {\r\n  throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');\r\n};\r\n","/*!\r\n * Copyright (c) 2015, Salesforce.com, Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n * this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n * this list of conditions and the following disclaimer in the documentation\r\n * and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\r\n * be used to endorse or promote products derived from this software without\r\n * specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar Store = require('./store').Store;\r\nvar permuteDomain = require('./permuteDomain').permuteDomain;\r\nvar pathMatch = require('./pathMatch').pathMatch;\r\nvar util = require('util');\r\n\r\nfunction MemoryCookieStore() {\r\n  Store.call(this);\r\n  this.idx = {};\r\n}\r\nutil.inherits(MemoryCookieStore, Store);\r\nexports.MemoryCookieStore = MemoryCookieStore;\r\nMemoryCookieStore.prototype.idx = null;\r\n\r\n// Since it's just a struct in RAM, this Store is synchronous\r\nMemoryCookieStore.prototype.synchronous = true;\r\n\r\n// force a default depth:\r\nMemoryCookieStore.prototype.inspect = function() {\r\n  return \"{ idx: \"+util.inspect(this.idx, false, 2)+' }';\r\n};\r\n\r\n// Use the new custom inspection symbol to add the custom inspect function if\r\n// available.\r\nif (util.inspect.custom) {\r\n  MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect;\r\n}\r\n\r\nMemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {\r\n  if (!this.idx[domain]) {\r\n    return cb(null,undefined);\r\n  }\r\n  if (!this.idx[domain][path]) {\r\n    return cb(null,undefined);\r\n  }\r\n  return cb(null,this.idx[domain][path][key]||null);\r\n};\r\n\r\nMemoryCookieStore.prototype.findCookies = function(domain, path, cb) {\r\n  var results = [];\r\n  if (!domain) {\r\n    return cb(null,[]);\r\n  }\r\n\r\n  var pathMatcher;\r\n  if (!path) {\r\n    // null means \"all paths\"\r\n    pathMatcher = function matchAll(domainIndex) {\r\n      for (var curPath in domainIndex) {\r\n        var pathIndex = domainIndex[curPath];\r\n        for (var key in pathIndex) {\r\n          results.push(pathIndex[key]);\r\n        }\r\n      }\r\n    };\r\n\r\n  } else {\r\n    pathMatcher = function matchRFC(domainIndex) {\r\n       //NOTE: we should use path-match algorithm from S5.1.4 here\r\n       //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\r\n       Object.keys(domainIndex).forEach(function (cookiePath) {\r\n         if (pathMatch(path, cookiePath)) {\r\n           var pathIndex = domainIndex[cookiePath];\r\n\r\n           for (var key in pathIndex) {\r\n             results.push(pathIndex[key]);\r\n           }\r\n         }\r\n       });\r\n     };\r\n  }\r\n\r\n  var domains = permuteDomain(domain) || [domain];\r\n  var idx = this.idx;\r\n  domains.forEach(function(curDomain) {\r\n    var domainIndex = idx[curDomain];\r\n    if (!domainIndex) {\r\n      return;\r\n    }\r\n    pathMatcher(domainIndex);\r\n  });\r\n\r\n  cb(null,results);\r\n};\r\n\r\nMemoryCookieStore.prototype.putCookie = function(cookie, cb) {\r\n  if (!this.idx[cookie.domain]) {\r\n    this.idx[cookie.domain] = {};\r\n  }\r\n  if (!this.idx[cookie.domain][cookie.path]) {\r\n    this.idx[cookie.domain][cookie.path] = {};\r\n  }\r\n  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\r\n  cb(null);\r\n};\r\n\r\nMemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {\r\n  // updateCookie() may avoid updating cookies that are identical.  For example,\r\n  // lastAccessed may not be important to some stores and an equality\r\n  // comparison could exclude that field.\r\n  this.putCookie(newCookie,cb);\r\n};\r\n\r\nMemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {\r\n  if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {\r\n    delete this.idx[domain][path][key];\r\n  }\r\n  cb(null);\r\n};\r\n\r\nMemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {\r\n  if (this.idx[domain]) {\r\n    if (path) {\r\n      delete this.idx[domain][path];\r\n    } else {\r\n      delete this.idx[domain];\r\n    }\r\n  }\r\n  return cb(null);\r\n};\r\n\r\nMemoryCookieStore.prototype.removeAllCookies = function(cb) {\r\n  this.idx = {};\r\n  return cb(null);\r\n}\r\n\r\nMemoryCookieStore.prototype.getAllCookies = function(cb) {\r\n  var cookies = [];\r\n  var idx = this.idx;\r\n\r\n  var domains = Object.keys(idx);\r\n  domains.forEach(function(domain) {\r\n    var paths = Object.keys(idx[domain]);\r\n    paths.forEach(function(path) {\r\n      var keys = Object.keys(idx[domain][path]);\r\n      keys.forEach(function(key) {\r\n        if (key !== null) {\r\n          cookies.push(idx[domain][path][key]);\r\n        }\r\n      });\r\n    });\r\n  });\r\n\r\n  // Sort by creationIndex so deserializing retains the creation order.\r\n  // When implementing your own store, this SHOULD retain the order too\r\n  cookies.sort(function(a,b) {\r\n    return (a.creationIndex||0) - (b.creationIndex||0);\r\n  });\r\n\r\n  cb(null, cookies);\r\n};\r\n","/*!\r\n * Copyright (c) 2015, Salesforce.com, Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n * this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n * this list of conditions and the following disclaimer in the documentation\r\n * and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\r\n * be used to endorse or promote products derived from this software without\r\n * specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar pubsuffix = require('./pubsuffix-psl');\r\n\r\n// Gives the permutation of all possible domainMatch()es of a given domain. The\r\n// array is in shortest-to-longest order.  Handy for indexing.\r\nfunction permuteDomain (domain) {\r\n  var pubSuf = pubsuffix.getPublicSuffix(domain);\r\n  if (!pubSuf) {\r\n    return null;\r\n  }\r\n  if (pubSuf == domain) {\r\n    return [domain];\r\n  }\r\n\r\n  var prefix = domain.slice(0, -(pubSuf.length + 1)); // \".example.com\"\r\n  var parts = prefix.split('.').reverse();\r\n  var cur = pubSuf;\r\n  var permutations = [cur];\r\n  while (parts.length) {\r\n    cur = parts.shift() + '.' + cur;\r\n    permutations.push(cur);\r\n  }\r\n  return permutations;\r\n}\r\n\r\nexports.permuteDomain = permuteDomain;\r\n","/*!\r\n * Copyright (c) 2015, Salesforce.com, Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n * this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n * this list of conditions and the following disclaimer in the documentation\r\n * and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\r\n * be used to endorse or promote products derived from this software without\r\n * specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\n * \"A request-path path-matches a given cookie-path if at least one of the\r\n * following conditions holds:\"\r\n */\r\nfunction pathMatch (reqPath, cookiePath) {\r\n  // \"o  The cookie-path and the request-path are identical.\"\r\n  if (cookiePath === reqPath) {\r\n    return true;\r\n  }\r\n\r\n  var idx = reqPath.indexOf(cookiePath);\r\n  if (idx === 0) {\r\n    // \"o  The cookie-path is a prefix of the request-path, and the last\r\n    // character of the cookie-path is %x2F (\"/\").\"\r\n    if (cookiePath.substr(-1) === \"/\") {\r\n      return true;\r\n    }\r\n\r\n    // \" o  The cookie-path is a prefix of the request-path, and the first\r\n    // character of the request-path that is not included in the cookie- path\r\n    // is a %x2F (\"/\") character.\"\r\n    if (reqPath.substr(cookiePath.length, 1) === \"/\") {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexports.pathMatch = pathMatch;\r\n","// generated by genversion\r\nmodule.exports = '2.5.0'\r\n"]}