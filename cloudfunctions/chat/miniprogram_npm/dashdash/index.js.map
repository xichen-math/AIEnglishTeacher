{"version":3,"sources":["dashdash.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\r\n * dashdash - A light, featureful and explicit option parsing library for\r\n * node.js.\r\n */\r\n// vim: set ts=4 sts=4 sw=4 et:\r\n\r\nvar assert = require('assert-plus');\r\nvar format = require('util').format;\r\nvar fs = require('fs');\r\nvar path = require('path');\r\n\r\n\r\nvar DEBUG = true;\r\nif (DEBUG) {\r\n    var debug = console.warn;\r\n} else {\r\n    var debug = function () {};\r\n}\r\n\r\n\r\n\r\n// ---- internal support stuff\r\n\r\n// Replace {{variable}} in `s` with the template data in `d`.\r\nfunction renderTemplate(s, d) {\r\n    return s.replace(/{{([a-zA-Z]+)}}/g, function (match, key) {\r\n        return d.hasOwnProperty(key) ? d[key] : match;\r\n    });\r\n}\r\n\r\n/**\r\n * Return a shallow copy of the given object;\r\n */\r\nfunction shallowCopy(obj) {\r\n    if (!obj) {\r\n        return (obj);\r\n    }\r\n    var copy = {};\r\n    Object.keys(obj).forEach(function (k) {\r\n        copy[k] = obj[k];\r\n    });\r\n    return (copy);\r\n}\r\n\r\n\r\nfunction space(n) {\r\n    var s = '';\r\n    for (var i = 0; i < n; i++) {\r\n        s += ' ';\r\n    }\r\n    return s;\r\n}\r\n\r\n\r\nfunction makeIndent(arg, deflen, name) {\r\n    if (arg === null || arg === undefined)\r\n        return space(deflen);\r\n    else if (typeof (arg) === 'number')\r\n        return space(arg);\r\n    else if (typeof (arg) === 'string')\r\n        return arg;\r\n    else\r\n        assert.fail('invalid \"' + name + '\": not a string or number: ' + arg);\r\n}\r\n\r\n\r\n/**\r\n * Return an array of lines wrapping the given text to the given width.\r\n * This splits on whitespace. Single tokens longer than `width` are not\r\n * broken up.\r\n */\r\nfunction textwrap(s, width) {\r\n    var words = s.trim().split(/\\s+/);\r\n    var lines = [];\r\n    var line = '';\r\n    words.forEach(function (w) {\r\n        var newLength = line.length + w.length;\r\n        if (line.length > 0)\r\n            newLength += 1;\r\n        if (newLength > width) {\r\n            lines.push(line);\r\n            line = '';\r\n        }\r\n        if (line.length > 0)\r\n            line += ' ';\r\n        line += w;\r\n    });\r\n    lines.push(line);\r\n    return lines;\r\n}\r\n\r\n\r\n/**\r\n * Transform an option name to a \"key\" that is used as the field\r\n * on the `opts` object returned from `<parser>.parse()`.\r\n *\r\n * Transformations:\r\n * - '-' -> '_': This allow one to use hyphen in option names (common)\r\n *   but not have to do silly things like `opt[\"dry-run\"]` to access the\r\n *   parsed results.\r\n */\r\nfunction optionKeyFromName(name) {\r\n    return name.replace(/-/g, '_');\r\n}\r\n\r\n\r\n\r\n// ---- Option types\r\n\r\nfunction parseBool(option, optstr, arg) {\r\n    return Boolean(arg);\r\n}\r\n\r\nfunction parseString(option, optstr, arg) {\r\n    assert.string(arg, 'arg');\r\n    return arg;\r\n}\r\n\r\nfunction parseNumber(option, optstr, arg) {\r\n    assert.string(arg, 'arg');\r\n    var num = Number(arg);\r\n    if (isNaN(num)) {\r\n        throw new Error(format('arg for \"%s\" is not a number: \"%s\"',\r\n            optstr, arg));\r\n    }\r\n    return num;\r\n}\r\n\r\nfunction parseInteger(option, optstr, arg) {\r\n    assert.string(arg, 'arg');\r\n    var num = Number(arg);\r\n    if (!/^[0-9-]+$/.test(arg) || isNaN(num)) {\r\n        throw new Error(format('arg for \"%s\" is not an integer: \"%s\"',\r\n            optstr, arg));\r\n    }\r\n    return num;\r\n}\r\n\r\nfunction parsePositiveInteger(option, optstr, arg) {\r\n    assert.string(arg, 'arg');\r\n    var num = Number(arg);\r\n    if (!/^[0-9]+$/.test(arg) || isNaN(num) || num === 0) {\r\n        throw new Error(format('arg for \"%s\" is not a positive integer: \"%s\"',\r\n            optstr, arg));\r\n    }\r\n    return num;\r\n}\r\n\r\n/**\r\n * Supported date args:\r\n * - epoch second times (e.g. 1396031701)\r\n * - ISO 8601 format: YYYY-MM-DD[THH:MM:SS[.sss][Z]]\r\n *      2014-03-28T18:35:01.489Z\r\n *      2014-03-28T18:35:01.489\r\n *      2014-03-28T18:35:01Z\r\n *      2014-03-28T18:35:01\r\n *      2014-03-28\r\n */\r\nfunction parseDate(option, optstr, arg) {\r\n    assert.string(arg, 'arg');\r\n    var date;\r\n    if (/^\\d+$/.test(arg)) {\r\n        // epoch seconds\r\n        date = new Date(Number(arg) * 1000);\r\n    /* JSSTYLED */\r\n    } else if (/^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z?)?$/i.test(arg)) {\r\n        // ISO 8601 format\r\n        date = new Date(arg);\r\n    } else {\r\n        throw new Error(format('arg for \"%s\" is not a valid date format: \"%s\"',\r\n            optstr, arg));\r\n    }\r\n    if (date.toString() === 'Invalid Date') {\r\n        throw new Error(format('arg for \"%s\" is an invalid date: \"%s\"',\r\n            optstr, arg));\r\n    }\r\n    return date;\r\n}\r\n\r\nvar optionTypes = {\r\n    bool: {\r\n        takesArg: false,\r\n        parseArg: parseBool\r\n    },\r\n    string: {\r\n        takesArg: true,\r\n        helpArg: 'ARG',\r\n        parseArg: parseString\r\n    },\r\n    number: {\r\n        takesArg: true,\r\n        helpArg: 'NUM',\r\n        parseArg: parseNumber\r\n    },\r\n    integer: {\r\n        takesArg: true,\r\n        helpArg: 'INT',\r\n        parseArg: parseInteger\r\n    },\r\n    positiveInteger: {\r\n        takesArg: true,\r\n        helpArg: 'INT',\r\n        parseArg: parsePositiveInteger\r\n    },\r\n    date: {\r\n        takesArg: true,\r\n        helpArg: 'DATE',\r\n        parseArg: parseDate\r\n    },\r\n    arrayOfBool: {\r\n        takesArg: false,\r\n        array: true,\r\n        parseArg: parseBool\r\n    },\r\n    arrayOfString: {\r\n        takesArg: true,\r\n        helpArg: 'ARG',\r\n        array: true,\r\n        parseArg: parseString\r\n    },\r\n    arrayOfNumber: {\r\n        takesArg: true,\r\n        helpArg: 'NUM',\r\n        array: true,\r\n        parseArg: parseNumber\r\n    },\r\n    arrayOfInteger: {\r\n        takesArg: true,\r\n        helpArg: 'INT',\r\n        array: true,\r\n        parseArg: parseInteger\r\n    },\r\n    arrayOfPositiveInteger: {\r\n        takesArg: true,\r\n        helpArg: 'INT',\r\n        array: true,\r\n        parseArg: parsePositiveInteger\r\n    },\r\n    arrayOfDate: {\r\n        takesArg: true,\r\n        helpArg: 'INT',\r\n        array: true,\r\n        parseArg: parseDate\r\n    },\r\n};\r\n\r\n\r\n\r\n// ---- Parser\r\n\r\n/**\r\n * Parser constructor.\r\n *\r\n * @param config {Object} The parser configuration\r\n *      - options {Array} Array of option specs. See the README for how to\r\n *        specify each option spec.\r\n *      - allowUnknown {Boolean} Default false. Whether to throw on unknown\r\n *        options. If false, then unknown args are included in the _args array.\r\n *      - interspersed {Boolean} Default true. Whether to allow interspersed\r\n *        arguments (non-options) and options. E.g.:\r\n *              node tool.js arg1 arg2 -v\r\n *        '-v' is after some args here. If `interspersed: false` then '-v'\r\n *        would not be parsed out. Note that regardless of `interspersed`\r\n *        the presence of '--' will stop option parsing, as all good\r\n *        option parsers should.\r\n */\r\nfunction Parser(config) {\r\n    assert.object(config, 'config');\r\n    assert.arrayOfObject(config.options, 'config.options');\r\n    assert.optionalBool(config.interspersed, 'config.interspersed');\r\n    var self = this;\r\n\r\n    // Allow interspersed arguments (true by default).\r\n    this.interspersed = (config.interspersed !== undefined\r\n        ? config.interspersed : true);\r\n\r\n    // Don't allow unknown flags (true by default).\r\n    this.allowUnknown = (config.allowUnknown !== undefined\r\n        ? config.allowUnknown : false);\r\n\r\n    this.options = config.options.map(function (o) { return shallowCopy(o); });\r\n    this.optionFromName = {};\r\n    this.optionFromEnv = {};\r\n    for (var i = 0; i < this.options.length; i++) {\r\n        var o = this.options[i];\r\n        if (o.group !== undefined && o.group !== null) {\r\n            assert.optionalString(o.group,\r\n                format('config.options.%d.group', i));\r\n            continue;\r\n        }\r\n        assert.ok(optionTypes[o.type],\r\n            format('invalid config.options.%d.type: \"%s\" in %j',\r\n                   i, o.type, o));\r\n        assert.optionalString(o.name, format('config.options.%d.name', i));\r\n        assert.optionalArrayOfString(o.names,\r\n            format('config.options.%d.names', i));\r\n        assert.ok((o.name || o.names) && !(o.name && o.names),\r\n            format('exactly one of \"name\" or \"names\" required: %j', o));\r\n        assert.optionalString(o.help, format('config.options.%d.help', i));\r\n        var env = o.env || [];\r\n        if (typeof (env) === 'string') {\r\n            env = [env];\r\n        }\r\n        assert.optionalArrayOfString(env, format('config.options.%d.env', i));\r\n        assert.optionalString(o.helpGroup,\r\n            format('config.options.%d.helpGroup', i));\r\n        assert.optionalBool(o.helpWrap,\r\n            format('config.options.%d.helpWrap', i));\r\n        assert.optionalBool(o.hidden, format('config.options.%d.hidden', i));\r\n\r\n        if (o.name) {\r\n            o.names = [o.name];\r\n        } else {\r\n            assert.string(o.names[0],\r\n                format('config.options.%d.names is empty', i));\r\n        }\r\n        o.key = optionKeyFromName(o.names[0]);\r\n        o.names.forEach(function (n) {\r\n            if (self.optionFromName[n]) {\r\n                throw new Error(format(\r\n                    'option name collision: \"%s\" used in %j and %j',\r\n                    n, self.optionFromName[n], o));\r\n            }\r\n            self.optionFromName[n] = o;\r\n        });\r\n        env.forEach(function (n) {\r\n            if (self.optionFromEnv[n]) {\r\n                throw new Error(format(\r\n                    'option env collision: \"%s\" used in %j and %j',\r\n                    n, self.optionFromEnv[n], o));\r\n            }\r\n            self.optionFromEnv[n] = o;\r\n        });\r\n    }\r\n}\r\n\r\nParser.prototype.optionTakesArg = function optionTakesArg(option) {\r\n    return optionTypes[option.type].takesArg;\r\n};\r\n\r\n/**\r\n * Parse options from the given argv.\r\n *\r\n * @param inputs {Object} Optional.\r\n *      - argv {Array} Optional. The argv to parse. Defaults to\r\n *        `process.argv`.\r\n *      - slice {Number} The index into argv at which options/args begin.\r\n *        Default is 2, as appropriate for `process.argv`.\r\n *      - env {Object} Optional. The env to use for 'env' entries in the\r\n *        option specs. Defaults to `process.env`.\r\n * @returns {Object} Parsed `opts`. It has special keys `_args` (the\r\n *      remaining args from `argv`) and `_order` (gives the order that\r\n *      options were specified).\r\n */\r\nParser.prototype.parse = function parse(inputs) {\r\n    var self = this;\r\n\r\n    // Old API was `parse([argv, [slice]])`\r\n    if (Array.isArray(arguments[0])) {\r\n        inputs = {argv: arguments[0], slice: arguments[1]};\r\n    }\r\n\r\n    assert.optionalObject(inputs, 'inputs');\r\n    if (!inputs) {\r\n        inputs = {};\r\n    }\r\n    assert.optionalArrayOfString(inputs.argv, 'inputs.argv');\r\n    //assert.optionalNumber(slice, 'slice');\r\n    var argv = inputs.argv || process.argv;\r\n    var slice = inputs.slice !== undefined ? inputs.slice : 2;\r\n    var args = argv.slice(slice);\r\n    var env = inputs.env || process.env;\r\n    var opts = {};\r\n    var _order = [];\r\n\r\n    function addOpt(option, optstr, key, val, from) {\r\n        var type = optionTypes[option.type];\r\n        var parsedVal = type.parseArg(option, optstr, val);\r\n        if (type.array) {\r\n            if (!opts[key]) {\r\n                opts[key] = [];\r\n            }\r\n            if (type.arrayFlatten && Array.isArray(parsedVal)) {\r\n                for (var i = 0; i < parsedVal.length; i++) {\r\n                    opts[key].push(parsedVal[i]);\r\n                }\r\n            } else {\r\n                opts[key].push(parsedVal);\r\n            }\r\n        } else {\r\n            opts[key] = parsedVal;\r\n        }\r\n        var item = { key: key, value: parsedVal, from: from };\r\n        _order.push(item);\r\n    }\r\n\r\n    // Parse args.\r\n    var _args = [];\r\n    var i = 0;\r\n    outer: while (i < args.length) {\r\n        var arg = args[i];\r\n\r\n        // End of options marker.\r\n        if (arg === '--') {\r\n            i++;\r\n            break;\r\n\r\n        // Long option\r\n        } else if (arg.slice(0, 2) === '--') {\r\n            var name = arg.slice(2);\r\n            var val = null;\r\n            var idx = name.indexOf('=');\r\n            if (idx !== -1) {\r\n                val = name.slice(idx + 1);\r\n                name = name.slice(0, idx);\r\n            }\r\n            var option = this.optionFromName[name];\r\n            if (!option) {\r\n                if (!this.allowUnknown)\r\n                    throw new Error(format('unknown option: \"--%s\"', name));\r\n                else if (this.interspersed)\r\n                    _args.push(arg);\r\n                else\r\n                    break outer;\r\n            } else {\r\n                var takesArg = this.optionTakesArg(option);\r\n                if (val !== null && !takesArg) {\r\n                    throw new Error(format('argument given to \"--%s\" option '\r\n                        + 'that does not take one: \"%s\"', name, arg));\r\n                }\r\n                if (!takesArg) {\r\n                    addOpt(option, '--'+name, option.key, true, 'argv');\r\n                } else if (val !== null) {\r\n                    addOpt(option, '--'+name, option.key, val, 'argv');\r\n                } else if (i + 1 >= args.length) {\r\n                    throw new Error(format('do not have enough args for \"--%s\" '\r\n                        + 'option', name));\r\n                } else {\r\n                    addOpt(option, '--'+name, option.key, args[i + 1], 'argv');\r\n                    i++;\r\n                }\r\n            }\r\n\r\n        // Short option\r\n        } else if (arg[0] === '-' && arg.length > 1) {\r\n            var j = 1;\r\n            var allFound = true;\r\n            while (j < arg.length) {\r\n                var name = arg[j];\r\n                var option = this.optionFromName[name];\r\n                if (!option) {\r\n                    allFound = false;\r\n                    if (this.allowUnknown) {\r\n                        if (this.interspersed) {\r\n                            _args.push(arg);\r\n                            break;\r\n                        } else\r\n                            break outer;\r\n                    } else if (arg.length > 2) {\r\n                        throw new Error(format(\r\n                            'unknown option: \"-%s\" in \"%s\" group',\r\n                            name, arg));\r\n                    } else {\r\n                        throw new Error(format('unknown option: \"-%s\"', name));\r\n                    }\r\n                } else if (this.optionTakesArg(option)) {\r\n                    break;\r\n                }\r\n                j++;\r\n            }\r\n\r\n            j = 1;\r\n            while (allFound && j < arg.length) {\r\n                var name = arg[j];\r\n                var val = arg.slice(j + 1);  // option val if it takes an arg\r\n                var option = this.optionFromName[name];\r\n                var takesArg = this.optionTakesArg(option);\r\n                if (!takesArg) {\r\n                    addOpt(option, '-'+name, option.key, true, 'argv');\r\n                } else if (val) {\r\n                    addOpt(option, '-'+name, option.key, val, 'argv');\r\n                    break;\r\n                } else {\r\n                    if (i + 1 >= args.length) {\r\n                        throw new Error(format('do not have enough args '\r\n                            + 'for \"-%s\" option', name));\r\n                    }\r\n                    addOpt(option, '-'+name, option.key, args[i + 1], 'argv');\r\n                    i++;\r\n                    break;\r\n                }\r\n                j++;\r\n            }\r\n\r\n        // An interspersed arg\r\n        } else if (this.interspersed) {\r\n            _args.push(arg);\r\n\r\n        // An arg and interspersed args are not allowed, so done options.\r\n        } else {\r\n            break outer;\r\n        }\r\n        i++;\r\n    }\r\n    _args = _args.concat(args.slice(i));\r\n\r\n    // Parse environment.\r\n    Object.keys(this.optionFromEnv).forEach(function (envname) {\r\n        var val = env[envname];\r\n        if (val === undefined)\r\n            return;\r\n        var option = self.optionFromEnv[envname];\r\n        if (opts[option.key] !== undefined)\r\n            return;\r\n        var takesArg = self.optionTakesArg(option);\r\n        if (takesArg) {\r\n            addOpt(option, envname, option.key, val, 'env');\r\n        } else if (val !== '') {\r\n            // Boolean envvar handling:\r\n            // - VAR=<empty-string>     not set (as if the VAR was not set)\r\n            // - VAR=0                  false\r\n            // - anything else          true\r\n            addOpt(option, envname, option.key, (val !== '0'), 'env');\r\n        }\r\n    });\r\n\r\n    // Apply default values.\r\n    this.options.forEach(function (o) {\r\n        if (opts[o.key] === undefined) {\r\n            if (o.default !== undefined) {\r\n                opts[o.key] = o.default;\r\n            } else if (o.type && optionTypes[o.type].default !== undefined) {\r\n                opts[o.key] = optionTypes[o.type].default;\r\n            }\r\n        }\r\n    });\r\n\r\n    opts._order = _order;\r\n    opts._args = _args;\r\n    return opts;\r\n};\r\n\r\n\r\n/**\r\n * Return help output for the current options.\r\n *\r\n * E.g.: if the current options are:\r\n *      [{names: ['help', 'h'], type: 'bool', help: 'Show help and exit.'}]\r\n * then this would return:\r\n *      '  -h, --help     Show help and exit.\\n'\r\n *\r\n * @param config {Object} Config for controlling the option help output.\r\n *      - indent {Number|String} Default 4. An indent/prefix to use for\r\n *        each option line.\r\n *      - nameSort {String} Default is 'length'. By default the names are\r\n *        sorted to put the short opts first (i.e. '-h, --help' preferred\r\n *        to '--help, -h'). Set to 'none' to not do this sorting.\r\n *      - maxCol {Number} Default 80. Note that long tokens in a help string\r\n *        can go past this.\r\n *      - helpCol {Number} Set to specify a specific column at which\r\n *        option help will be aligned. By default this is determined\r\n *        automatically.\r\n *      - minHelpCol {Number} Default 20.\r\n *      - maxHelpCol {Number} Default 40.\r\n *      - includeEnv {Boolean} Default false. If true, a note stating the `env`\r\n *        envvar (if specified for this option) will be appended to the help\r\n *        output.\r\n *      - includeDefault {Boolean} Default false. If true, a note stating\r\n *        the `default` for this option, if any, will be appended to the help\r\n *        output.\r\n *      - helpWrap {Boolean} Default true. Wrap help text in helpCol..maxCol\r\n *        bounds.\r\n * @returns {String}\r\n */\r\nParser.prototype.help = function help(config) {\r\n    config = config || {};\r\n    assert.object(config, 'config');\r\n\r\n    var indent = makeIndent(config.indent, 4, 'config.indent');\r\n    var headingIndent = makeIndent(config.headingIndent,\r\n        Math.round(indent.length / 2), 'config.headingIndent');\r\n\r\n    assert.optionalString(config.nameSort, 'config.nameSort');\r\n    var nameSort = config.nameSort || 'length';\r\n    assert.ok(~['length', 'none'].indexOf(nameSort),\r\n        'invalid \"config.nameSort\"');\r\n    assert.optionalNumber(config.maxCol, 'config.maxCol');\r\n    assert.optionalNumber(config.maxHelpCol, 'config.maxHelpCol');\r\n    assert.optionalNumber(config.minHelpCol, 'config.minHelpCol');\r\n    assert.optionalNumber(config.helpCol, 'config.helpCol');\r\n    assert.optionalBool(config.includeEnv, 'config.includeEnv');\r\n    assert.optionalBool(config.includeDefault, 'config.includeDefault');\r\n    assert.optionalBool(config.helpWrap, 'config.helpWrap');\r\n    var maxCol = config.maxCol || 80;\r\n    var minHelpCol = config.minHelpCol || 20;\r\n    var maxHelpCol = config.maxHelpCol || 40;\r\n\r\n    var lines = [];\r\n    var maxWidth = 0;\r\n    this.options.forEach(function (o) {\r\n        if (o.hidden) {\r\n            return;\r\n        }\r\n        if (o.group !== undefined && o.group !== null) {\r\n            // We deal with groups in the next pass\r\n            lines.push(null);\r\n            return;\r\n        }\r\n        var type = optionTypes[o.type];\r\n        var arg = o.helpArg || type.helpArg || 'ARG';\r\n        var line = '';\r\n        var names = o.names.slice();\r\n        if (nameSort === 'length') {\r\n            names.sort(function (a, b) {\r\n                if (a.length < b.length)\r\n                    return -1;\r\n                else if (b.length < a.length)\r\n                    return 1;\r\n                else\r\n                    return 0;\r\n            })\r\n        }\r\n        names.forEach(function (name, i) {\r\n            if (i > 0)\r\n                line += ', ';\r\n            if (name.length === 1) {\r\n                line += '-' + name\r\n                if (type.takesArg)\r\n                    line += ' ' + arg;\r\n            } else {\r\n                line += '--' + name\r\n                if (type.takesArg)\r\n                    line += '=' + arg;\r\n            }\r\n        });\r\n        maxWidth = Math.max(maxWidth, line.length);\r\n        lines.push(line);\r\n    });\r\n\r\n    // Add help strings.\r\n    var helpCol = config.helpCol;\r\n    if (!helpCol) {\r\n        helpCol = maxWidth + indent.length + 2;\r\n        helpCol = Math.min(Math.max(helpCol, minHelpCol), maxHelpCol);\r\n    }\r\n    var i = -1;\r\n    this.options.forEach(function (o) {\r\n        if (o.hidden) {\r\n            return;\r\n        }\r\n        i++;\r\n\r\n        if (o.group !== undefined && o.group !== null) {\r\n            if (o.group === '') {\r\n                // Support a empty string \"group\" to have a blank line between\r\n                // sets of options.\r\n                lines[i] = '';\r\n            } else {\r\n                // Render the group heading with the heading-specific indent.\r\n                lines[i] = (i === 0 ? '' : '\\n') + headingIndent +\r\n                    o.group + ':';\r\n            }\r\n            return;\r\n        }\r\n\r\n        var helpDefault;\r\n        if (config.includeDefault) {\r\n            if (o.default !== undefined) {\r\n                helpDefault = format('Default: %j', o.default);\r\n            } else if (o.type && optionTypes[o.type].default !== undefined) {\r\n                helpDefault = format('Default: %j',\r\n                    optionTypes[o.type].default);\r\n            }\r\n        }\r\n\r\n        var line = lines[i] = indent + lines[i];\r\n        if (!o.help && !(config.includeEnv && o.env) && !helpDefault) {\r\n            return;\r\n        }\r\n        var n = helpCol - line.length;\r\n        if (n >= 0) {\r\n            line += space(n);\r\n        } else {\r\n            line += '\\n' + space(helpCol);\r\n        }\r\n\r\n        var helpEnv = '';\r\n        if (o.env && o.env.length && config.includeEnv) {\r\n            helpEnv += 'Environment: ';\r\n            var type = optionTypes[o.type];\r\n            var arg = o.helpArg || type.helpArg || 'ARG';\r\n            var envs = (Array.isArray(o.env) ? o.env : [o.env]).map(\r\n                function (e) {\r\n                    if (type.takesArg) {\r\n                        return e + '=' + arg;\r\n                    } else {\r\n                        return e + '=1';\r\n                    }\r\n                }\r\n            );\r\n            helpEnv += envs.join(', ');\r\n        }\r\n        var help = (o.help || '').trim();\r\n        if (o.helpWrap !== false && config.helpWrap !== false) {\r\n            // Wrap help description normally.\r\n            if (help.length && !~'.!?\"\\''.indexOf(help.slice(-1))) {\r\n                help += '.';\r\n            }\r\n            if (help.length) {\r\n                help += ' ';\r\n            }\r\n            help += helpEnv;\r\n            if (helpDefault) {\r\n                if (helpEnv) {\r\n                    help += '. ';\r\n                }\r\n                help += helpDefault;\r\n            }\r\n            line += textwrap(help, maxCol - helpCol).join(\r\n                '\\n' + space(helpCol));\r\n        } else {\r\n            // Do not wrap help description, but indent newlines appropriately.\r\n            var helpLines = help.split('\\n').filter(\r\n                    function (ln) { return ln.length });\r\n            if (helpEnv !== '') {\r\n                helpLines.push(helpEnv);\r\n            }\r\n            if (helpDefault) {\r\n                helpLines.push(helpDefault);\r\n            }\r\n            line += helpLines.join('\\n' + space(helpCol));\r\n        }\r\n\r\n        lines[i] = line;\r\n    });\r\n\r\n    var rv = '';\r\n    if (lines.length > 0) {\r\n        rv = lines.join('\\n') + '\\n';\r\n    }\r\n    return rv;\r\n};\r\n\r\n\r\n/**\r\n * Return a string suitable for a Bash completion file for this tool.\r\n *\r\n * @param args.name {String} The tool name.\r\n * @param args.specExtra {String} Optional. Extra Bash code content to add\r\n *      to the end of the \"spec\". Typically this is used to append Bash\r\n *      \"complete_TYPE\" functions for custom option types. See\r\n *      \"examples/ddcompletion.js\" for an example.\r\n * @param args.argtypes {Array} Optional. Array of completion types for\r\n *      positional args (i.e. non-options). E.g.\r\n *          argtypes = ['fruit', 'veggie', 'file']\r\n *      will result in completion of fruits for the first arg, veggies for the\r\n *      second, and filenames for the third and subsequent positional args.\r\n *      If not given, positional args will use Bash's 'default' completion.\r\n *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.\r\n *      `complete_fruit` and `complete_veggie` in this example.\r\n */\r\nParser.prototype.bashCompletion = function bashCompletion(args) {\r\n    assert.object(args, 'args');\r\n    assert.string(args.name, 'args.name');\r\n    assert.optionalString(args.specExtra, 'args.specExtra');\r\n    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');\r\n\r\n    return bashCompletionFromOptions({\r\n        name: args.name,\r\n        specExtra: args.specExtra,\r\n        argtypes: args.argtypes,\r\n        options: this.options\r\n    });\r\n};\r\n\r\n\r\n// ---- Bash completion\r\n\r\nconst BASH_COMPLETION_TEMPLATE_PATH = path.join(\r\n    __dirname, '../etc/dashdash.bash_completion.in');\r\n\r\n/**\r\n * Return the Bash completion \"spec\" (the string value for the \"{{spec}}\"\r\n * var in the \"dashdash.bash_completion.in\" template) for this tool.\r\n *\r\n * The \"spec\" is Bash code that defines the CLI options and subcmds for\r\n * the template's completion code. It looks something like this:\r\n *\r\n *      local cmd_shortopts=\"-J ...\"\r\n *      local cmd_longopts=\"--help ...\"\r\n *      local cmd_optargs=\"-p=tritonprofile ...\"\r\n *\r\n * @param args.options {Array} The array of dashdash option specs.\r\n * @param args.context {String} Optional. A context string for the \"local cmd*\"\r\n *      vars in the spec. By default it is the empty string. When used to\r\n *      scope for completion on a *sub-command* (e.g. for \"git log\" on a \"git\"\r\n *      tool), then it would have a value (e.g. \"__log\"). See\r\n *      <http://github.com/trentm/node-cmdln> Bash completion for details.\r\n * @param opts.includeHidden {Boolean} Optional. Default false. By default\r\n *      hidden options and subcmds are \"excluded\". Here excluded means they\r\n *      won't be offered as a completion, but if used, their argument type\r\n *      will be completed. \"Hidden\" options and subcmds are ones with the\r\n *      `hidden: true` attribute to exclude them from default help output.\r\n * @param args.argtypes {Array} Optional. Array of completion types for\r\n *      positional args (i.e. non-options). E.g.\r\n *          argtypes = ['fruit', 'veggie', 'file']\r\n *      will result in completion of fruits for the first arg, veggies for the\r\n *      second, and filenames for the third and subsequent positional args.\r\n *      If not given, positional args will use Bash's 'default' completion.\r\n *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.\r\n *      `complete_fruit` and `complete_veggie` in this example.\r\n */\r\nfunction bashCompletionSpecFromOptions(args) {\r\n    assert.object(args, 'args');\r\n    assert.object(args.options, 'args.options');\r\n    assert.optionalString(args.context, 'args.context');\r\n    assert.optionalBool(args.includeHidden, 'args.includeHidden');\r\n    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');\r\n\r\n    var context = args.context || '';\r\n    var includeHidden = (args.includeHidden === undefined\r\n        ? false : args.includeHidden);\r\n\r\n    var spec = [];\r\n    var shortopts = [];\r\n    var longopts = [];\r\n    var optargs = [];\r\n    (args.options || []).forEach(function (o) {\r\n        if (o.group !== undefined && o.group !== null) {\r\n            // Skip group headers.\r\n            return;\r\n        }\r\n\r\n        var optNames = o.names || [o.name];\r\n        var optType = getOptionType(o.type);\r\n        if (optType.takesArg) {\r\n            var completionType = o.completionType ||\r\n                optType.completionType || o.type;\r\n            optNames.forEach(function (optName) {\r\n                if (optName.length === 1) {\r\n                    if (includeHidden || !o.hidden) {\r\n                        shortopts.push('-' + optName);\r\n                    }\r\n                    // Include even hidden options in `optargs` so that bash\r\n                    // completion of its arg still works.\r\n                    optargs.push('-' + optName + '=' + completionType);\r\n                } else {\r\n                    if (includeHidden || !o.hidden) {\r\n                        longopts.push('--' + optName);\r\n                    }\r\n                    optargs.push('--' + optName + '=' + completionType);\r\n                }\r\n            });\r\n        } else {\r\n            optNames.forEach(function (optName) {\r\n                if (includeHidden || !o.hidden) {\r\n                    if (optName.length === 1) {\r\n                        shortopts.push('-' + optName);\r\n                    } else {\r\n                        longopts.push('--' + optName);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    spec.push(format('local cmd%s_shortopts=\"%s\"',\r\n        context, shortopts.sort().join(' ')));\r\n    spec.push(format('local cmd%s_longopts=\"%s\"',\r\n        context, longopts.sort().join(' ')));\r\n    spec.push(format('local cmd%s_optargs=\"%s\"',\r\n        context, optargs.sort().join(' ')));\r\n    if (args.argtypes) {\r\n        spec.push(format('local cmd%s_argtypes=\"%s\"',\r\n            context, args.argtypes.join(' ')));\r\n    }\r\n    return spec.join('\\n');\r\n}\r\n\r\n\r\n/**\r\n * Return a string suitable for a Bash completion file for this tool.\r\n *\r\n * @param args.name {String} The tool name.\r\n * @param args.options {Array} The array of dashdash option specs.\r\n * @param args.specExtra {String} Optional. Extra Bash code content to add\r\n *      to the end of the \"spec\". Typically this is used to append Bash\r\n *      \"complete_TYPE\" functions for custom option types. See\r\n *      \"examples/ddcompletion.js\" for an example.\r\n * @param args.argtypes {Array} Optional. Array of completion types for\r\n *      positional args (i.e. non-options). E.g.\r\n *          argtypes = ['fruit', 'veggie', 'file']\r\n *      will result in completion of fruits for the first arg, veggies for the\r\n *      second, and filenames for the third and subsequent positional args.\r\n *      If not given, positional args will use Bash's 'default' completion.\r\n *      See `specExtra` for providing Bash `complete_TYPE` functions, e.g.\r\n *      `complete_fruit` and `complete_veggie` in this example.\r\n */\r\nfunction bashCompletionFromOptions(args) {\r\n    assert.object(args, 'args');\r\n    assert.object(args.options, 'args.options');\r\n    assert.string(args.name, 'args.name');\r\n    assert.optionalString(args.specExtra, 'args.specExtra');\r\n    assert.optionalArrayOfString(args.argtypes, 'args.argtypes');\r\n\r\n    // Gather template data.\r\n    var data = {\r\n        name: args.name,\r\n        date: new Date(),\r\n        spec: bashCompletionSpecFromOptions({\r\n            options: args.options,\r\n            argtypes: args.argtypes\r\n        }),\r\n    };\r\n    if (args.specExtra) {\r\n        data.spec += '\\n\\n' + args.specExtra;\r\n    }\r\n\r\n    // Render template.\r\n    var template = fs.readFileSync(BASH_COMPLETION_TEMPLATE_PATH, 'utf8');\r\n    return renderTemplate(template, data);\r\n}\r\n\r\n\r\n\r\n// ---- exports\r\n\r\nfunction createParser(config) {\r\n    return new Parser(config);\r\n}\r\n\r\n/**\r\n * Parse argv with the given options.\r\n *\r\n * @param config {Object} A merge of all the available fields from\r\n *      `dashdash.Parser` and `dashdash.Parser.parse`: options, interspersed,\r\n *      argv, env, slice.\r\n */\r\nfunction parse(config) {\r\n    assert.object(config, 'config');\r\n    assert.optionalArrayOfString(config.argv, 'config.argv');\r\n    assert.optionalObject(config.env, 'config.env');\r\n    var config = shallowCopy(config);\r\n    var argv = config.argv;\r\n    delete config.argv;\r\n    var env = config.env;\r\n    delete config.env;\r\n\r\n    var parser = new Parser(config);\r\n    return parser.parse({argv: argv, env: env});\r\n}\r\n\r\n\r\n/**\r\n * Add a new option type.\r\n *\r\n * @params optionType {Object}:\r\n *      - name {String} Required.\r\n *      - takesArg {Boolean} Required. Whether this type of option takes an\r\n *        argument on process.argv. Typically this is true for all but the\r\n *        \"bool\" type.\r\n *      - helpArg {String} Required iff `takesArg === true`. The string to\r\n *        show in generated help for options of this type.\r\n *      - parseArg {Function} Require. `function (option, optstr, arg)` parser\r\n *        that takes a string argument and returns an instance of the\r\n *        appropriate type, or throws an error if the arg is invalid.\r\n *      - array {Boolean} Optional. Set to true if this is an 'arrayOf' type\r\n *        that collects multiple usages of the option in process.argv and\r\n *        puts results in an array.\r\n *      - arrayFlatten {Boolean} Optional. XXX\r\n *      - default Optional. Default value for options of this type, if no\r\n *        default is specified in the option type usage.\r\n */\r\nfunction addOptionType(optionType) {\r\n    assert.object(optionType, 'optionType');\r\n    assert.string(optionType.name, 'optionType.name');\r\n    assert.bool(optionType.takesArg, 'optionType.takesArg');\r\n    if (optionType.takesArg) {\r\n        assert.string(optionType.helpArg, 'optionType.helpArg');\r\n    }\r\n    assert.func(optionType.parseArg, 'optionType.parseArg');\r\n    assert.optionalBool(optionType.array, 'optionType.array');\r\n    assert.optionalBool(optionType.arrayFlatten, 'optionType.arrayFlatten');\r\n\r\n    optionTypes[optionType.name] = {\r\n        takesArg: optionType.takesArg,\r\n        helpArg: optionType.helpArg,\r\n        parseArg: optionType.parseArg,\r\n        array: optionType.array,\r\n        arrayFlatten: optionType.arrayFlatten,\r\n        default: optionType.default\r\n    }\r\n}\r\n\r\n\r\nfunction getOptionType(name) {\r\n    assert.string(name, 'name');\r\n    return optionTypes[name];\r\n}\r\n\r\n\r\n/**\r\n * Return a synopsis string for the given option spec.\r\n *\r\n * Examples:\r\n *      > synopsisFromOpt({names: ['help', 'h'], type: 'bool'});\r\n *      '[ --help | -h ]'\r\n *      > synopsisFromOpt({name: 'file', type: 'string', helpArg: 'FILE'});\r\n *      '[ --file=FILE ]'\r\n */\r\nfunction synopsisFromOpt(o) {\r\n    assert.object(o, 'o');\r\n\r\n    if (o.hasOwnProperty('group')) {\r\n        return null;\r\n    }\r\n    var names = o.names || [o.name];\r\n    // `type` here could be undefined if, for example, the command has a\r\n    // dashdash option spec with a bogus 'type'.\r\n    var type = getOptionType(o.type);\r\n    var helpArg = o.helpArg || (type && type.helpArg) || 'ARG';\r\n    var parts = [];\r\n    names.forEach(function (name) {\r\n        var part = (name.length === 1 ? '-' : '--') + name;\r\n        if (type && type.takesArg) {\r\n            part += (name.length === 1 ? ' ' + helpArg : '=' + helpArg);\r\n        }\r\n        parts.push(part);\r\n    });\r\n    return ('[ ' + parts.join(' | ') + ' ]');\r\n};\r\n\r\n\r\nmodule.exports = {\r\n    createParser: createParser,\r\n    Parser: Parser,\r\n    parse: parse,\r\n    addOptionType: addOptionType,\r\n    getOptionType: getOptionType,\r\n    synopsisFromOpt: synopsisFromOpt,\r\n\r\n    // Bash completion-related exports\r\n    BASH_COMPLETION_TEMPLATE_PATH: BASH_COMPLETION_TEMPLATE_PATH,\r\n    bashCompletionFromOptions: bashCompletionFromOptions,\r\n    bashCompletionSpecFromOptions: bashCompletionSpecFromOptions,\r\n\r\n    // Export the parseFoo parsers because they might be useful as primitives\r\n    // for custom option types.\r\n    parseBool: parseBool,\r\n    parseString: parseString,\r\n    parseNumber: parseNumber,\r\n    parseInteger: parseInteger,\r\n    parsePositiveInteger: parsePositiveInteger,\r\n    parseDate: parseDate\r\n};\r\n"]}