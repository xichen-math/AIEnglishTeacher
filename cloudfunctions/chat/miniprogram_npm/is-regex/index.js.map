{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nvar callBound = require('call-bound');\r\nvar hasToStringTag = require('has-tostringtag/shams')();\r\nvar hasOwn = require('hasown');\r\nvar gOPD = require('gopd');\r\n\r\n/** @type {import('.')} */\r\nvar fn;\r\n\r\nif (hasToStringTag) {\r\n\t/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */\r\n\tvar $exec = callBound('RegExp.prototype.exec');\r\n\t/** @type {object} */\r\n\tvar isRegexMarker = {};\r\n\r\n\tvar throwRegexMarker = function () {\r\n\t\tthrow isRegexMarker;\r\n\t};\r\n\t/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */\r\n\tvar badStringifier = {\r\n\t\ttoString: throwRegexMarker,\r\n\t\tvalueOf: throwRegexMarker\r\n\t};\r\n\r\n\tif (typeof Symbol.toPrimitive === 'symbol') {\r\n\t\tbadStringifier[Symbol.toPrimitive] = throwRegexMarker;\r\n\t}\r\n\r\n\t/** @type {import('.')} */\r\n\t// @ts-expect-error TS can't figure out that the $exec call always throws\r\n\t// eslint-disable-next-line consistent-return\r\n\tfn = function isRegex(value) {\r\n\t\tif (!value || typeof value !== 'object') {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// eslint-disable-next-line no-extra-parens\r\n\t\tvar descriptor = /** @type {NonNullable<typeof gOPD>} */ (gOPD)(/** @type {{ lastIndex?: unknown }} */ (value), 'lastIndex');\r\n\t\tvar hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');\r\n\t\tif (!hasLastIndexDataProperty) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\t// eslint-disable-next-line no-extra-parens\r\n\t\t\t$exec(value, /** @type {string} */ (/** @type {unknown} */ (badStringifier)));\r\n\t\t} catch (e) {\r\n\t\t\treturn e === isRegexMarker;\r\n\t\t}\r\n\t};\r\n} else {\r\n\t/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */\r\n\tvar $toString = callBound('Object.prototype.toString');\r\n\t/** @const @type {'[object RegExp]'} */\r\n\tvar regexClass = '[object RegExp]';\r\n\r\n\t/** @type {import('.')} */\r\n\tfn = function isRegex(value) {\r\n\t\t// In older browsers, typeof regex incorrectly returns 'function'\r\n\t\tif (!value || (typeof value !== 'object' && typeof value !== 'function')) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn $toString(value) === regexClass;\r\n\t};\r\n}\r\n\r\nmodule.exports = fn;\r\n"]}