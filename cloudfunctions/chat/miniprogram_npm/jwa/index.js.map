{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var bufferEqual = require('buffer-equal-constant-time');\r\nvar Buffer = require('safe-buffer').Buffer;\r\nvar crypto = require('crypto');\r\nvar formatEcdsa = require('ecdsa-sig-formatter');\r\nvar util = require('util');\r\n\r\nvar MSG_INVALID_ALGORITHM = '\"%s\" is not a valid algorithm.\\n  Supported algorithms are:\\n  \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\", \"ES384\", \"ES512\" and \"none\".'\r\nvar MSG_INVALID_SECRET = 'secret must be a string or buffer';\r\nvar MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';\r\nvar MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';\r\n\r\nvar supportsKeyObjects = typeof crypto.createPublicKey === 'function';\r\nif (supportsKeyObjects) {\r\n  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';\r\n  MSG_INVALID_SECRET += 'or a KeyObject';\r\n}\r\n\r\nfunction checkIsPublicKey(key) {\r\n  if (Buffer.isBuffer(key)) {\r\n    return;\r\n  }\r\n\r\n  if (typeof key === 'string') {\r\n    return;\r\n  }\r\n\r\n  if (!supportsKeyObjects) {\r\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\r\n  }\r\n\r\n  if (typeof key !== 'object') {\r\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\r\n  }\r\n\r\n  if (typeof key.type !== 'string') {\r\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\r\n  }\r\n\r\n  if (typeof key.asymmetricKeyType !== 'string') {\r\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\r\n  }\r\n\r\n  if (typeof key.export !== 'function') {\r\n    throw typeError(MSG_INVALID_VERIFIER_KEY);\r\n  }\r\n};\r\n\r\nfunction checkIsPrivateKey(key) {\r\n  if (Buffer.isBuffer(key)) {\r\n    return;\r\n  }\r\n\r\n  if (typeof key === 'string') {\r\n    return;\r\n  }\r\n\r\n  if (typeof key === 'object') {\r\n    return;\r\n  }\r\n\r\n  throw typeError(MSG_INVALID_SIGNER_KEY);\r\n};\r\n\r\nfunction checkIsSecretKey(key) {\r\n  if (Buffer.isBuffer(key)) {\r\n    return;\r\n  }\r\n\r\n  if (typeof key === 'string') {\r\n    return key;\r\n  }\r\n\r\n  if (!supportsKeyObjects) {\r\n    throw typeError(MSG_INVALID_SECRET);\r\n  }\r\n\r\n  if (typeof key !== 'object') {\r\n    throw typeError(MSG_INVALID_SECRET);\r\n  }\r\n\r\n  if (key.type !== 'secret') {\r\n    throw typeError(MSG_INVALID_SECRET);\r\n  }\r\n\r\n  if (typeof key.export !== 'function') {\r\n    throw typeError(MSG_INVALID_SECRET);\r\n  }\r\n}\r\n\r\nfunction fromBase64(base64) {\r\n  return base64\r\n    .replace(/=/g, '')\r\n    .replace(/\\+/g, '-')\r\n    .replace(/\\//g, '_');\r\n}\r\n\r\nfunction toBase64(base64url) {\r\n  base64url = base64url.toString();\r\n\r\n  var padding = 4 - base64url.length % 4;\r\n  if (padding !== 4) {\r\n    for (var i = 0; i < padding; ++i) {\r\n      base64url += '=';\r\n    }\r\n  }\r\n\r\n  return base64url\r\n    .replace(/\\-/g, '+')\r\n    .replace(/_/g, '/');\r\n}\r\n\r\nfunction typeError(template) {\r\n  var args = [].slice.call(arguments, 1);\r\n  var errMsg = util.format.bind(util, template).apply(null, args);\r\n  return new TypeError(errMsg);\r\n}\r\n\r\nfunction bufferOrString(obj) {\r\n  return Buffer.isBuffer(obj) || typeof obj === 'string';\r\n}\r\n\r\nfunction normalizeInput(thing) {\r\n  if (!bufferOrString(thing))\r\n    thing = JSON.stringify(thing);\r\n  return thing;\r\n}\r\n\r\nfunction createHmacSigner(bits) {\r\n  return function sign(thing, secret) {\r\n    checkIsSecretKey(secret);\r\n    thing = normalizeInput(thing);\r\n    var hmac = crypto.createHmac('sha' + bits, secret);\r\n    var sig = (hmac.update(thing), hmac.digest('base64'))\r\n    return fromBase64(sig);\r\n  }\r\n}\r\n\r\nfunction createHmacVerifier(bits) {\r\n  return function verify(thing, signature, secret) {\r\n    var computedSig = createHmacSigner(bits)(thing, secret);\r\n    return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));\r\n  }\r\n}\r\n\r\nfunction createKeySigner(bits) {\r\n return function sign(thing, privateKey) {\r\n    checkIsPrivateKey(privateKey);\r\n    thing = normalizeInput(thing);\r\n    // Even though we are specifying \"RSA\" here, this works with ECDSA\r\n    // keys as well.\r\n    var signer = crypto.createSign('RSA-SHA' + bits);\r\n    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));\r\n    return fromBase64(sig);\r\n  }\r\n}\r\n\r\nfunction createKeyVerifier(bits) {\r\n  return function verify(thing, signature, publicKey) {\r\n    checkIsPublicKey(publicKey);\r\n    thing = normalizeInput(thing);\r\n    signature = toBase64(signature);\r\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\r\n    verifier.update(thing);\r\n    return verifier.verify(publicKey, signature, 'base64');\r\n  }\r\n}\r\n\r\nfunction createPSSKeySigner(bits) {\r\n  return function sign(thing, privateKey) {\r\n    checkIsPrivateKey(privateKey);\r\n    thing = normalizeInput(thing);\r\n    var signer = crypto.createSign('RSA-SHA' + bits);\r\n    var sig = (signer.update(thing), signer.sign({\r\n      key: privateKey,\r\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\r\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\r\n    }, 'base64'));\r\n    return fromBase64(sig);\r\n  }\r\n}\r\n\r\nfunction createPSSKeyVerifier(bits) {\r\n  return function verify(thing, signature, publicKey) {\r\n    checkIsPublicKey(publicKey);\r\n    thing = normalizeInput(thing);\r\n    signature = toBase64(signature);\r\n    var verifier = crypto.createVerify('RSA-SHA' + bits);\r\n    verifier.update(thing);\r\n    return verifier.verify({\r\n      key: publicKey,\r\n      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\r\n      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\r\n    }, signature, 'base64');\r\n  }\r\n}\r\n\r\nfunction createECDSASigner(bits) {\r\n  var inner = createKeySigner(bits);\r\n  return function sign() {\r\n    var signature = inner.apply(null, arguments);\r\n    signature = formatEcdsa.derToJose(signature, 'ES' + bits);\r\n    return signature;\r\n  };\r\n}\r\n\r\nfunction createECDSAVerifer(bits) {\r\n  var inner = createKeyVerifier(bits);\r\n  return function verify(thing, signature, publicKey) {\r\n    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');\r\n    var result = inner(thing, signature, publicKey);\r\n    return result;\r\n  };\r\n}\r\n\r\nfunction createNoneSigner() {\r\n  return function sign() {\r\n    return '';\r\n  }\r\n}\r\n\r\nfunction createNoneVerifier() {\r\n  return function verify(thing, signature) {\r\n    return signature === '';\r\n  }\r\n}\r\n\r\nmodule.exports = function jwa(algorithm) {\r\n  var signerFactories = {\r\n    hs: createHmacSigner,\r\n    rs: createKeySigner,\r\n    ps: createPSSKeySigner,\r\n    es: createECDSASigner,\r\n    none: createNoneSigner,\r\n  }\r\n  var verifierFactories = {\r\n    hs: createHmacVerifier,\r\n    rs: createKeyVerifier,\r\n    ps: createPSSKeyVerifier,\r\n    es: createECDSAVerifer,\r\n    none: createNoneVerifier,\r\n  }\r\n  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);\r\n  if (!match)\r\n    throw typeError(MSG_INVALID_ALGORITHM, algorithm);\r\n  var algo = (match[1] || match[3]).toLowerCase();\r\n  var bits = match[2];\r\n\r\n  return {\r\n    sign: signerFactories[algo](bits),\r\n    verify: verifierFactories[algo](bits),\r\n  }\r\n};\r\n"]}