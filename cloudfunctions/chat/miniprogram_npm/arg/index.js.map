{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const flagSymbol = Symbol('arg flag');\r\n\r\nfunction arg(opts, {argv = process.argv.slice(2), permissive = false, stopAtPositional = false} = {}) {\r\n\tif (!opts) {\r\n\t\tthrow new Error('Argument specification object is required');\r\n\t}\r\n\r\n\tconst result = {_: []};\r\n\r\n\tconst aliases = {};\r\n\tconst handlers = {};\r\n\r\n\tfor (const key of Object.keys(opts)) {\r\n\t\tif (!key) {\r\n\t\t\tthrow new TypeError('Argument key cannot be an empty string');\r\n\t\t}\r\n\r\n\t\tif (key[0] !== '-') {\r\n\t\t\tthrow new TypeError(`Argument key must start with '-' but found: '${key}'`);\r\n\t\t}\r\n\r\n\t\tif (key.length === 1) {\r\n\t\t\tthrow new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${key}`);\r\n\t\t}\r\n\r\n\t\tif (typeof opts[key] === 'string') {\r\n\t\t\taliases[key] = opts[key];\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tlet type = opts[key];\r\n\t\tlet isFlag = false;\r\n\r\n\t\tif (Array.isArray(type) && type.length === 1 && typeof type[0] === 'function') {\r\n\t\t\tconst [fn] = type;\r\n\t\t\ttype = (value, name, prev = []) => {\r\n\t\t\t\tprev.push(fn(value, name, prev[prev.length - 1]));\r\n\t\t\t\treturn prev;\r\n\t\t\t};\r\n\t\t\tisFlag = fn === Boolean || fn[flagSymbol] === true;\r\n\t\t} else if (typeof type === 'function') {\r\n\t\t\tisFlag = type === Boolean || type[flagSymbol] === true;\r\n\t\t} else {\r\n\t\t\tthrow new TypeError(`Type missing or not a function or valid array type: ${key}`);\r\n\t\t}\r\n\r\n\t\tif (key[1] !== '-' && key.length > 2) {\r\n\t\t\tthrow new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${key}`);\r\n\t\t}\r\n\r\n\t\thandlers[key] = [type, isFlag];\r\n\t}\r\n\r\n\tfor (let i = 0, len = argv.length; i < len; i++) {\r\n\t\tconst wholeArg = argv[i];\r\n\r\n\t\tif (stopAtPositional && result._.length > 0) {\r\n\t\t\tresult._ = result._.concat(argv.slice(i));\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (wholeArg === '--') {\r\n\t\t\tresult._ = result._.concat(argv.slice(i + 1));\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (wholeArg.length > 1 && wholeArg[0] === '-') {\r\n\t\t\t/* eslint-disable operator-linebreak */\r\n\t\t\tconst separatedArguments = (wholeArg[1] === '-' || wholeArg.length === 2)\r\n\t\t\t\t? [wholeArg]\r\n\t\t\t\t: wholeArg.slice(1).split('').map(a => `-${a}`);\r\n\t\t\t/* eslint-enable operator-linebreak */\r\n\r\n\t\t\tfor (let j = 0; j < separatedArguments.length; j++) {\r\n\t\t\t\tconst arg = separatedArguments[j];\r\n\t\t\t\tconst [originalArgName, argStr] = arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\r\n\r\n\t\t\t\tlet argName = originalArgName;\r\n\t\t\t\twhile (argName in aliases) {\r\n\t\t\t\t\targName = aliases[argName];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!(argName in handlers)) {\r\n\t\t\t\t\tif (permissive) {\r\n\t\t\t\t\t\tresult._.push(arg);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconst err = new Error(`Unknown or unexpected option: ${originalArgName}`);\r\n\t\t\t\t\t\terr.code = 'ARG_UNKNOWN_OPTION';\r\n\t\t\t\t\t\tthrow err;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst [type, isFlag] = handlers[argName];\r\n\r\n\t\t\t\tif (!isFlag && ((j + 1) < separatedArguments.length)) {\r\n\t\t\t\t\tthrow new TypeError(`Option requires argument (but was followed by another short argument): ${originalArgName}`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isFlag) {\r\n\t\t\t\t\tresult[argName] = type(true, argName, result[argName]);\r\n\t\t\t\t} else if (argStr === undefined) {\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\targv.length < i + 2 ||\r\n\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\targv[i + 1].length > 1 &&\r\n\t\t\t\t\t\t\t(argv[i + 1][0] === '-') &&\r\n\t\t\t\t\t\t\t!(\r\n\t\t\t\t\t\t\t\targv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) &&\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\ttype === Number ||\r\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line no-undef\r\n\t\t\t\t\t\t\t\t\t(typeof BigInt !== 'undefined' && type === BigInt)\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tconst extended = originalArgName === argName ? '' : ` (alias for ${argName})`;\r\n\t\t\t\t\t\tthrow new Error(`Option requires argument: ${originalArgName}${extended}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresult[argName] = type(argv[i + 1], argName, result[argName]);\r\n\t\t\t\t\t++i;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult[argName] = type(argStr, argName, result[argName]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tresult._.push(wholeArg);\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\narg.flag = fn => {\r\n\tfn[flagSymbol] = true;\r\n\treturn fn;\r\n};\r\n\r\n// Utility types\r\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);\r\n\r\nmodule.exports = arg;\r\n"]}