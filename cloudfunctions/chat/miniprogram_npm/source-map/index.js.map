{"version":3,"sources":["source-map.js","lib/source-map-generator.js","lib/base64-vlq.js","lib/base64.js","lib/util.js","lib/array-set.js","lib/mapping-list.js","lib/source-map-consumer.js","lib/binary-search.js","lib/quick-sort.js","lib/source-node.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AGTA,ALeA,AGTA;ACFA,AHSA,ACHA,AGTA,ALeA,AGTA;ACFA,AHSA,ACHA,AGTA,ALeA,AGTA;ACFA,AHSA,ACHA,AGTA,ACHA,ANkBA,AGTA;ACFA,AHSA,ACHA,AGTA,ACHA,ANkBA,AGTA;ACFA,AHSA,ACHA,AGTA,ACHA,ANkBA,AGTA;ACFA,AHSA,ACHA,AKfA,AFMA,ACHA,ANkBA,AGTA;ACFA,AHSA,ACHA,AKfA,AFMA,ACHA,ANkBA,AGTA;ACFA,AHSA,ACHA,AKfA,AFMA,ACHA,ANkBA,AGTA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AGTA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AGTA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AGTA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,ACHA,AKfA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,AFMA,AGTA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AMlBA,ACHA,AFMA,ANkBA,AS3BA,ANkBA;ACFA,AHSA,AOrBA,AFMA,ANkBA,AS3BA,ANkBA;AFOA,AOrBA,AFMA,ANkBA,AS3BA,ANkBA;AFOA,AOrBA,AFMA,ANkBA,AS3BA,ANkBA;AFOA,AOrBA,AFMA,ANkBA,AS3BA,ANkBA;AFOA,AOrBA,AFMA,ANkBA,AS3BA,ANkBA;AFOA,AOrBA,AFMA,ANkBA,AS3BA,ANkBA;AFOA,AKfA,ANkBA,AS3BA,ANkBA;AFOA,AKfA,ANkBA,AS3BA,ANkBA;AFOA,AKfA,ANkBA,AS3BA,ANkBA;AFOA,AKfA,ANkBA,AS3BA,ANkBA;AFOA,AKfA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,ANkBA,AS3BA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AGTA,ANkBA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*\r\n * Copyright 2009-2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE.txt or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\r\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\r\nexports.SourceNode = require('./lib/source-node').SourceNode;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar base64VLQ = require('./base64-vlq');\r\nvar util = require('./util');\r\nvar ArraySet = require('./array-set').ArraySet;\r\nvar MappingList = require('./mapping-list').MappingList;\r\n\r\n/**\r\n * An instance of the SourceMapGenerator represents a source map which is\r\n * being built incrementally. You may pass an object with the following\r\n * properties:\r\n *\r\n *   - file: The filename of the generated source.\r\n *   - sourceRoot: A root for all relative URLs in this source map.\r\n */\r\nfunction SourceMapGenerator(aArgs) {\r\n  if (!aArgs) {\r\n    aArgs = {};\r\n  }\r\n  this._file = util.getArg(aArgs, 'file', null);\r\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\r\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\r\n  this._sources = new ArraySet();\r\n  this._names = new ArraySet();\r\n  this._mappings = new MappingList();\r\n  this._sourcesContents = null;\r\n}\r\n\r\nSourceMapGenerator.prototype._version = 3;\r\n\r\n/**\r\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\r\n *\r\n * @param aSourceMapConsumer The SourceMap.\r\n */\r\nSourceMapGenerator.fromSourceMap =\r\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\r\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\r\n    var generator = new SourceMapGenerator({\r\n      file: aSourceMapConsumer.file,\r\n      sourceRoot: sourceRoot\r\n    });\r\n    aSourceMapConsumer.eachMapping(function (mapping) {\r\n      var newMapping = {\r\n        generated: {\r\n          line: mapping.generatedLine,\r\n          column: mapping.generatedColumn\r\n        }\r\n      };\r\n\r\n      if (mapping.source != null) {\r\n        newMapping.source = mapping.source;\r\n        if (sourceRoot != null) {\r\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\r\n        }\r\n\r\n        newMapping.original = {\r\n          line: mapping.originalLine,\r\n          column: mapping.originalColumn\r\n        };\r\n\r\n        if (mapping.name != null) {\r\n          newMapping.name = mapping.name;\r\n        }\r\n      }\r\n\r\n      generator.addMapping(newMapping);\r\n    });\r\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\r\n      var sourceRelative = sourceFile;\r\n      if (sourceRoot !== null) {\r\n        sourceRelative = util.relative(sourceRoot, sourceFile);\r\n      }\r\n\r\n      if (!generator._sources.has(sourceRelative)) {\r\n        generator._sources.add(sourceRelative);\r\n      }\r\n\r\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n      if (content != null) {\r\n        generator.setSourceContent(sourceFile, content);\r\n      }\r\n    });\r\n    return generator;\r\n  };\r\n\r\n/**\r\n * Add a single mapping from original source line and column to the generated\r\n * source's line and column for this source map being created. The mapping\r\n * object should have the following properties:\r\n *\r\n *   - generated: An object with the generated line and column positions.\r\n *   - original: An object with the original line and column positions.\r\n *   - source: The original source file (relative to the sourceRoot).\r\n *   - name: An optional original token name for this mapping.\r\n */\r\nSourceMapGenerator.prototype.addMapping =\r\n  function SourceMapGenerator_addMapping(aArgs) {\r\n    var generated = util.getArg(aArgs, 'generated');\r\n    var original = util.getArg(aArgs, 'original', null);\r\n    var source = util.getArg(aArgs, 'source', null);\r\n    var name = util.getArg(aArgs, 'name', null);\r\n\r\n    if (!this._skipValidation) {\r\n      this._validateMapping(generated, original, source, name);\r\n    }\r\n\r\n    if (source != null) {\r\n      source = String(source);\r\n      if (!this._sources.has(source)) {\r\n        this._sources.add(source);\r\n      }\r\n    }\r\n\r\n    if (name != null) {\r\n      name = String(name);\r\n      if (!this._names.has(name)) {\r\n        this._names.add(name);\r\n      }\r\n    }\r\n\r\n    this._mappings.add({\r\n      generatedLine: generated.line,\r\n      generatedColumn: generated.column,\r\n      originalLine: original != null && original.line,\r\n      originalColumn: original != null && original.column,\r\n      source: source,\r\n      name: name\r\n    });\r\n  };\r\n\r\n/**\r\n * Set the source content for a source file.\r\n */\r\nSourceMapGenerator.prototype.setSourceContent =\r\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\r\n    var source = aSourceFile;\r\n    if (this._sourceRoot != null) {\r\n      source = util.relative(this._sourceRoot, source);\r\n    }\r\n\r\n    if (aSourceContent != null) {\r\n      // Add the source content to the _sourcesContents map.\r\n      // Create a new _sourcesContents map if the property is null.\r\n      if (!this._sourcesContents) {\r\n        this._sourcesContents = Object.create(null);\r\n      }\r\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\r\n    } else if (this._sourcesContents) {\r\n      // Remove the source file from the _sourcesContents map.\r\n      // If the _sourcesContents map is empty, set the property to null.\r\n      delete this._sourcesContents[util.toSetString(source)];\r\n      if (Object.keys(this._sourcesContents).length === 0) {\r\n        this._sourcesContents = null;\r\n      }\r\n    }\r\n  };\r\n\r\n/**\r\n * Applies the mappings of a sub-source-map for a specific source file to the\r\n * source map being generated. Each mapping to the supplied source file is\r\n * rewritten using the supplied source map. Note: The resolution for the\r\n * resulting mappings is the minimium of this map and the supplied map.\r\n *\r\n * @param aSourceMapConsumer The source map to be applied.\r\n * @param aSourceFile Optional. The filename of the source file.\r\n *        If omitted, SourceMapConsumer's file property will be used.\r\n * @param aSourceMapPath Optional. The dirname of the path to the source map\r\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\r\n *        This parameter is needed when the two source maps aren't in the same\r\n *        directory, and the source map to be applied contains relative source\r\n *        paths. If so, those relative source paths need to be rewritten\r\n *        relative to the SourceMapGenerator.\r\n */\r\nSourceMapGenerator.prototype.applySourceMap =\r\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\r\n    var sourceFile = aSourceFile;\r\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\r\n    if (aSourceFile == null) {\r\n      if (aSourceMapConsumer.file == null) {\r\n        throw new Error(\r\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\r\n          'or the source map\\'s \"file\" property. Both were omitted.'\r\n        );\r\n      }\r\n      sourceFile = aSourceMapConsumer.file;\r\n    }\r\n    var sourceRoot = this._sourceRoot;\r\n    // Make \"sourceFile\" relative if an absolute Url is passed.\r\n    if (sourceRoot != null) {\r\n      sourceFile = util.relative(sourceRoot, sourceFile);\r\n    }\r\n    // Applying the SourceMap can add and remove items from the sources and\r\n    // the names array.\r\n    var newSources = new ArraySet();\r\n    var newNames = new ArraySet();\r\n\r\n    // Find mappings for the \"sourceFile\"\r\n    this._mappings.unsortedForEach(function (mapping) {\r\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\r\n        // Check if it can be mapped by the source map, then update the mapping.\r\n        var original = aSourceMapConsumer.originalPositionFor({\r\n          line: mapping.originalLine,\r\n          column: mapping.originalColumn\r\n        });\r\n        if (original.source != null) {\r\n          // Copy mapping\r\n          mapping.source = original.source;\r\n          if (aSourceMapPath != null) {\r\n            mapping.source = util.join(aSourceMapPath, mapping.source)\r\n          }\r\n          if (sourceRoot != null) {\r\n            mapping.source = util.relative(sourceRoot, mapping.source);\r\n          }\r\n          mapping.originalLine = original.line;\r\n          mapping.originalColumn = original.column;\r\n          if (original.name != null) {\r\n            mapping.name = original.name;\r\n          }\r\n        }\r\n      }\r\n\r\n      var source = mapping.source;\r\n      if (source != null && !newSources.has(source)) {\r\n        newSources.add(source);\r\n      }\r\n\r\n      var name = mapping.name;\r\n      if (name != null && !newNames.has(name)) {\r\n        newNames.add(name);\r\n      }\r\n\r\n    }, this);\r\n    this._sources = newSources;\r\n    this._names = newNames;\r\n\r\n    // Copy sourcesContents of applied map.\r\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\r\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n      if (content != null) {\r\n        if (aSourceMapPath != null) {\r\n          sourceFile = util.join(aSourceMapPath, sourceFile);\r\n        }\r\n        if (sourceRoot != null) {\r\n          sourceFile = util.relative(sourceRoot, sourceFile);\r\n        }\r\n        this.setSourceContent(sourceFile, content);\r\n      }\r\n    }, this);\r\n  };\r\n\r\n/**\r\n * A mapping can have one of the three levels of data:\r\n *\r\n *   1. Just the generated position.\r\n *   2. The Generated position, original position, and original source.\r\n *   3. Generated and original position, original source, as well as a name\r\n *      token.\r\n *\r\n * To maintain consistency, we validate that any new mapping being added falls\r\n * in to one of these categories.\r\n */\r\nSourceMapGenerator.prototype._validateMapping =\r\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\r\n                                              aName) {\r\n    // When aOriginal is truthy but has empty values for .line and .column,\r\n    // it is most likely a programmer error. In this case we throw a very\r\n    // specific error message to try to guide them the right way.\r\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\r\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\r\n        throw new Error(\r\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\r\n            'the original mapping entirely and only map the generated position. If so, pass ' +\r\n            'null for the original mapping instead of an object with empty or null values.'\r\n        );\r\n    }\r\n\r\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\r\n        && aGenerated.line > 0 && aGenerated.column >= 0\r\n        && !aOriginal && !aSource && !aName) {\r\n      // Case 1.\r\n      return;\r\n    }\r\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\r\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\r\n             && aGenerated.line > 0 && aGenerated.column >= 0\r\n             && aOriginal.line > 0 && aOriginal.column >= 0\r\n             && aSource) {\r\n      // Cases 2 and 3.\r\n      return;\r\n    }\r\n    else {\r\n      throw new Error('Invalid mapping: ' + JSON.stringify({\r\n        generated: aGenerated,\r\n        source: aSource,\r\n        original: aOriginal,\r\n        name: aName\r\n      }));\r\n    }\r\n  };\r\n\r\n/**\r\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\r\n * specified by the source map format.\r\n */\r\nSourceMapGenerator.prototype._serializeMappings =\r\n  function SourceMapGenerator_serializeMappings() {\r\n    var previousGeneratedColumn = 0;\r\n    var previousGeneratedLine = 1;\r\n    var previousOriginalColumn = 0;\r\n    var previousOriginalLine = 0;\r\n    var previousName = 0;\r\n    var previousSource = 0;\r\n    var result = '';\r\n    var next;\r\n    var mapping;\r\n    var nameIdx;\r\n    var sourceIdx;\r\n\r\n    var mappings = this._mappings.toArray();\r\n    for (var i = 0, len = mappings.length; i < len; i++) {\r\n      mapping = mappings[i];\r\n      next = ''\r\n\r\n      if (mapping.generatedLine !== previousGeneratedLine) {\r\n        previousGeneratedColumn = 0;\r\n        while (mapping.generatedLine !== previousGeneratedLine) {\r\n          next += ';';\r\n          previousGeneratedLine++;\r\n        }\r\n      }\r\n      else {\r\n        if (i > 0) {\r\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\r\n            continue;\r\n          }\r\n          next += ',';\r\n        }\r\n      }\r\n\r\n      next += base64VLQ.encode(mapping.generatedColumn\r\n                                 - previousGeneratedColumn);\r\n      previousGeneratedColumn = mapping.generatedColumn;\r\n\r\n      if (mapping.source != null) {\r\n        sourceIdx = this._sources.indexOf(mapping.source);\r\n        next += base64VLQ.encode(sourceIdx - previousSource);\r\n        previousSource = sourceIdx;\r\n\r\n        // lines are stored 0-based in SourceMap spec version 3\r\n        next += base64VLQ.encode(mapping.originalLine - 1\r\n                                   - previousOriginalLine);\r\n        previousOriginalLine = mapping.originalLine - 1;\r\n\r\n        next += base64VLQ.encode(mapping.originalColumn\r\n                                   - previousOriginalColumn);\r\n        previousOriginalColumn = mapping.originalColumn;\r\n\r\n        if (mapping.name != null) {\r\n          nameIdx = this._names.indexOf(mapping.name);\r\n          next += base64VLQ.encode(nameIdx - previousName);\r\n          previousName = nameIdx;\r\n        }\r\n      }\r\n\r\n      result += next;\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\nSourceMapGenerator.prototype._generateSourcesContent =\r\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\r\n    return aSources.map(function (source) {\r\n      if (!this._sourcesContents) {\r\n        return null;\r\n      }\r\n      if (aSourceRoot != null) {\r\n        source = util.relative(aSourceRoot, source);\r\n      }\r\n      var key = util.toSetString(source);\r\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\r\n        ? this._sourcesContents[key]\r\n        : null;\r\n    }, this);\r\n  };\r\n\r\n/**\r\n * Externalize the source map.\r\n */\r\nSourceMapGenerator.prototype.toJSON =\r\n  function SourceMapGenerator_toJSON() {\r\n    var map = {\r\n      version: this._version,\r\n      sources: this._sources.toArray(),\r\n      names: this._names.toArray(),\r\n      mappings: this._serializeMappings()\r\n    };\r\n    if (this._file != null) {\r\n      map.file = this._file;\r\n    }\r\n    if (this._sourceRoot != null) {\r\n      map.sourceRoot = this._sourceRoot;\r\n    }\r\n    if (this._sourcesContents) {\r\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\r\n    }\r\n\r\n    return map;\r\n  };\r\n\r\n/**\r\n * Render the source map being generated to a string.\r\n */\r\nSourceMapGenerator.prototype.toString =\r\n  function SourceMapGenerator_toString() {\r\n    return JSON.stringify(this.toJSON());\r\n  };\r\n\r\nexports.SourceMapGenerator = SourceMapGenerator;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n *\r\n * Based on the Base 64 VLQ implementation in Closure Compiler:\r\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\r\n *\r\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *  * Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above\r\n *    copyright notice, this list of conditions and the following\r\n *    disclaimer in the documentation and/or other materials provided\r\n *    with the distribution.\r\n *  * Neither the name of Google Inc. nor the names of its\r\n *    contributors may be used to endorse or promote products derived\r\n *    from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar base64 = require('./base64');\r\n\r\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\r\n// length quantities we use in the source map spec, the first bit is the sign,\r\n// the next four bits are the actual value, and the 6th bit is the\r\n// continuation bit. The continuation bit tells us whether there are more\r\n// digits in this value following this digit.\r\n//\r\n//   Continuation\r\n//   |    Sign\r\n//   |    |\r\n//   V    V\r\n//   101011\r\n\r\nvar VLQ_BASE_SHIFT = 5;\r\n\r\n// binary: 100000\r\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\r\n\r\n// binary: 011111\r\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\r\n\r\n// binary: 100000\r\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\r\n\r\n/**\r\n * Converts from a two-complement value to a value where the sign bit is\r\n * placed in the least significant bit.  For example, as decimals:\r\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\r\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\r\n */\r\nfunction toVLQSigned(aValue) {\r\n  return aValue < 0\r\n    ? ((-aValue) << 1) + 1\r\n    : (aValue << 1) + 0;\r\n}\r\n\r\n/**\r\n * Converts to a two-complement value from a value where the sign bit is\r\n * placed in the least significant bit.  For example, as decimals:\r\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\r\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\r\n */\r\nfunction fromVLQSigned(aValue) {\r\n  var isNegative = (aValue & 1) === 1;\r\n  var shifted = aValue >> 1;\r\n  return isNegative\r\n    ? -shifted\r\n    : shifted;\r\n}\r\n\r\n/**\r\n * Returns the base 64 VLQ encoded value.\r\n */\r\nexports.encode = function base64VLQ_encode(aValue) {\r\n  var encoded = \"\";\r\n  var digit;\r\n\r\n  var vlq = toVLQSigned(aValue);\r\n\r\n  do {\r\n    digit = vlq & VLQ_BASE_MASK;\r\n    vlq >>>= VLQ_BASE_SHIFT;\r\n    if (vlq > 0) {\r\n      // There are still more digits in this value, so we must make sure the\r\n      // continuation bit is marked.\r\n      digit |= VLQ_CONTINUATION_BIT;\r\n    }\r\n    encoded += base64.encode(digit);\r\n  } while (vlq > 0);\r\n\r\n  return encoded;\r\n};\r\n\r\n/**\r\n * Decodes the next base 64 VLQ value from the given string and returns the\r\n * value and the rest of the string via the out parameter.\r\n */\r\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\r\n  var strLen = aStr.length;\r\n  var result = 0;\r\n  var shift = 0;\r\n  var continuation, digit;\r\n\r\n  do {\r\n    if (aIndex >= strLen) {\r\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\r\n    }\r\n\r\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\r\n    if (digit === -1) {\r\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\r\n    }\r\n\r\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\r\n    digit &= VLQ_BASE_MASK;\r\n    result = result + (digit << shift);\r\n    shift += VLQ_BASE_SHIFT;\r\n  } while (continuation);\r\n\r\n  aOutParam.value = fromVLQSigned(result);\r\n  aOutParam.rest = aIndex;\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\r\n\r\n/**\r\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\r\n */\r\nexports.encode = function (number) {\r\n  if (0 <= number && number < intToCharMap.length) {\r\n    return intToCharMap[number];\r\n  }\r\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\r\n};\r\n\r\n/**\r\n * Decode a single base 64 character code digit to an integer. Returns -1 on\r\n * failure.\r\n */\r\nexports.decode = function (charCode) {\r\n  var bigA = 65;     // 'A'\r\n  var bigZ = 90;     // 'Z'\r\n\r\n  var littleA = 97;  // 'a'\r\n  var littleZ = 122; // 'z'\r\n\r\n  var zero = 48;     // '0'\r\n  var nine = 57;     // '9'\r\n\r\n  var plus = 43;     // '+'\r\n  var slash = 47;    // '/'\r\n\r\n  var littleOffset = 26;\r\n  var numberOffset = 52;\r\n\r\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n  if (bigA <= charCode && charCode <= bigZ) {\r\n    return (charCode - bigA);\r\n  }\r\n\r\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\r\n  if (littleA <= charCode && charCode <= littleZ) {\r\n    return (charCode - littleA + littleOffset);\r\n  }\r\n\r\n  // 52 - 61: 0123456789\r\n  if (zero <= charCode && charCode <= nine) {\r\n    return (charCode - zero + numberOffset);\r\n  }\r\n\r\n  // 62: +\r\n  if (charCode == plus) {\r\n    return 62;\r\n  }\r\n\r\n  // 63: /\r\n  if (charCode == slash) {\r\n    return 63;\r\n  }\r\n\r\n  // Invalid base64 digit.\r\n  return -1;\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\n/**\r\n * This is a helper function for getting values from parameter/options\r\n * objects.\r\n *\r\n * @param args The object we are extracting values from\r\n * @param name The name of the property we are getting.\r\n * @param defaultValue An optional value to return if the property is missing\r\n * from the object. If this is not specified and the property is missing, an\r\n * error will be thrown.\r\n */\r\nfunction getArg(aArgs, aName, aDefaultValue) {\r\n  if (aName in aArgs) {\r\n    return aArgs[aName];\r\n  } else if (arguments.length === 3) {\r\n    return aDefaultValue;\r\n  } else {\r\n    throw new Error('\"' + aName + '\" is a required argument.');\r\n  }\r\n}\r\nexports.getArg = getArg;\r\n\r\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\r\nvar dataUrlRegexp = /^data:.+\\,.+$/;\r\n\r\nfunction urlParse(aUrl) {\r\n  var match = aUrl.match(urlRegexp);\r\n  if (!match) {\r\n    return null;\r\n  }\r\n  return {\r\n    scheme: match[1],\r\n    auth: match[2],\r\n    host: match[3],\r\n    port: match[4],\r\n    path: match[5]\r\n  };\r\n}\r\nexports.urlParse = urlParse;\r\n\r\nfunction urlGenerate(aParsedUrl) {\r\n  var url = '';\r\n  if (aParsedUrl.scheme) {\r\n    url += aParsedUrl.scheme + ':';\r\n  }\r\n  url += '//';\r\n  if (aParsedUrl.auth) {\r\n    url += aParsedUrl.auth + '@';\r\n  }\r\n  if (aParsedUrl.host) {\r\n    url += aParsedUrl.host;\r\n  }\r\n  if (aParsedUrl.port) {\r\n    url += \":\" + aParsedUrl.port\r\n  }\r\n  if (aParsedUrl.path) {\r\n    url += aParsedUrl.path;\r\n  }\r\n  return url;\r\n}\r\nexports.urlGenerate = urlGenerate;\r\n\r\n/**\r\n * Normalizes a path, or the path portion of a URL:\r\n *\r\n * - Replaces consecutive slashes with one slash.\r\n * - Removes unnecessary '.' parts.\r\n * - Removes unnecessary '<dir>/..' parts.\r\n *\r\n * Based on code in the Node.js 'path' core module.\r\n *\r\n * @param aPath The path or url to normalize.\r\n */\r\nfunction normalize(aPath) {\r\n  var path = aPath;\r\n  var url = urlParse(aPath);\r\n  if (url) {\r\n    if (!url.path) {\r\n      return aPath;\r\n    }\r\n    path = url.path;\r\n  }\r\n  var isAbsolute = exports.isAbsolute(path);\r\n\r\n  var parts = path.split(/\\/+/);\r\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\r\n    part = parts[i];\r\n    if (part === '.') {\r\n      parts.splice(i, 1);\r\n    } else if (part === '..') {\r\n      up++;\r\n    } else if (up > 0) {\r\n      if (part === '') {\r\n        // The first part is blank if the path is absolute. Trying to go\r\n        // above the root is a no-op. Therefore we can remove all '..' parts\r\n        // directly after the root.\r\n        parts.splice(i + 1, up);\r\n        up = 0;\r\n      } else {\r\n        parts.splice(i, 2);\r\n        up--;\r\n      }\r\n    }\r\n  }\r\n  path = parts.join('/');\r\n\r\n  if (path === '') {\r\n    path = isAbsolute ? '/' : '.';\r\n  }\r\n\r\n  if (url) {\r\n    url.path = path;\r\n    return urlGenerate(url);\r\n  }\r\n  return path;\r\n}\r\nexports.normalize = normalize;\r\n\r\n/**\r\n * Joins two paths/URLs.\r\n *\r\n * @param aRoot The root path or URL.\r\n * @param aPath The path or URL to be joined with the root.\r\n *\r\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\r\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\r\n *   first.\r\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\r\n *   is updated with the result and aRoot is returned. Otherwise the result\r\n *   is returned.\r\n *   - If aPath is absolute, the result is aPath.\r\n *   - Otherwise the two paths are joined with a slash.\r\n * - Joining for example 'http://' and 'www.example.com' is also supported.\r\n */\r\nfunction join(aRoot, aPath) {\r\n  if (aRoot === \"\") {\r\n    aRoot = \".\";\r\n  }\r\n  if (aPath === \"\") {\r\n    aPath = \".\";\r\n  }\r\n  var aPathUrl = urlParse(aPath);\r\n  var aRootUrl = urlParse(aRoot);\r\n  if (aRootUrl) {\r\n    aRoot = aRootUrl.path || '/';\r\n  }\r\n\r\n  // `join(foo, '//www.example.org')`\r\n  if (aPathUrl && !aPathUrl.scheme) {\r\n    if (aRootUrl) {\r\n      aPathUrl.scheme = aRootUrl.scheme;\r\n    }\r\n    return urlGenerate(aPathUrl);\r\n  }\r\n\r\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\r\n    return aPath;\r\n  }\r\n\r\n  // `join('http://', 'www.example.com')`\r\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\r\n    aRootUrl.host = aPath;\r\n    return urlGenerate(aRootUrl);\r\n  }\r\n\r\n  var joined = aPath.charAt(0) === '/'\r\n    ? aPath\r\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\r\n\r\n  if (aRootUrl) {\r\n    aRootUrl.path = joined;\r\n    return urlGenerate(aRootUrl);\r\n  }\r\n  return joined;\r\n}\r\nexports.join = join;\r\n\r\nexports.isAbsolute = function (aPath) {\r\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\r\n};\r\n\r\n/**\r\n * Make a path relative to a URL or another path.\r\n *\r\n * @param aRoot The root path or URL.\r\n * @param aPath The path or URL to be made relative to aRoot.\r\n */\r\nfunction relative(aRoot, aPath) {\r\n  if (aRoot === \"\") {\r\n    aRoot = \".\";\r\n  }\r\n\r\n  aRoot = aRoot.replace(/\\/$/, '');\r\n\r\n  // It is possible for the path to be above the root. In this case, simply\r\n  // checking whether the root is a prefix of the path won't work. Instead, we\r\n  // need to remove components from the root one by one, until either we find\r\n  // a prefix that fits, or we run out of components to remove.\r\n  var level = 0;\r\n  while (aPath.indexOf(aRoot + '/') !== 0) {\r\n    var index = aRoot.lastIndexOf(\"/\");\r\n    if (index < 0) {\r\n      return aPath;\r\n    }\r\n\r\n    // If the only part of the root that is left is the scheme (i.e. http://,\r\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\r\n    // have exhausted all components, so the path is not relative to the root.\r\n    aRoot = aRoot.slice(0, index);\r\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\r\n      return aPath;\r\n    }\r\n\r\n    ++level;\r\n  }\r\n\r\n  // Make sure we add a \"../\" for each component we removed from the root.\r\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\r\n}\r\nexports.relative = relative;\r\n\r\nvar supportsNullProto = (function () {\r\n  var obj = Object.create(null);\r\n  return !('__proto__' in obj);\r\n}());\r\n\r\nfunction identity (s) {\r\n  return s;\r\n}\r\n\r\n/**\r\n * Because behavior goes wacky when you set `__proto__` on objects, we\r\n * have to prefix all the strings in our set with an arbitrary character.\r\n *\r\n * See https://github.com/mozilla/source-map/pull/31 and\r\n * https://github.com/mozilla/source-map/issues/30\r\n *\r\n * @param String aStr\r\n */\r\nfunction toSetString(aStr) {\r\n  if (isProtoString(aStr)) {\r\n    return '$' + aStr;\r\n  }\r\n\r\n  return aStr;\r\n}\r\nexports.toSetString = supportsNullProto ? identity : toSetString;\r\n\r\nfunction fromSetString(aStr) {\r\n  if (isProtoString(aStr)) {\r\n    return aStr.slice(1);\r\n  }\r\n\r\n  return aStr;\r\n}\r\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\r\n\r\nfunction isProtoString(s) {\r\n  if (!s) {\r\n    return false;\r\n  }\r\n\r\n  var length = s.length;\r\n\r\n  if (length < 9 /* \"__proto__\".length */) {\r\n    return false;\r\n  }\r\n\r\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\r\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\r\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\r\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\r\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\r\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\r\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\r\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\r\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\r\n    return false;\r\n  }\r\n\r\n  for (var i = length - 10; i >= 0; i--) {\r\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Comparator between two mappings where the original positions are compared.\r\n *\r\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\r\n * mappings with the same original source/line/column, but different generated\r\n * line and column the same. Useful when searching for a mapping with a\r\n * stubbed out mapping.\r\n */\r\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\r\n  var cmp = strcmp(mappingA.source, mappingB.source);\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalLine - mappingB.originalLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\r\n  if (cmp !== 0 || onlyCompareOriginal) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  return strcmp(mappingA.name, mappingB.name);\r\n}\r\nexports.compareByOriginalPositions = compareByOriginalPositions;\r\n\r\n/**\r\n * Comparator between two mappings with deflated source and name indices where\r\n * the generated positions are compared.\r\n *\r\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\r\n * mappings with the same generated line and column, but different\r\n * source/name/original line and column the same. Useful when searching for a\r\n * mapping with a stubbed out mapping.\r\n */\r\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\r\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\r\n  if (cmp !== 0 || onlyCompareGenerated) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = strcmp(mappingA.source, mappingB.source);\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalLine - mappingB.originalLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  return strcmp(mappingA.name, mappingB.name);\r\n}\r\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\r\n\r\nfunction strcmp(aStr1, aStr2) {\r\n  if (aStr1 === aStr2) {\r\n    return 0;\r\n  }\r\n\r\n  if (aStr1 === null) {\r\n    return 1; // aStr2 !== null\r\n  }\r\n\r\n  if (aStr2 === null) {\r\n    return -1; // aStr1 !== null\r\n  }\r\n\r\n  if (aStr1 > aStr2) {\r\n    return 1;\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\n/**\r\n * Comparator between two mappings with inflated source and name strings where\r\n * the generated positions are compared.\r\n */\r\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\r\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = strcmp(mappingA.source, mappingB.source);\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalLine - mappingB.originalLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  return strcmp(mappingA.name, mappingB.name);\r\n}\r\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\r\n\r\n/**\r\n * Strip any JSON XSSI avoidance prefix from the string (as documented\r\n * in the source maps specification), and then parse the string as\r\n * JSON.\r\n */\r\nfunction parseSourceMapInput(str) {\r\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\r\n}\r\nexports.parseSourceMapInput = parseSourceMapInput;\r\n\r\n/**\r\n * Compute the URL of a source given the the source root, the source's\r\n * URL, and the source map's URL.\r\n */\r\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\r\n  sourceURL = sourceURL || '';\r\n\r\n  if (sourceRoot) {\r\n    // This follows what Chrome does.\r\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\r\n      sourceRoot += '/';\r\n    }\r\n    // The spec says:\r\n    //   Line 4: An optional source root, useful for relocating source\r\n    //   files on a server or removing repeated values in the\r\n    //   “sources” entry.  This value is prepended to the individual\r\n    //   entries in the “source” field.\r\n    sourceURL = sourceRoot + sourceURL;\r\n  }\r\n\r\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\r\n  // a parameter.  This mode is still somewhat supported, which is why\r\n  // this code block is conditional.  However, it's preferable to pass\r\n  // the source map URL to SourceMapConsumer, so that this function\r\n  // can implement the source URL resolution algorithm as outlined in\r\n  // the spec.  This block is basically the equivalent of:\r\n  //    new URL(sourceURL, sourceMapURL).toString()\r\n  // ... except it avoids using URL, which wasn't available in the\r\n  // older releases of node still supported by this library.\r\n  //\r\n  // The spec says:\r\n  //   If the sources are not absolute URLs after prepending of the\r\n  //   “sourceRoot”, the sources are resolved relative to the\r\n  //   SourceMap (like resolving script src in a html document).\r\n  if (sourceMapURL) {\r\n    var parsed = urlParse(sourceMapURL);\r\n    if (!parsed) {\r\n      throw new Error(\"sourceMapURL could not be parsed\");\r\n    }\r\n    if (parsed.path) {\r\n      // Strip the last path component, but keep the \"/\".\r\n      var index = parsed.path.lastIndexOf('/');\r\n      if (index >= 0) {\r\n        parsed.path = parsed.path.substring(0, index + 1);\r\n      }\r\n    }\r\n    sourceURL = join(urlGenerate(parsed), sourceURL);\r\n  }\r\n\r\n  return normalize(sourceURL);\r\n}\r\nexports.computeSourceURL = computeSourceURL;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar util = require('./util');\r\nvar has = Object.prototype.hasOwnProperty;\r\nvar hasNativeMap = typeof Map !== \"undefined\";\r\n\r\n/**\r\n * A data structure which is a combination of an array and a set. Adding a new\r\n * member is O(1), testing for membership is O(1), and finding the index of an\r\n * element is O(1). Removing elements from the set is not supported. Only\r\n * strings are supported for membership.\r\n */\r\nfunction ArraySet() {\r\n  this._array = [];\r\n  this._set = hasNativeMap ? new Map() : Object.create(null);\r\n}\r\n\r\n/**\r\n * Static method for creating ArraySet instances from an existing array.\r\n */\r\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\r\n  var set = new ArraySet();\r\n  for (var i = 0, len = aArray.length; i < len; i++) {\r\n    set.add(aArray[i], aAllowDuplicates);\r\n  }\r\n  return set;\r\n};\r\n\r\n/**\r\n * Return how many unique items are in this ArraySet. If duplicates have been\r\n * added, than those do not count towards the size.\r\n *\r\n * @returns Number\r\n */\r\nArraySet.prototype.size = function ArraySet_size() {\r\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\r\n};\r\n\r\n/**\r\n * Add the given string to this set.\r\n *\r\n * @param String aStr\r\n */\r\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\r\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\r\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\r\n  var idx = this._array.length;\r\n  if (!isDuplicate || aAllowDuplicates) {\r\n    this._array.push(aStr);\r\n  }\r\n  if (!isDuplicate) {\r\n    if (hasNativeMap) {\r\n      this._set.set(aStr, idx);\r\n    } else {\r\n      this._set[sStr] = idx;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Is the given string a member of this set?\r\n *\r\n * @param String aStr\r\n */\r\nArraySet.prototype.has = function ArraySet_has(aStr) {\r\n  if (hasNativeMap) {\r\n    return this._set.has(aStr);\r\n  } else {\r\n    var sStr = util.toSetString(aStr);\r\n    return has.call(this._set, sStr);\r\n  }\r\n};\r\n\r\n/**\r\n * What is the index of the given string in the array?\r\n *\r\n * @param String aStr\r\n */\r\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\r\n  if (hasNativeMap) {\r\n    var idx = this._set.get(aStr);\r\n    if (idx >= 0) {\r\n        return idx;\r\n    }\r\n  } else {\r\n    var sStr = util.toSetString(aStr);\r\n    if (has.call(this._set, sStr)) {\r\n      return this._set[sStr];\r\n    }\r\n  }\r\n\r\n  throw new Error('\"' + aStr + '\" is not in the set.');\r\n};\r\n\r\n/**\r\n * What is the element at the given index?\r\n *\r\n * @param Number aIdx\r\n */\r\nArraySet.prototype.at = function ArraySet_at(aIdx) {\r\n  if (aIdx >= 0 && aIdx < this._array.length) {\r\n    return this._array[aIdx];\r\n  }\r\n  throw new Error('No element indexed by ' + aIdx);\r\n};\r\n\r\n/**\r\n * Returns the array representation of this set (which has the proper indices\r\n * indicated by indexOf). Note that this is a copy of the internal array used\r\n * for storing the members so that no one can mess with internal state.\r\n */\r\nArraySet.prototype.toArray = function ArraySet_toArray() {\r\n  return this._array.slice();\r\n};\r\n\r\nexports.ArraySet = ArraySet;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2014 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar util = require('./util');\r\n\r\n/**\r\n * Determine whether mappingB is after mappingA with respect to generated\r\n * position.\r\n */\r\nfunction generatedPositionAfter(mappingA, mappingB) {\r\n  // Optimized for most common case\r\n  var lineA = mappingA.generatedLine;\r\n  var lineB = mappingB.generatedLine;\r\n  var columnA = mappingA.generatedColumn;\r\n  var columnB = mappingB.generatedColumn;\r\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\r\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\r\n}\r\n\r\n/**\r\n * A data structure to provide a sorted view of accumulated mappings in a\r\n * performance conscious manner. It trades a neglibable overhead in general\r\n * case for a large speedup in case of mappings being added in order.\r\n */\r\nfunction MappingList() {\r\n  this._array = [];\r\n  this._sorted = true;\r\n  // Serves as infimum\r\n  this._last = {generatedLine: -1, generatedColumn: 0};\r\n}\r\n\r\n/**\r\n * Iterate through internal items. This method takes the same arguments that\r\n * `Array.prototype.forEach` takes.\r\n *\r\n * NOTE: The order of the mappings is NOT guaranteed.\r\n */\r\nMappingList.prototype.unsortedForEach =\r\n  function MappingList_forEach(aCallback, aThisArg) {\r\n    this._array.forEach(aCallback, aThisArg);\r\n  };\r\n\r\n/**\r\n * Add the given source mapping.\r\n *\r\n * @param Object aMapping\r\n */\r\nMappingList.prototype.add = function MappingList_add(aMapping) {\r\n  if (generatedPositionAfter(this._last, aMapping)) {\r\n    this._last = aMapping;\r\n    this._array.push(aMapping);\r\n  } else {\r\n    this._sorted = false;\r\n    this._array.push(aMapping);\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the flat, sorted array of mappings. The mappings are sorted by\r\n * generated position.\r\n *\r\n * WARNING: This method returns internal data without copying, for\r\n * performance. The return value must NOT be mutated, and should be treated as\r\n * an immutable borrow. If you want to take ownership, you must make your own\r\n * copy.\r\n */\r\nMappingList.prototype.toArray = function MappingList_toArray() {\r\n  if (!this._sorted) {\r\n    this._array.sort(util.compareByGeneratedPositionsInflated);\r\n    this._sorted = true;\r\n  }\r\n  return this._array;\r\n};\r\n\r\nexports.MappingList = MappingList;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar util = require('./util');\r\nvar binarySearch = require('./binary-search');\r\nvar ArraySet = require('./array-set').ArraySet;\r\nvar base64VLQ = require('./base64-vlq');\r\nvar quickSort = require('./quick-sort').quickSort;\r\n\r\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\r\n  var sourceMap = aSourceMap;\r\n  if (typeof aSourceMap === 'string') {\r\n    sourceMap = util.parseSourceMapInput(aSourceMap);\r\n  }\r\n\r\n  return sourceMap.sections != null\r\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\r\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\r\n}\r\n\r\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\r\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\r\n}\r\n\r\n/**\r\n * The version of the source mapping spec that we are consuming.\r\n */\r\nSourceMapConsumer.prototype._version = 3;\r\n\r\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\r\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\r\n// are lazily instantiated, accessed via the `_generatedMappings` and\r\n// `_originalMappings` getters respectively, and we only parse the mappings\r\n// and create these arrays once queried for a source location. We jump through\r\n// these hoops because there can be many thousands of mappings, and parsing\r\n// them is expensive, so we only want to do it if we must.\r\n//\r\n// Each object in the arrays is of the form:\r\n//\r\n//     {\r\n//       generatedLine: The line number in the generated code,\r\n//       generatedColumn: The column number in the generated code,\r\n//       source: The path to the original source file that generated this\r\n//               chunk of code,\r\n//       originalLine: The line number in the original source that\r\n//                     corresponds to this chunk of generated code,\r\n//       originalColumn: The column number in the original source that\r\n//                       corresponds to this chunk of generated code,\r\n//       name: The name of the original symbol which generated this chunk of\r\n//             code.\r\n//     }\r\n//\r\n// All properties except for `generatedLine` and `generatedColumn` can be\r\n// `null`.\r\n//\r\n// `_generatedMappings` is ordered by the generated positions.\r\n//\r\n// `_originalMappings` is ordered by the original positions.\r\n\r\nSourceMapConsumer.prototype.__generatedMappings = null;\r\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\r\n  configurable: true,\r\n  enumerable: true,\r\n  get: function () {\r\n    if (!this.__generatedMappings) {\r\n      this._parseMappings(this._mappings, this.sourceRoot);\r\n    }\r\n\r\n    return this.__generatedMappings;\r\n  }\r\n});\r\n\r\nSourceMapConsumer.prototype.__originalMappings = null;\r\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\r\n  configurable: true,\r\n  enumerable: true,\r\n  get: function () {\r\n    if (!this.__originalMappings) {\r\n      this._parseMappings(this._mappings, this.sourceRoot);\r\n    }\r\n\r\n    return this.__originalMappings;\r\n  }\r\n});\r\n\r\nSourceMapConsumer.prototype._charIsMappingSeparator =\r\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\r\n    var c = aStr.charAt(index);\r\n    return c === \";\" || c === \",\";\r\n  };\r\n\r\n/**\r\n * Parse the mappings in a string in to a data structure which we can easily\r\n * query (the ordered arrays in the `this.__generatedMappings` and\r\n * `this.__originalMappings` properties).\r\n */\r\nSourceMapConsumer.prototype._parseMappings =\r\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\r\n    throw new Error(\"Subclasses must implement _parseMappings\");\r\n  };\r\n\r\nSourceMapConsumer.GENERATED_ORDER = 1;\r\nSourceMapConsumer.ORIGINAL_ORDER = 2;\r\n\r\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\r\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\r\n\r\n/**\r\n * Iterate over each mapping between an original source/line/column and a\r\n * generated line/column in this source map.\r\n *\r\n * @param Function aCallback\r\n *        The function that is called with each mapping.\r\n * @param Object aContext\r\n *        Optional. If specified, this object will be the value of `this` every\r\n *        time that `aCallback` is called.\r\n * @param aOrder\r\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\r\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\r\n *        iterate over the mappings sorted by the generated file's line/column\r\n *        order or the original's source/line/column order, respectively. Defaults to\r\n *        `SourceMapConsumer.GENERATED_ORDER`.\r\n */\r\nSourceMapConsumer.prototype.eachMapping =\r\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\r\n    var context = aContext || null;\r\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\r\n\r\n    var mappings;\r\n    switch (order) {\r\n    case SourceMapConsumer.GENERATED_ORDER:\r\n      mappings = this._generatedMappings;\r\n      break;\r\n    case SourceMapConsumer.ORIGINAL_ORDER:\r\n      mappings = this._originalMappings;\r\n      break;\r\n    default:\r\n      throw new Error(\"Unknown order of iteration.\");\r\n    }\r\n\r\n    var sourceRoot = this.sourceRoot;\r\n    mappings.map(function (mapping) {\r\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\r\n      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\r\n      return {\r\n        source: source,\r\n        generatedLine: mapping.generatedLine,\r\n        generatedColumn: mapping.generatedColumn,\r\n        originalLine: mapping.originalLine,\r\n        originalColumn: mapping.originalColumn,\r\n        name: mapping.name === null ? null : this._names.at(mapping.name)\r\n      };\r\n    }, this).forEach(aCallback, context);\r\n  };\r\n\r\n/**\r\n * Returns all generated line and column information for the original source,\r\n * line, and column provided. If no column is provided, returns all mappings\r\n * corresponding to a either the line we are searching for or the next\r\n * closest line that has any mappings. Otherwise, returns all mappings\r\n * corresponding to the given line and either the column we are searching for\r\n * or the next closest column that has any offsets.\r\n *\r\n * The only argument is an object with the following properties:\r\n *\r\n *   - source: The filename of the original source.\r\n *   - line: The line number in the original source.  The line number is 1-based.\r\n *   - column: Optional. the column number in the original source.\r\n *    The column number is 0-based.\r\n *\r\n * and an array of objects is returned, each with the following properties:\r\n *\r\n *   - line: The line number in the generated source, or null.  The\r\n *    line number is 1-based.\r\n *   - column: The column number in the generated source, or null.\r\n *    The column number is 0-based.\r\n */\r\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\r\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\r\n    var line = util.getArg(aArgs, 'line');\r\n\r\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\r\n    // returns the index of the closest mapping less than the needle. By\r\n    // setting needle.originalColumn to 0, we thus find the last mapping for\r\n    // the given line, provided such a mapping exists.\r\n    var needle = {\r\n      source: util.getArg(aArgs, 'source'),\r\n      originalLine: line,\r\n      originalColumn: util.getArg(aArgs, 'column', 0)\r\n    };\r\n\r\n    needle.source = this._findSourceIndex(needle.source);\r\n    if (needle.source < 0) {\r\n      return [];\r\n    }\r\n\r\n    var mappings = [];\r\n\r\n    var index = this._findMapping(needle,\r\n                                  this._originalMappings,\r\n                                  \"originalLine\",\r\n                                  \"originalColumn\",\r\n                                  util.compareByOriginalPositions,\r\n                                  binarySearch.LEAST_UPPER_BOUND);\r\n    if (index >= 0) {\r\n      var mapping = this._originalMappings[index];\r\n\r\n      if (aArgs.column === undefined) {\r\n        var originalLine = mapping.originalLine;\r\n\r\n        // Iterate until either we run out of mappings, or we run into\r\n        // a mapping for a different line than the one we found. Since\r\n        // mappings are sorted, this is guaranteed to find all mappings for\r\n        // the line we found.\r\n        while (mapping && mapping.originalLine === originalLine) {\r\n          mappings.push({\r\n            line: util.getArg(mapping, 'generatedLine', null),\r\n            column: util.getArg(mapping, 'generatedColumn', null),\r\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\r\n          });\r\n\r\n          mapping = this._originalMappings[++index];\r\n        }\r\n      } else {\r\n        var originalColumn = mapping.originalColumn;\r\n\r\n        // Iterate until either we run out of mappings, or we run into\r\n        // a mapping for a different line than the one we were searching for.\r\n        // Since mappings are sorted, this is guaranteed to find all mappings for\r\n        // the line we are searching for.\r\n        while (mapping &&\r\n               mapping.originalLine === line &&\r\n               mapping.originalColumn == originalColumn) {\r\n          mappings.push({\r\n            line: util.getArg(mapping, 'generatedLine', null),\r\n            column: util.getArg(mapping, 'generatedColumn', null),\r\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\r\n          });\r\n\r\n          mapping = this._originalMappings[++index];\r\n        }\r\n      }\r\n    }\r\n\r\n    return mappings;\r\n  };\r\n\r\nexports.SourceMapConsumer = SourceMapConsumer;\r\n\r\n/**\r\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\r\n * query for information about the original file positions by giving it a file\r\n * position in the generated source.\r\n *\r\n * The first parameter is the raw source map (either as a JSON string, or\r\n * already parsed to an object). According to the spec, source maps have the\r\n * following attributes:\r\n *\r\n *   - version: Which version of the source map spec this map is following.\r\n *   - sources: An array of URLs to the original source files.\r\n *   - names: An array of identifiers which can be referrenced by individual mappings.\r\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\r\n *   - sourcesContent: Optional. An array of contents of the original source files.\r\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\r\n *   - file: Optional. The generated file this source map is associated with.\r\n *\r\n * Here is an example source map, taken from the source map spec[0]:\r\n *\r\n *     {\r\n *       version : 3,\r\n *       file: \"out.js\",\r\n *       sourceRoot : \"\",\r\n *       sources: [\"foo.js\", \"bar.js\"],\r\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\r\n *       mappings: \"AA,AB;;ABCDE;\"\r\n *     }\r\n *\r\n * The second parameter, if given, is a string whose value is the URL\r\n * at which the source map was found.  This URL is used to compute the\r\n * sources array.\r\n *\r\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\r\n */\r\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\r\n  var sourceMap = aSourceMap;\r\n  if (typeof aSourceMap === 'string') {\r\n    sourceMap = util.parseSourceMapInput(aSourceMap);\r\n  }\r\n\r\n  var version = util.getArg(sourceMap, 'version');\r\n  var sources = util.getArg(sourceMap, 'sources');\r\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\r\n  // requires the array) to play nice here.\r\n  var names = util.getArg(sourceMap, 'names', []);\r\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\r\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\r\n  var mappings = util.getArg(sourceMap, 'mappings');\r\n  var file = util.getArg(sourceMap, 'file', null);\r\n\r\n  // Once again, Sass deviates from the spec and supplies the version as a\r\n  // string rather than a number, so we use loose equality checking here.\r\n  if (version != this._version) {\r\n    throw new Error('Unsupported version: ' + version);\r\n  }\r\n\r\n  if (sourceRoot) {\r\n    sourceRoot = util.normalize(sourceRoot);\r\n  }\r\n\r\n  sources = sources\r\n    .map(String)\r\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\r\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\r\n    // See bugzil.la/1090768.\r\n    .map(util.normalize)\r\n    // Always ensure that absolute sources are internally stored relative to\r\n    // the source root, if the source root is absolute. Not doing this would\r\n    // be particularly problematic when the source root is a prefix of the\r\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\r\n    .map(function (source) {\r\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\r\n        ? util.relative(sourceRoot, source)\r\n        : source;\r\n    });\r\n\r\n  // Pass `true` below to allow duplicate names and sources. While source maps\r\n  // are intended to be compressed and deduplicated, the TypeScript compiler\r\n  // sometimes generates source maps with duplicates in them. See Github issue\r\n  // #72 and bugzil.la/889492.\r\n  this._names = ArraySet.fromArray(names.map(String), true);\r\n  this._sources = ArraySet.fromArray(sources, true);\r\n\r\n  this._absoluteSources = this._sources.toArray().map(function (s) {\r\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\r\n  });\r\n\r\n  this.sourceRoot = sourceRoot;\r\n  this.sourcesContent = sourcesContent;\r\n  this._mappings = mappings;\r\n  this._sourceMapURL = aSourceMapURL;\r\n  this.file = file;\r\n}\r\n\r\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\r\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\r\n\r\n/**\r\n * Utility function to find the index of a source.  Returns -1 if not\r\n * found.\r\n */\r\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\r\n  var relativeSource = aSource;\r\n  if (this.sourceRoot != null) {\r\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\r\n  }\r\n\r\n  if (this._sources.has(relativeSource)) {\r\n    return this._sources.indexOf(relativeSource);\r\n  }\r\n\r\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\r\n  // this case we can't simply undo the transform.\r\n  var i;\r\n  for (i = 0; i < this._absoluteSources.length; ++i) {\r\n    if (this._absoluteSources[i] == aSource) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n};\r\n\r\n/**\r\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\r\n *\r\n * @param SourceMapGenerator aSourceMap\r\n *        The source map that will be consumed.\r\n * @param String aSourceMapURL\r\n *        The URL at which the source map can be found (optional)\r\n * @returns BasicSourceMapConsumer\r\n */\r\nBasicSourceMapConsumer.fromSourceMap =\r\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\r\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\r\n\r\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\r\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\r\n    smc.sourceRoot = aSourceMap._sourceRoot;\r\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\r\n                                                            smc.sourceRoot);\r\n    smc.file = aSourceMap._file;\r\n    smc._sourceMapURL = aSourceMapURL;\r\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\r\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\r\n    });\r\n\r\n    // Because we are modifying the entries (by converting string sources and\r\n    // names to indices into the sources and names ArraySets), we have to make\r\n    // a copy of the entry or else bad things happen. Shared mutable state\r\n    // strikes again! See github issue #191.\r\n\r\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\r\n    var destGeneratedMappings = smc.__generatedMappings = [];\r\n    var destOriginalMappings = smc.__originalMappings = [];\r\n\r\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\r\n      var srcMapping = generatedMappings[i];\r\n      var destMapping = new Mapping;\r\n      destMapping.generatedLine = srcMapping.generatedLine;\r\n      destMapping.generatedColumn = srcMapping.generatedColumn;\r\n\r\n      if (srcMapping.source) {\r\n        destMapping.source = sources.indexOf(srcMapping.source);\r\n        destMapping.originalLine = srcMapping.originalLine;\r\n        destMapping.originalColumn = srcMapping.originalColumn;\r\n\r\n        if (srcMapping.name) {\r\n          destMapping.name = names.indexOf(srcMapping.name);\r\n        }\r\n\r\n        destOriginalMappings.push(destMapping);\r\n      }\r\n\r\n      destGeneratedMappings.push(destMapping);\r\n    }\r\n\r\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\r\n\r\n    return smc;\r\n  };\r\n\r\n/**\r\n * The version of the source mapping spec that we are consuming.\r\n */\r\nBasicSourceMapConsumer.prototype._version = 3;\r\n\r\n/**\r\n * The list of original sources.\r\n */\r\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\r\n  get: function () {\r\n    return this._absoluteSources.slice();\r\n  }\r\n});\r\n\r\n/**\r\n * Provide the JIT with a nice shape / hidden class.\r\n */\r\nfunction Mapping() {\r\n  this.generatedLine = 0;\r\n  this.generatedColumn = 0;\r\n  this.source = null;\r\n  this.originalLine = null;\r\n  this.originalColumn = null;\r\n  this.name = null;\r\n}\r\n\r\n/**\r\n * Parse the mappings in a string in to a data structure which we can easily\r\n * query (the ordered arrays in the `this.__generatedMappings` and\r\n * `this.__originalMappings` properties).\r\n */\r\nBasicSourceMapConsumer.prototype._parseMappings =\r\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\r\n    var generatedLine = 1;\r\n    var previousGeneratedColumn = 0;\r\n    var previousOriginalLine = 0;\r\n    var previousOriginalColumn = 0;\r\n    var previousSource = 0;\r\n    var previousName = 0;\r\n    var length = aStr.length;\r\n    var index = 0;\r\n    var cachedSegments = {};\r\n    var temp = {};\r\n    var originalMappings = [];\r\n    var generatedMappings = [];\r\n    var mapping, str, segment, end, value;\r\n\r\n    while (index < length) {\r\n      if (aStr.charAt(index) === ';') {\r\n        generatedLine++;\r\n        index++;\r\n        previousGeneratedColumn = 0;\r\n      }\r\n      else if (aStr.charAt(index) === ',') {\r\n        index++;\r\n      }\r\n      else {\r\n        mapping = new Mapping();\r\n        mapping.generatedLine = generatedLine;\r\n\r\n        // Because each offset is encoded relative to the previous one,\r\n        // many segments often have the same encoding. We can exploit this\r\n        // fact by caching the parsed variable length fields of each segment,\r\n        // allowing us to avoid a second parse if we encounter the same\r\n        // segment again.\r\n        for (end = index; end < length; end++) {\r\n          if (this._charIsMappingSeparator(aStr, end)) {\r\n            break;\r\n          }\r\n        }\r\n        str = aStr.slice(index, end);\r\n\r\n        segment = cachedSegments[str];\r\n        if (segment) {\r\n          index += str.length;\r\n        } else {\r\n          segment = [];\r\n          while (index < end) {\r\n            base64VLQ.decode(aStr, index, temp);\r\n            value = temp.value;\r\n            index = temp.rest;\r\n            segment.push(value);\r\n          }\r\n\r\n          if (segment.length === 2) {\r\n            throw new Error('Found a source, but no line and column');\r\n          }\r\n\r\n          if (segment.length === 3) {\r\n            throw new Error('Found a source and line, but no column');\r\n          }\r\n\r\n          cachedSegments[str] = segment;\r\n        }\r\n\r\n        // Generated column.\r\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\r\n        previousGeneratedColumn = mapping.generatedColumn;\r\n\r\n        if (segment.length > 1) {\r\n          // Original source.\r\n          mapping.source = previousSource + segment[1];\r\n          previousSource += segment[1];\r\n\r\n          // Original line.\r\n          mapping.originalLine = previousOriginalLine + segment[2];\r\n          previousOriginalLine = mapping.originalLine;\r\n          // Lines are stored 0-based\r\n          mapping.originalLine += 1;\r\n\r\n          // Original column.\r\n          mapping.originalColumn = previousOriginalColumn + segment[3];\r\n          previousOriginalColumn = mapping.originalColumn;\r\n\r\n          if (segment.length > 4) {\r\n            // Original name.\r\n            mapping.name = previousName + segment[4];\r\n            previousName += segment[4];\r\n          }\r\n        }\r\n\r\n        generatedMappings.push(mapping);\r\n        if (typeof mapping.originalLine === 'number') {\r\n          originalMappings.push(mapping);\r\n        }\r\n      }\r\n    }\r\n\r\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\r\n    this.__generatedMappings = generatedMappings;\r\n\r\n    quickSort(originalMappings, util.compareByOriginalPositions);\r\n    this.__originalMappings = originalMappings;\r\n  };\r\n\r\n/**\r\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\r\n * we are searching for in the given \"haystack\" of mappings.\r\n */\r\nBasicSourceMapConsumer.prototype._findMapping =\r\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\r\n                                         aColumnName, aComparator, aBias) {\r\n    // To return the position we are searching for, we must first find the\r\n    // mapping for the given position and then return the opposite position it\r\n    // points to. Because the mappings are sorted, we can use binary search to\r\n    // find the best mapping.\r\n\r\n    if (aNeedle[aLineName] <= 0) {\r\n      throw new TypeError('Line must be greater than or equal to 1, got '\r\n                          + aNeedle[aLineName]);\r\n    }\r\n    if (aNeedle[aColumnName] < 0) {\r\n      throw new TypeError('Column must be greater than or equal to 0, got '\r\n                          + aNeedle[aColumnName]);\r\n    }\r\n\r\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\r\n  };\r\n\r\n/**\r\n * Compute the last column for each generated mapping. The last column is\r\n * inclusive.\r\n */\r\nBasicSourceMapConsumer.prototype.computeColumnSpans =\r\n  function SourceMapConsumer_computeColumnSpans() {\r\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\r\n      var mapping = this._generatedMappings[index];\r\n\r\n      // Mappings do not contain a field for the last generated columnt. We\r\n      // can come up with an optimistic estimate, however, by assuming that\r\n      // mappings are contiguous (i.e. given two consecutive mappings, the\r\n      // first mapping ends where the second one starts).\r\n      if (index + 1 < this._generatedMappings.length) {\r\n        var nextMapping = this._generatedMappings[index + 1];\r\n\r\n        if (mapping.generatedLine === nextMapping.generatedLine) {\r\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // The last mapping for each line spans the entire line.\r\n      mapping.lastGeneratedColumn = Infinity;\r\n    }\r\n  };\r\n\r\n/**\r\n * Returns the original source, line, and column information for the generated\r\n * source's line and column positions provided. The only argument is an object\r\n * with the following properties:\r\n *\r\n *   - line: The line number in the generated source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the generated source.  The column\r\n *     number is 0-based.\r\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\r\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - source: The original source file, or null.\r\n *   - line: The line number in the original source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the original source, or null.  The\r\n *     column number is 0-based.\r\n *   - name: The original identifier, or null.\r\n */\r\nBasicSourceMapConsumer.prototype.originalPositionFor =\r\n  function SourceMapConsumer_originalPositionFor(aArgs) {\r\n    var needle = {\r\n      generatedLine: util.getArg(aArgs, 'line'),\r\n      generatedColumn: util.getArg(aArgs, 'column')\r\n    };\r\n\r\n    var index = this._findMapping(\r\n      needle,\r\n      this._generatedMappings,\r\n      \"generatedLine\",\r\n      \"generatedColumn\",\r\n      util.compareByGeneratedPositionsDeflated,\r\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\r\n    );\r\n\r\n    if (index >= 0) {\r\n      var mapping = this._generatedMappings[index];\r\n\r\n      if (mapping.generatedLine === needle.generatedLine) {\r\n        var source = util.getArg(mapping, 'source', null);\r\n        if (source !== null) {\r\n          source = this._sources.at(source);\r\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\r\n        }\r\n        var name = util.getArg(mapping, 'name', null);\r\n        if (name !== null) {\r\n          name = this._names.at(name);\r\n        }\r\n        return {\r\n          source: source,\r\n          line: util.getArg(mapping, 'originalLine', null),\r\n          column: util.getArg(mapping, 'originalColumn', null),\r\n          name: name\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      source: null,\r\n      line: null,\r\n      column: null,\r\n      name: null\r\n    };\r\n  };\r\n\r\n/**\r\n * Return true if we have the source content for every source in the source\r\n * map, false otherwise.\r\n */\r\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\r\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\r\n    if (!this.sourcesContent) {\r\n      return false;\r\n    }\r\n    return this.sourcesContent.length >= this._sources.size() &&\r\n      !this.sourcesContent.some(function (sc) { return sc == null; });\r\n  };\r\n\r\n/**\r\n * Returns the original source content. The only argument is the url of the\r\n * original source file. Returns null if no original source content is\r\n * available.\r\n */\r\nBasicSourceMapConsumer.prototype.sourceContentFor =\r\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\r\n    if (!this.sourcesContent) {\r\n      return null;\r\n    }\r\n\r\n    var index = this._findSourceIndex(aSource);\r\n    if (index >= 0) {\r\n      return this.sourcesContent[index];\r\n    }\r\n\r\n    var relativeSource = aSource;\r\n    if (this.sourceRoot != null) {\r\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\r\n    }\r\n\r\n    var url;\r\n    if (this.sourceRoot != null\r\n        && (url = util.urlParse(this.sourceRoot))) {\r\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\r\n      // many users. We can help them out when they expect file:// URIs to\r\n      // behave like it would if they were running a local HTTP server. See\r\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\r\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\r\n      if (url.scheme == \"file\"\r\n          && this._sources.has(fileUriAbsPath)) {\r\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\r\n      }\r\n\r\n      if ((!url.path || url.path == \"/\")\r\n          && this._sources.has(\"/\" + relativeSource)) {\r\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\r\n      }\r\n    }\r\n\r\n    // This function is used recursively from\r\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\r\n    // don't want to throw if we can't find the source - we just want to\r\n    // return null, so we provide a flag to exit gracefully.\r\n    if (nullOnMissing) {\r\n      return null;\r\n    }\r\n    else {\r\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\r\n    }\r\n  };\r\n\r\n/**\r\n * Returns the generated line and column information for the original source,\r\n * line, and column positions provided. The only argument is an object with\r\n * the following properties:\r\n *\r\n *   - source: The filename of the original source.\r\n *   - line: The line number in the original source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the original source.  The column\r\n *     number is 0-based.\r\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\r\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - line: The line number in the generated source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the generated source, or null.\r\n *     The column number is 0-based.\r\n */\r\nBasicSourceMapConsumer.prototype.generatedPositionFor =\r\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\r\n    var source = util.getArg(aArgs, 'source');\r\n    source = this._findSourceIndex(source);\r\n    if (source < 0) {\r\n      return {\r\n        line: null,\r\n        column: null,\r\n        lastColumn: null\r\n      };\r\n    }\r\n\r\n    var needle = {\r\n      source: source,\r\n      originalLine: util.getArg(aArgs, 'line'),\r\n      originalColumn: util.getArg(aArgs, 'column')\r\n    };\r\n\r\n    var index = this._findMapping(\r\n      needle,\r\n      this._originalMappings,\r\n      \"originalLine\",\r\n      \"originalColumn\",\r\n      util.compareByOriginalPositions,\r\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\r\n    );\r\n\r\n    if (index >= 0) {\r\n      var mapping = this._originalMappings[index];\r\n\r\n      if (mapping.source === needle.source) {\r\n        return {\r\n          line: util.getArg(mapping, 'generatedLine', null),\r\n          column: util.getArg(mapping, 'generatedColumn', null),\r\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      line: null,\r\n      column: null,\r\n      lastColumn: null\r\n    };\r\n  };\r\n\r\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\r\n\r\n/**\r\n * An IndexedSourceMapConsumer instance represents a parsed source map which\r\n * we can query for information. It differs from BasicSourceMapConsumer in\r\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\r\n * input.\r\n *\r\n * The first parameter is a raw source map (either as a JSON string, or already\r\n * parsed to an object). According to the spec for indexed source maps, they\r\n * have the following attributes:\r\n *\r\n *   - version: Which version of the source map spec this map is following.\r\n *   - file: Optional. The generated file this source map is associated with.\r\n *   - sections: A list of section definitions.\r\n *\r\n * Each value under the \"sections\" field has two fields:\r\n *   - offset: The offset into the original specified at which this section\r\n *       begins to apply, defined as an object with a \"line\" and \"column\"\r\n *       field.\r\n *   - map: A source map definition. This source map could also be indexed,\r\n *       but doesn't have to be.\r\n *\r\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\r\n * specifying a URL to retrieve a source map from, but that's currently\r\n * unsupported.\r\n *\r\n * Here's an example source map, taken from the source map spec[0], but\r\n * modified to omit a section which uses the \"url\" field.\r\n *\r\n *  {\r\n *    version : 3,\r\n *    file: \"app.js\",\r\n *    sections: [{\r\n *      offset: {line:100, column:10},\r\n *      map: {\r\n *        version : 3,\r\n *        file: \"section.js\",\r\n *        sources: [\"foo.js\", \"bar.js\"],\r\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\r\n *        mappings: \"AAAA,E;;ABCDE;\"\r\n *      }\r\n *    }],\r\n *  }\r\n *\r\n * The second parameter, if given, is a string whose value is the URL\r\n * at which the source map was found.  This URL is used to compute the\r\n * sources array.\r\n *\r\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\r\n */\r\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\r\n  var sourceMap = aSourceMap;\r\n  if (typeof aSourceMap === 'string') {\r\n    sourceMap = util.parseSourceMapInput(aSourceMap);\r\n  }\r\n\r\n  var version = util.getArg(sourceMap, 'version');\r\n  var sections = util.getArg(sourceMap, 'sections');\r\n\r\n  if (version != this._version) {\r\n    throw new Error('Unsupported version: ' + version);\r\n  }\r\n\r\n  this._sources = new ArraySet();\r\n  this._names = new ArraySet();\r\n\r\n  var lastOffset = {\r\n    line: -1,\r\n    column: 0\r\n  };\r\n  this._sections = sections.map(function (s) {\r\n    if (s.url) {\r\n      // The url field will require support for asynchronicity.\r\n      // See https://github.com/mozilla/source-map/issues/16\r\n      throw new Error('Support for url field in sections not implemented.');\r\n    }\r\n    var offset = util.getArg(s, 'offset');\r\n    var offsetLine = util.getArg(offset, 'line');\r\n    var offsetColumn = util.getArg(offset, 'column');\r\n\r\n    if (offsetLine < lastOffset.line ||\r\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\r\n      throw new Error('Section offsets must be ordered and non-overlapping.');\r\n    }\r\n    lastOffset = offset;\r\n\r\n    return {\r\n      generatedOffset: {\r\n        // The offset fields are 0-based, but we use 1-based indices when\r\n        // encoding/decoding from VLQ.\r\n        generatedLine: offsetLine + 1,\r\n        generatedColumn: offsetColumn + 1\r\n      },\r\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\r\n    }\r\n  });\r\n}\r\n\r\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\r\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\r\n\r\n/**\r\n * The version of the source mapping spec that we are consuming.\r\n */\r\nIndexedSourceMapConsumer.prototype._version = 3;\r\n\r\n/**\r\n * The list of original sources.\r\n */\r\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\r\n  get: function () {\r\n    var sources = [];\r\n    for (var i = 0; i < this._sections.length; i++) {\r\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\r\n        sources.push(this._sections[i].consumer.sources[j]);\r\n      }\r\n    }\r\n    return sources;\r\n  }\r\n});\r\n\r\n/**\r\n * Returns the original source, line, and column information for the generated\r\n * source's line and column positions provided. The only argument is an object\r\n * with the following properties:\r\n *\r\n *   - line: The line number in the generated source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the generated source.  The column\r\n *     number is 0-based.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - source: The original source file, or null.\r\n *   - line: The line number in the original source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the original source, or null.  The\r\n *     column number is 0-based.\r\n *   - name: The original identifier, or null.\r\n */\r\nIndexedSourceMapConsumer.prototype.originalPositionFor =\r\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\r\n    var needle = {\r\n      generatedLine: util.getArg(aArgs, 'line'),\r\n      generatedColumn: util.getArg(aArgs, 'column')\r\n    };\r\n\r\n    // Find the section containing the generated position we're trying to map\r\n    // to an original position.\r\n    var sectionIndex = binarySearch.search(needle, this._sections,\r\n      function(needle, section) {\r\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\r\n        if (cmp) {\r\n          return cmp;\r\n        }\r\n\r\n        return (needle.generatedColumn -\r\n                section.generatedOffset.generatedColumn);\r\n      });\r\n    var section = this._sections[sectionIndex];\r\n\r\n    if (!section) {\r\n      return {\r\n        source: null,\r\n        line: null,\r\n        column: null,\r\n        name: null\r\n      };\r\n    }\r\n\r\n    return section.consumer.originalPositionFor({\r\n      line: needle.generatedLine -\r\n        (section.generatedOffset.generatedLine - 1),\r\n      column: needle.generatedColumn -\r\n        (section.generatedOffset.generatedLine === needle.generatedLine\r\n         ? section.generatedOffset.generatedColumn - 1\r\n         : 0),\r\n      bias: aArgs.bias\r\n    });\r\n  };\r\n\r\n/**\r\n * Return true if we have the source content for every source in the source\r\n * map, false otherwise.\r\n */\r\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\r\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\r\n    return this._sections.every(function (s) {\r\n      return s.consumer.hasContentsOfAllSources();\r\n    });\r\n  };\r\n\r\n/**\r\n * Returns the original source content. The only argument is the url of the\r\n * original source file. Returns null if no original source content is\r\n * available.\r\n */\r\nIndexedSourceMapConsumer.prototype.sourceContentFor =\r\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\r\n    for (var i = 0; i < this._sections.length; i++) {\r\n      var section = this._sections[i];\r\n\r\n      var content = section.consumer.sourceContentFor(aSource, true);\r\n      if (content) {\r\n        return content;\r\n      }\r\n    }\r\n    if (nullOnMissing) {\r\n      return null;\r\n    }\r\n    else {\r\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\r\n    }\r\n  };\r\n\r\n/**\r\n * Returns the generated line and column information for the original source,\r\n * line, and column positions provided. The only argument is an object with\r\n * the following properties:\r\n *\r\n *   - source: The filename of the original source.\r\n *   - line: The line number in the original source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the original source.  The column\r\n *     number is 0-based.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - line: The line number in the generated source, or null.  The\r\n *     line number is 1-based. \r\n *   - column: The column number in the generated source, or null.\r\n *     The column number is 0-based.\r\n */\r\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\r\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\r\n    for (var i = 0; i < this._sections.length; i++) {\r\n      var section = this._sections[i];\r\n\r\n      // Only consider this section if the requested source is in the list of\r\n      // sources of the consumer.\r\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\r\n        continue;\r\n      }\r\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\r\n      if (generatedPosition) {\r\n        var ret = {\r\n          line: generatedPosition.line +\r\n            (section.generatedOffset.generatedLine - 1),\r\n          column: generatedPosition.column +\r\n            (section.generatedOffset.generatedLine === generatedPosition.line\r\n             ? section.generatedOffset.generatedColumn - 1\r\n             : 0)\r\n        };\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    return {\r\n      line: null,\r\n      column: null\r\n    };\r\n  };\r\n\r\n/**\r\n * Parse the mappings in a string in to a data structure which we can easily\r\n * query (the ordered arrays in the `this.__generatedMappings` and\r\n * `this.__originalMappings` properties).\r\n */\r\nIndexedSourceMapConsumer.prototype._parseMappings =\r\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\r\n    this.__generatedMappings = [];\r\n    this.__originalMappings = [];\r\n    for (var i = 0; i < this._sections.length; i++) {\r\n      var section = this._sections[i];\r\n      var sectionMappings = section.consumer._generatedMappings;\r\n      for (var j = 0; j < sectionMappings.length; j++) {\r\n        var mapping = sectionMappings[j];\r\n\r\n        var source = section.consumer._sources.at(mapping.source);\r\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\r\n        this._sources.add(source);\r\n        source = this._sources.indexOf(source);\r\n\r\n        var name = null;\r\n        if (mapping.name) {\r\n          name = section.consumer._names.at(mapping.name);\r\n          this._names.add(name);\r\n          name = this._names.indexOf(name);\r\n        }\r\n\r\n        // The mappings coming from the consumer for the section have\r\n        // generated positions relative to the start of the section, so we\r\n        // need to offset them to be relative to the start of the concatenated\r\n        // generated file.\r\n        var adjustedMapping = {\r\n          source: source,\r\n          generatedLine: mapping.generatedLine +\r\n            (section.generatedOffset.generatedLine - 1),\r\n          generatedColumn: mapping.generatedColumn +\r\n            (section.generatedOffset.generatedLine === mapping.generatedLine\r\n            ? section.generatedOffset.generatedColumn - 1\r\n            : 0),\r\n          originalLine: mapping.originalLine,\r\n          originalColumn: mapping.originalColumn,\r\n          name: name\r\n        };\r\n\r\n        this.__generatedMappings.push(adjustedMapping);\r\n        if (typeof adjustedMapping.originalLine === 'number') {\r\n          this.__originalMappings.push(adjustedMapping);\r\n        }\r\n      }\r\n    }\r\n\r\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\r\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\r\n  };\r\n\r\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nexports.GREATEST_LOWER_BOUND = 1;\r\nexports.LEAST_UPPER_BOUND = 2;\r\n\r\n/**\r\n * Recursive implementation of binary search.\r\n *\r\n * @param aLow Indices here and lower do not contain the needle.\r\n * @param aHigh Indices here and higher do not contain the needle.\r\n * @param aNeedle The element being searched for.\r\n * @param aHaystack The non-empty array being searched.\r\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n */\r\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\r\n  // This function terminates when one of the following is true:\r\n  //\r\n  //   1. We find the exact element we are looking for.\r\n  //\r\n  //   2. We did not find the exact element, but we can return the index of\r\n  //      the next-closest element.\r\n  //\r\n  //   3. We did not find the exact element, and there is no next-closest\r\n  //      element than the one we are searching for, so we return -1.\r\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\r\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\r\n  if (cmp === 0) {\r\n    // Found the element we are looking for.\r\n    return mid;\r\n  }\r\n  else if (cmp > 0) {\r\n    // Our needle is greater than aHaystack[mid].\r\n    if (aHigh - mid > 1) {\r\n      // The element is in the upper half.\r\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\r\n    }\r\n\r\n    // The exact needle element was not found in this haystack. Determine if\r\n    // we are in termination case (3) or (2) and return the appropriate thing.\r\n    if (aBias == exports.LEAST_UPPER_BOUND) {\r\n      return aHigh < aHaystack.length ? aHigh : -1;\r\n    } else {\r\n      return mid;\r\n    }\r\n  }\r\n  else {\r\n    // Our needle is less than aHaystack[mid].\r\n    if (mid - aLow > 1) {\r\n      // The element is in the lower half.\r\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\r\n    }\r\n\r\n    // we are in termination case (3) or (2) and return the appropriate thing.\r\n    if (aBias == exports.LEAST_UPPER_BOUND) {\r\n      return mid;\r\n    } else {\r\n      return aLow < 0 ? -1 : aLow;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This is an implementation of binary search which will always try and return\r\n * the index of the closest element if there is no exact hit. This is because\r\n * mappings between original and generated line/col pairs are single points,\r\n * and there is an implicit region between each of them, so a miss just means\r\n * that you aren't on the very start of a region.\r\n *\r\n * @param aNeedle The element you are looking for.\r\n * @param aHaystack The array that is being searched.\r\n * @param aCompare A function which takes the needle and an element in the\r\n *     array and returns -1, 0, or 1 depending on whether the needle is less\r\n *     than, equal to, or greater than the element, respectively.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\r\n */\r\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\r\n  if (aHaystack.length === 0) {\r\n    return -1;\r\n  }\r\n\r\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\r\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\r\n  if (index < 0) {\r\n    return -1;\r\n  }\r\n\r\n  // We have found either the exact element, or the next-closest element than\r\n  // the one we are searching for. However, there may be more than one such\r\n  // element. Make sure we always return the smallest of these.\r\n  while (index - 1 >= 0) {\r\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\r\n      break;\r\n    }\r\n    --index;\r\n  }\r\n\r\n  return index;\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\n// It turns out that some (most?) JavaScript engines don't self-host\r\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\r\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\r\n// custom comparator function, calling back and forth between the VM's C++ and\r\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\r\n// worse generated code for the comparator function than would be optimal. In\r\n// fact, when sorting with a comparator, these costs outweigh the benefits of\r\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\r\n// a ~3500ms mean speed-up in `bench/bench.html`.\r\n\r\n/**\r\n * Swap the elements indexed by `x` and `y` in the array `ary`.\r\n *\r\n * @param {Array} ary\r\n *        The array.\r\n * @param {Number} x\r\n *        The index of the first item.\r\n * @param {Number} y\r\n *        The index of the second item.\r\n */\r\nfunction swap(ary, x, y) {\r\n  var temp = ary[x];\r\n  ary[x] = ary[y];\r\n  ary[y] = temp;\r\n}\r\n\r\n/**\r\n * Returns a random integer within the range `low .. high` inclusive.\r\n *\r\n * @param {Number} low\r\n *        The lower bound on the range.\r\n * @param {Number} high\r\n *        The upper bound on the range.\r\n */\r\nfunction randomIntInRange(low, high) {\r\n  return Math.round(low + (Math.random() * (high - low)));\r\n}\r\n\r\n/**\r\n * The Quick Sort algorithm.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n * @param {Number} p\r\n *        Start index of the array\r\n * @param {Number} r\r\n *        End index of the array\r\n */\r\nfunction doQuickSort(ary, comparator, p, r) {\r\n  // If our lower bound is less than our upper bound, we (1) partition the\r\n  // array into two pieces and (2) recurse on each half. If it is not, this is\r\n  // the empty array and our base case.\r\n\r\n  if (p < r) {\r\n    // (1) Partitioning.\r\n    //\r\n    // The partitioning chooses a pivot between `p` and `r` and moves all\r\n    // elements that are less than or equal to the pivot to the before it, and\r\n    // all the elements that are greater than it after it. The effect is that\r\n    // once partition is done, the pivot is in the exact place it will be when\r\n    // the array is put in sorted order, and it will not need to be moved\r\n    // again. This runs in O(n) time.\r\n\r\n    // Always choose a random pivot so that an input array which is reverse\r\n    // sorted does not cause O(n^2) running time.\r\n    var pivotIndex = randomIntInRange(p, r);\r\n    var i = p - 1;\r\n\r\n    swap(ary, pivotIndex, r);\r\n    var pivot = ary[r];\r\n\r\n    // Immediately after `j` is incremented in this loop, the following hold\r\n    // true:\r\n    //\r\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\r\n    //\r\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\r\n    for (var j = p; j < r; j++) {\r\n      if (comparator(ary[j], pivot) <= 0) {\r\n        i += 1;\r\n        swap(ary, i, j);\r\n      }\r\n    }\r\n\r\n    swap(ary, i + 1, j);\r\n    var q = i + 1;\r\n\r\n    // (2) Recurse on each half.\r\n\r\n    doQuickSort(ary, comparator, p, q - 1);\r\n    doQuickSort(ary, comparator, q + 1, r);\r\n  }\r\n}\r\n\r\n/**\r\n * Sort the given array in-place with the given comparator function.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n */\r\nexports.quickSort = function (ary, comparator) {\r\n  doQuickSort(ary, comparator, 0, ary.length - 1);\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\r\nvar util = require('./util');\r\n\r\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\r\n// operating systems these days (capturing the result).\r\nvar REGEX_NEWLINE = /(\\r?\\n)/;\r\n\r\n// Newline character code for charCodeAt() comparisons\r\nvar NEWLINE_CODE = 10;\r\n\r\n// Private symbol for identifying `SourceNode`s when multiple versions of\r\n// the source-map library are loaded. This MUST NOT CHANGE across\r\n// versions!\r\nvar isSourceNode = \"$$$isSourceNode$$$\";\r\n\r\n/**\r\n * SourceNodes provide a way to abstract over interpolating/concatenating\r\n * snippets of generated JavaScript source code while maintaining the line and\r\n * column information associated with the original source code.\r\n *\r\n * @param aLine The original line number.\r\n * @param aColumn The original column number.\r\n * @param aSource The original source's filename.\r\n * @param aChunks Optional. An array of strings which are snippets of\r\n *        generated JS, or other SourceNodes.\r\n * @param aName The original identifier.\r\n */\r\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\r\n  this.children = [];\r\n  this.sourceContents = {};\r\n  this.line = aLine == null ? null : aLine;\r\n  this.column = aColumn == null ? null : aColumn;\r\n  this.source = aSource == null ? null : aSource;\r\n  this.name = aName == null ? null : aName;\r\n  this[isSourceNode] = true;\r\n  if (aChunks != null) this.add(aChunks);\r\n}\r\n\r\n/**\r\n * Creates a SourceNode from generated code and a SourceMapConsumer.\r\n *\r\n * @param aGeneratedCode The generated code\r\n * @param aSourceMapConsumer The SourceMap for the generated code\r\n * @param aRelativePath Optional. The path that relative sources in the\r\n *        SourceMapConsumer should be relative to.\r\n */\r\nSourceNode.fromStringWithSourceMap =\r\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\r\n    // The SourceNode we want to fill with the generated code\r\n    // and the SourceMap\r\n    var node = new SourceNode();\r\n\r\n    // All even indices of this array are one line of the generated code,\r\n    // while all odd indices are the newlines between two adjacent lines\r\n    // (since `REGEX_NEWLINE` captures its match).\r\n    // Processed fragments are accessed by calling `shiftNextLine`.\r\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\r\n    var remainingLinesIndex = 0;\r\n    var shiftNextLine = function() {\r\n      var lineContents = getNextLine();\r\n      // The last line of a file might not have a newline.\r\n      var newLine = getNextLine() || \"\";\r\n      return lineContents + newLine;\r\n\r\n      function getNextLine() {\r\n        return remainingLinesIndex < remainingLines.length ?\r\n            remainingLines[remainingLinesIndex++] : undefined;\r\n      }\r\n    };\r\n\r\n    // We need to remember the position of \"remainingLines\"\r\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\r\n\r\n    // The generate SourceNodes we need a code range.\r\n    // To extract it current and last mapping is used.\r\n    // Here we store the last mapping.\r\n    var lastMapping = null;\r\n\r\n    aSourceMapConsumer.eachMapping(function (mapping) {\r\n      if (lastMapping !== null) {\r\n        // We add the code from \"lastMapping\" to \"mapping\":\r\n        // First check if there is a new line in between.\r\n        if (lastGeneratedLine < mapping.generatedLine) {\r\n          // Associate first line with \"lastMapping\"\r\n          addMappingWithCode(lastMapping, shiftNextLine());\r\n          lastGeneratedLine++;\r\n          lastGeneratedColumn = 0;\r\n          // The remaining code is added without mapping\r\n        } else {\r\n          // There is no new line in between.\r\n          // Associate the code between \"lastGeneratedColumn\" and\r\n          // \"mapping.generatedColumn\" with \"lastMapping\"\r\n          var nextLine = remainingLines[remainingLinesIndex] || '';\r\n          var code = nextLine.substr(0, mapping.generatedColumn -\r\n                                        lastGeneratedColumn);\r\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\r\n                                              lastGeneratedColumn);\r\n          lastGeneratedColumn = mapping.generatedColumn;\r\n          addMappingWithCode(lastMapping, code);\r\n          // No more remaining code, continue\r\n          lastMapping = mapping;\r\n          return;\r\n        }\r\n      }\r\n      // We add the generated code until the first mapping\r\n      // to the SourceNode without any mapping.\r\n      // Each line is added as separate string.\r\n      while (lastGeneratedLine < mapping.generatedLine) {\r\n        node.add(shiftNextLine());\r\n        lastGeneratedLine++;\r\n      }\r\n      if (lastGeneratedColumn < mapping.generatedColumn) {\r\n        var nextLine = remainingLines[remainingLinesIndex] || '';\r\n        node.add(nextLine.substr(0, mapping.generatedColumn));\r\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\r\n        lastGeneratedColumn = mapping.generatedColumn;\r\n      }\r\n      lastMapping = mapping;\r\n    }, this);\r\n    // We have processed all mappings.\r\n    if (remainingLinesIndex < remainingLines.length) {\r\n      if (lastMapping) {\r\n        // Associate the remaining code in the current line with \"lastMapping\"\r\n        addMappingWithCode(lastMapping, shiftNextLine());\r\n      }\r\n      // and add the remaining lines without any mapping\r\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\r\n    }\r\n\r\n    // Copy sourcesContent into SourceNode\r\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\r\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n      if (content != null) {\r\n        if (aRelativePath != null) {\r\n          sourceFile = util.join(aRelativePath, sourceFile);\r\n        }\r\n        node.setSourceContent(sourceFile, content);\r\n      }\r\n    });\r\n\r\n    return node;\r\n\r\n    function addMappingWithCode(mapping, code) {\r\n      if (mapping === null || mapping.source === undefined) {\r\n        node.add(code);\r\n      } else {\r\n        var source = aRelativePath\r\n          ? util.join(aRelativePath, mapping.source)\r\n          : mapping.source;\r\n        node.add(new SourceNode(mapping.originalLine,\r\n                                mapping.originalColumn,\r\n                                source,\r\n                                code,\r\n                                mapping.name));\r\n      }\r\n    }\r\n  };\r\n\r\n/**\r\n * Add a chunk of generated JS to this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    aChunk.forEach(function (chunk) {\r\n      this.add(chunk);\r\n    }, this);\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    if (aChunk) {\r\n      this.children.push(aChunk);\r\n    }\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a chunk of generated JS to the beginning of this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    for (var i = aChunk.length-1; i >= 0; i--) {\r\n      this.prepend(aChunk[i]);\r\n    }\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    this.children.unshift(aChunk);\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Walk over the tree of JS snippets in this node and its children. The\r\n * walking function is called once for each snippet of JS and is passed that\r\n * snippet and the its original associated source's line/column location.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\r\n  var chunk;\r\n  for (var i = 0, len = this.children.length; i < len; i++) {\r\n    chunk = this.children[i];\r\n    if (chunk[isSourceNode]) {\r\n      chunk.walk(aFn);\r\n    }\r\n    else {\r\n      if (chunk !== '') {\r\n        aFn(chunk, { source: this.source,\r\n                     line: this.line,\r\n                     column: this.column,\r\n                     name: this.name });\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\r\n * each of `this.children`.\r\n *\r\n * @param aSep The separator.\r\n */\r\nSourceNode.prototype.join = function SourceNode_join(aSep) {\r\n  var newChildren;\r\n  var i;\r\n  var len = this.children.length;\r\n  if (len > 0) {\r\n    newChildren = [];\r\n    for (i = 0; i < len-1; i++) {\r\n      newChildren.push(this.children[i]);\r\n      newChildren.push(aSep);\r\n    }\r\n    newChildren.push(this.children[i]);\r\n    this.children = newChildren;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Call String.prototype.replace on the very right-most source snippet. Useful\r\n * for trimming whitespace from the end of a source node, etc.\r\n *\r\n * @param aPattern The pattern to replace.\r\n * @param aReplacement The thing to replace the pattern with.\r\n */\r\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\r\n  var lastChild = this.children[this.children.length - 1];\r\n  if (lastChild[isSourceNode]) {\r\n    lastChild.replaceRight(aPattern, aReplacement);\r\n  }\r\n  else if (typeof lastChild === 'string') {\r\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\r\n  }\r\n  else {\r\n    this.children.push(''.replace(aPattern, aReplacement));\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the source content for a source file. This will be added to the SourceMapGenerator\r\n * in the sourcesContent field.\r\n *\r\n * @param aSourceFile The filename of the source file\r\n * @param aSourceContent The content of the source file\r\n */\r\nSourceNode.prototype.setSourceContent =\r\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\r\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\r\n  };\r\n\r\n/**\r\n * Walk over the tree of SourceNodes. The walking function is called for each\r\n * source file content and is passed the filename and source content.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walkSourceContents =\r\n  function SourceNode_walkSourceContents(aFn) {\r\n    for (var i = 0, len = this.children.length; i < len; i++) {\r\n      if (this.children[i][isSourceNode]) {\r\n        this.children[i].walkSourceContents(aFn);\r\n      }\r\n    }\r\n\r\n    var sources = Object.keys(this.sourceContents);\r\n    for (var i = 0, len = sources.length; i < len; i++) {\r\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\r\n    }\r\n  };\r\n\r\n/**\r\n * Return the string representation of this source node. Walks over the tree\r\n * and concatenates all the various snippets together to one string.\r\n */\r\nSourceNode.prototype.toString = function SourceNode_toString() {\r\n  var str = \"\";\r\n  this.walk(function (chunk) {\r\n    str += chunk;\r\n  });\r\n  return str;\r\n};\r\n\r\n/**\r\n * Returns the string representation of this source node along with a source\r\n * map.\r\n */\r\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\r\n  var generated = {\r\n    code: \"\",\r\n    line: 1,\r\n    column: 0\r\n  };\r\n  var map = new SourceMapGenerator(aArgs);\r\n  var sourceMappingActive = false;\r\n  var lastOriginalSource = null;\r\n  var lastOriginalLine = null;\r\n  var lastOriginalColumn = null;\r\n  var lastOriginalName = null;\r\n  this.walk(function (chunk, original) {\r\n    generated.code += chunk;\r\n    if (original.source !== null\r\n        && original.line !== null\r\n        && original.column !== null) {\r\n      if(lastOriginalSource !== original.source\r\n         || lastOriginalLine !== original.line\r\n         || lastOriginalColumn !== original.column\r\n         || lastOriginalName !== original.name) {\r\n        map.addMapping({\r\n          source: original.source,\r\n          original: {\r\n            line: original.line,\r\n            column: original.column\r\n          },\r\n          generated: {\r\n            line: generated.line,\r\n            column: generated.column\r\n          },\r\n          name: original.name\r\n        });\r\n      }\r\n      lastOriginalSource = original.source;\r\n      lastOriginalLine = original.line;\r\n      lastOriginalColumn = original.column;\r\n      lastOriginalName = original.name;\r\n      sourceMappingActive = true;\r\n    } else if (sourceMappingActive) {\r\n      map.addMapping({\r\n        generated: {\r\n          line: generated.line,\r\n          column: generated.column\r\n        }\r\n      });\r\n      lastOriginalSource = null;\r\n      sourceMappingActive = false;\r\n    }\r\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\r\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\r\n        generated.line++;\r\n        generated.column = 0;\r\n        // Mappings end at eol\r\n        if (idx + 1 === length) {\r\n          lastOriginalSource = null;\r\n          sourceMappingActive = false;\r\n        } else if (sourceMappingActive) {\r\n          map.addMapping({\r\n            source: original.source,\r\n            original: {\r\n              line: original.line,\r\n              column: original.column\r\n            },\r\n            generated: {\r\n              line: generated.line,\r\n              column: generated.column\r\n            },\r\n            name: original.name\r\n          });\r\n        }\r\n      } else {\r\n        generated.column++;\r\n      }\r\n    }\r\n  });\r\n  this.walkSourceContents(function (sourceFile, sourceContent) {\r\n    map.setSourceContent(sourceFile, sourceContent);\r\n  });\r\n\r\n  return { code: generated.code, map: map };\r\n};\r\n\r\nexports.SourceNode = SourceNode;\r\n"]}