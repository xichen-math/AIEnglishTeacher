{"version":3,"sources":["index.js","http.js","https.js","debug.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;AACA;AELA,AFMA;AELA,AFMA;AACA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var url = require(\"url\");\r\nvar URL = url.URL;\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar Writable = require(\"stream\").Writable;\r\nvar assert = require(\"assert\");\r\nvar debug = require(\"./debug\");\r\n\r\n// Preventive platform detection\r\n// istanbul ignore next\r\n(function detectUnsupportedEnvironment() {\r\n  var looksLikeNode = typeof process !== \"undefined\";\r\n  var looksLikeBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\r\n  var looksLikeV8 = isFunction(Error.captureStackTrace);\r\n  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {\r\n    console.warn(\"The follow-redirects package should be excluded from browser builds.\");\r\n  }\r\n}());\r\n\r\n// Whether to use the native URL object or the legacy url module\r\nvar useNativeURL = false;\r\ntry {\r\n  assert(new URL(\"\"));\r\n}\r\ncatch (error) {\r\n  useNativeURL = error.code === \"ERR_INVALID_URL\";\r\n}\r\n\r\n// URL fields to preserve in copy operations\r\nvar preservedUrlFields = [\r\n  \"auth\",\r\n  \"host\",\r\n  \"hostname\",\r\n  \"href\",\r\n  \"path\",\r\n  \"pathname\",\r\n  \"port\",\r\n  \"protocol\",\r\n  \"query\",\r\n  \"search\",\r\n  \"hash\",\r\n];\r\n\r\n// Create handlers that pass events from native requests\r\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\r\nvar eventHandlers = Object.create(null);\r\nevents.forEach(function (event) {\r\n  eventHandlers[event] = function (arg1, arg2, arg3) {\r\n    this._redirectable.emit(event, arg1, arg2, arg3);\r\n  };\r\n});\r\n\r\n// Error types with codes\r\nvar InvalidUrlError = createErrorType(\r\n  \"ERR_INVALID_URL\",\r\n  \"Invalid URL\",\r\n  TypeError\r\n);\r\nvar RedirectionError = createErrorType(\r\n  \"ERR_FR_REDIRECTION_FAILURE\",\r\n  \"Redirected request failed\"\r\n);\r\nvar TooManyRedirectsError = createErrorType(\r\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\r\n  \"Maximum number of redirects exceeded\",\r\n  RedirectionError\r\n);\r\nvar MaxBodyLengthExceededError = createErrorType(\r\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\r\n  \"Request body larger than maxBodyLength limit\"\r\n);\r\nvar WriteAfterEndError = createErrorType(\r\n  \"ERR_STREAM_WRITE_AFTER_END\",\r\n  \"write after end\"\r\n);\r\n\r\n// istanbul ignore next\r\nvar destroy = Writable.prototype.destroy || noop;\r\n\r\n// An HTTP(S) request that can be redirected\r\nfunction RedirectableRequest(options, responseCallback) {\r\n  // Initialize the request\r\n  Writable.call(this);\r\n  this._sanitizeOptions(options);\r\n  this._options = options;\r\n  this._ended = false;\r\n  this._ending = false;\r\n  this._redirectCount = 0;\r\n  this._redirects = [];\r\n  this._requestBodyLength = 0;\r\n  this._requestBodyBuffers = [];\r\n\r\n  // Attach a callback if passed\r\n  if (responseCallback) {\r\n    this.on(\"response\", responseCallback);\r\n  }\r\n\r\n  // React to responses of native requests\r\n  var self = this;\r\n  this._onNativeResponse = function (response) {\r\n    try {\r\n      self._processResponse(response);\r\n    }\r\n    catch (cause) {\r\n      self.emit(\"error\", cause instanceof RedirectionError ?\r\n        cause : new RedirectionError({ cause: cause }));\r\n    }\r\n  };\r\n\r\n  // Perform the first request\r\n  this._performRequest();\r\n}\r\nRedirectableRequest.prototype = Object.create(Writable.prototype);\r\n\r\nRedirectableRequest.prototype.abort = function () {\r\n  destroyRequest(this._currentRequest);\r\n  this._currentRequest.abort();\r\n  this.emit(\"abort\");\r\n};\r\n\r\nRedirectableRequest.prototype.destroy = function (error) {\r\n  destroyRequest(this._currentRequest, error);\r\n  destroy.call(this, error);\r\n  return this;\r\n};\r\n\r\n// Writes buffered data to the current native request\r\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\r\n  // Writing is not allowed if end has been called\r\n  if (this._ending) {\r\n    throw new WriteAfterEndError();\r\n  }\r\n\r\n  // Validate input and shift parameters if necessary\r\n  if (!isString(data) && !isBuffer(data)) {\r\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\r\n  }\r\n  if (isFunction(encoding)) {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Ignore empty buffers, since writing them doesn't invoke the callback\r\n  // https://github.com/nodejs/node/issues/22066\r\n  if (data.length === 0) {\r\n    if (callback) {\r\n      callback();\r\n    }\r\n    return;\r\n  }\r\n  // Only write when we don't exceed the maximum body length\r\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\r\n    this._requestBodyLength += data.length;\r\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\r\n    this._currentRequest.write(data, encoding, callback);\r\n  }\r\n  // Error when we exceed the maximum body length\r\n  else {\r\n    this.emit(\"error\", new MaxBodyLengthExceededError());\r\n    this.abort();\r\n  }\r\n};\r\n\r\n// Ends the current native request\r\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\r\n  // Shift parameters if necessary\r\n  if (isFunction(data)) {\r\n    callback = data;\r\n    data = encoding = null;\r\n  }\r\n  else if (isFunction(encoding)) {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Write data if needed and end\r\n  if (!data) {\r\n    this._ended = this._ending = true;\r\n    this._currentRequest.end(null, null, callback);\r\n  }\r\n  else {\r\n    var self = this;\r\n    var currentRequest = this._currentRequest;\r\n    this.write(data, encoding, function () {\r\n      self._ended = true;\r\n      currentRequest.end(null, null, callback);\r\n    });\r\n    this._ending = true;\r\n  }\r\n};\r\n\r\n// Sets a header value on the current native request\r\nRedirectableRequest.prototype.setHeader = function (name, value) {\r\n  this._options.headers[name] = value;\r\n  this._currentRequest.setHeader(name, value);\r\n};\r\n\r\n// Clears a header value on the current native request\r\nRedirectableRequest.prototype.removeHeader = function (name) {\r\n  delete this._options.headers[name];\r\n  this._currentRequest.removeHeader(name);\r\n};\r\n\r\n// Global timeout for all underlying requests\r\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\r\n  var self = this;\r\n\r\n  // Destroys the socket on timeout\r\n  function destroyOnTimeout(socket) {\r\n    socket.setTimeout(msecs);\r\n    socket.removeListener(\"timeout\", socket.destroy);\r\n    socket.addListener(\"timeout\", socket.destroy);\r\n  }\r\n\r\n  // Sets up a timer to trigger a timeout event\r\n  function startTimer(socket) {\r\n    if (self._timeout) {\r\n      clearTimeout(self._timeout);\r\n    }\r\n    self._timeout = setTimeout(function () {\r\n      self.emit(\"timeout\");\r\n      clearTimer();\r\n    }, msecs);\r\n    destroyOnTimeout(socket);\r\n  }\r\n\r\n  // Stops a timeout from triggering\r\n  function clearTimer() {\r\n    // Clear the timeout\r\n    if (self._timeout) {\r\n      clearTimeout(self._timeout);\r\n      self._timeout = null;\r\n    }\r\n\r\n    // Clean up all attached listeners\r\n    self.removeListener(\"abort\", clearTimer);\r\n    self.removeListener(\"error\", clearTimer);\r\n    self.removeListener(\"response\", clearTimer);\r\n    self.removeListener(\"close\", clearTimer);\r\n    if (callback) {\r\n      self.removeListener(\"timeout\", callback);\r\n    }\r\n    if (!self.socket) {\r\n      self._currentRequest.removeListener(\"socket\", startTimer);\r\n    }\r\n  }\r\n\r\n  // Attach callback if passed\r\n  if (callback) {\r\n    this.on(\"timeout\", callback);\r\n  }\r\n\r\n  // Start the timer if or when the socket is opened\r\n  if (this.socket) {\r\n    startTimer(this.socket);\r\n  }\r\n  else {\r\n    this._currentRequest.once(\"socket\", startTimer);\r\n  }\r\n\r\n  // Clean up on events\r\n  this.on(\"socket\", destroyOnTimeout);\r\n  this.on(\"abort\", clearTimer);\r\n  this.on(\"error\", clearTimer);\r\n  this.on(\"response\", clearTimer);\r\n  this.on(\"close\", clearTimer);\r\n\r\n  return this;\r\n};\r\n\r\n// Proxy all other public ClientRequest methods\r\n[\r\n  \"flushHeaders\", \"getHeader\",\r\n  \"setNoDelay\", \"setSocketKeepAlive\",\r\n].forEach(function (method) {\r\n  RedirectableRequest.prototype[method] = function (a, b) {\r\n    return this._currentRequest[method](a, b);\r\n  };\r\n});\r\n\r\n// Proxy all public ClientRequest properties\r\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\r\n  Object.defineProperty(RedirectableRequest.prototype, property, {\r\n    get: function () { return this._currentRequest[property]; },\r\n  });\r\n});\r\n\r\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\r\n  // Ensure headers are always present\r\n  if (!options.headers) {\r\n    options.headers = {};\r\n  }\r\n\r\n  // Since http.request treats host as an alias of hostname,\r\n  // but the url module interprets host as hostname plus port,\r\n  // eliminate the host property to avoid confusion.\r\n  if (options.host) {\r\n    // Use hostname if set, because it has precedence\r\n    if (!options.hostname) {\r\n      options.hostname = options.host;\r\n    }\r\n    delete options.host;\r\n  }\r\n\r\n  // Complete the URL object when necessary\r\n  if (!options.pathname && options.path) {\r\n    var searchPos = options.path.indexOf(\"?\");\r\n    if (searchPos < 0) {\r\n      options.pathname = options.path;\r\n    }\r\n    else {\r\n      options.pathname = options.path.substring(0, searchPos);\r\n      options.search = options.path.substring(searchPos);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n// Executes the next native request (initial or redirect)\r\nRedirectableRequest.prototype._performRequest = function () {\r\n  // Load the native protocol\r\n  var protocol = this._options.protocol;\r\n  var nativeProtocol = this._options.nativeProtocols[protocol];\r\n  if (!nativeProtocol) {\r\n    throw new TypeError(\"Unsupported protocol \" + protocol);\r\n  }\r\n\r\n  // If specified, use the agent corresponding to the protocol\r\n  // (HTTP and HTTPS use different types of agents)\r\n  if (this._options.agents) {\r\n    var scheme = protocol.slice(0, -1);\r\n    this._options.agent = this._options.agents[scheme];\r\n  }\r\n\r\n  // Create the native request and set up its event handlers\r\n  var request = this._currentRequest =\r\n        nativeProtocol.request(this._options, this._onNativeResponse);\r\n  request._redirectable = this;\r\n  for (var event of events) {\r\n    request.on(event, eventHandlers[event]);\r\n  }\r\n\r\n  // RFC7230§5.3.1: When making a request directly to an origin server, […]\r\n  // a client MUST send only the absolute path […] as the request-target.\r\n  this._currentUrl = /^\\//.test(this._options.path) ?\r\n    url.format(this._options) :\r\n    // When making a request to a proxy, […]\r\n    // a client MUST send the target URI in absolute-form […].\r\n    this._options.path;\r\n\r\n  // End a redirected request\r\n  // (The first request must be ended explicitly with RedirectableRequest#end)\r\n  if (this._isRedirect) {\r\n    // Write the request entity and end\r\n    var i = 0;\r\n    var self = this;\r\n    var buffers = this._requestBodyBuffers;\r\n    (function writeNext(error) {\r\n      // Only write if this request has not been redirected yet\r\n      // istanbul ignore else\r\n      if (request === self._currentRequest) {\r\n        // Report any write errors\r\n        // istanbul ignore if\r\n        if (error) {\r\n          self.emit(\"error\", error);\r\n        }\r\n        // Write the next buffer if there are still left\r\n        else if (i < buffers.length) {\r\n          var buffer = buffers[i++];\r\n          // istanbul ignore else\r\n          if (!request.finished) {\r\n            request.write(buffer.data, buffer.encoding, writeNext);\r\n          }\r\n        }\r\n        // End the request if `end` has been called on us\r\n        else if (self._ended) {\r\n          request.end();\r\n        }\r\n      }\r\n    }());\r\n  }\r\n};\r\n\r\n// Processes a response from the current native request\r\nRedirectableRequest.prototype._processResponse = function (response) {\r\n  // Store the redirected response\r\n  var statusCode = response.statusCode;\r\n  if (this._options.trackRedirects) {\r\n    this._redirects.push({\r\n      url: this._currentUrl,\r\n      headers: response.headers,\r\n      statusCode: statusCode,\r\n    });\r\n  }\r\n\r\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\r\n  // that further action needs to be taken by the user agent in order to\r\n  // fulfill the request. If a Location header field is provided,\r\n  // the user agent MAY automatically redirect its request to the URI\r\n  // referenced by the Location field value,\r\n  // even if the specific status code is not understood.\r\n\r\n  // If the response is not a redirect; return it as-is\r\n  var location = response.headers.location;\r\n  if (!location || this._options.followRedirects === false ||\r\n      statusCode < 300 || statusCode >= 400) {\r\n    response.responseUrl = this._currentUrl;\r\n    response.redirects = this._redirects;\r\n    this.emit(\"response\", response);\r\n\r\n    // Clean up\r\n    this._requestBodyBuffers = [];\r\n    return;\r\n  }\r\n\r\n  // The response is a redirect, so abort the current request\r\n  destroyRequest(this._currentRequest);\r\n  // Discard the remainder of the response to avoid waiting for data\r\n  response.destroy();\r\n\r\n  // RFC7231§6.4: A client SHOULD detect and intervene\r\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\r\n  if (++this._redirectCount > this._options.maxRedirects) {\r\n    throw new TooManyRedirectsError();\r\n  }\r\n\r\n  // Store the request headers if applicable\r\n  var requestHeaders;\r\n  var beforeRedirect = this._options.beforeRedirect;\r\n  if (beforeRedirect) {\r\n    requestHeaders = Object.assign({\r\n      // The Host header was set by nativeProtocol.request\r\n      Host: response.req.getHeader(\"host\"),\r\n    }, this._options.headers);\r\n  }\r\n\r\n  // RFC7231§6.4: Automatic redirection needs to done with\r\n  // care for methods not known to be safe, […]\r\n  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\r\n  // the request method from POST to GET for the subsequent request.\r\n  var method = this._options.method;\r\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\r\n      // RFC7231§6.4.4: The 303 (See Other) status code indicates that\r\n      // the server is redirecting the user agent to a different resource […]\r\n      // A user agent can perform a retrieval request targeting that URI\r\n      // (a GET or HEAD request if using HTTP) […]\r\n      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\r\n    this._options.method = \"GET\";\r\n    // Drop a possible entity and headers related to it\r\n    this._requestBodyBuffers = [];\r\n    removeMatchingHeaders(/^content-/i, this._options.headers);\r\n  }\r\n\r\n  // Drop the Host header, as the redirect might lead to a different host\r\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\r\n\r\n  // If the redirect is relative, carry over the host of the last request\r\n  var currentUrlParts = parseUrl(this._currentUrl);\r\n  var currentHost = currentHostHeader || currentUrlParts.host;\r\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\r\n    url.format(Object.assign(currentUrlParts, { host: currentHost }));\r\n\r\n  // Create the redirected request\r\n  var redirectUrl = resolveUrl(location, currentUrl);\r\n  debug(\"redirecting to\", redirectUrl.href);\r\n  this._isRedirect = true;\r\n  spreadUrlObject(redirectUrl, this._options);\r\n\r\n  // Drop confidential headers when redirecting to a less secure protocol\r\n  // or to a different domain that is not a superdomain\r\n  if (redirectUrl.protocol !== currentUrlParts.protocol &&\r\n     redirectUrl.protocol !== \"https:\" ||\r\n     redirectUrl.host !== currentHost &&\r\n     !isSubdomain(redirectUrl.host, currentHost)) {\r\n    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);\r\n  }\r\n\r\n  // Evaluate the beforeRedirect callback\r\n  if (isFunction(beforeRedirect)) {\r\n    var responseDetails = {\r\n      headers: response.headers,\r\n      statusCode: statusCode,\r\n    };\r\n    var requestDetails = {\r\n      url: currentUrl,\r\n      method: method,\r\n      headers: requestHeaders,\r\n    };\r\n    beforeRedirect(this._options, responseDetails, requestDetails);\r\n    this._sanitizeOptions(this._options);\r\n  }\r\n\r\n  // Perform the redirected request\r\n  this._performRequest();\r\n};\r\n\r\n// Wraps the key/value object of protocols with redirect functionality\r\nfunction wrap(protocols) {\r\n  // Default settings\r\n  var exports = {\r\n    maxRedirects: 21,\r\n    maxBodyLength: 10 * 1024 * 1024,\r\n  };\r\n\r\n  // Wrap each protocol\r\n  var nativeProtocols = {};\r\n  Object.keys(protocols).forEach(function (scheme) {\r\n    var protocol = scheme + \":\";\r\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\r\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\r\n\r\n    // Executes a request, following redirects\r\n    function request(input, options, callback) {\r\n      // Parse parameters, ensuring that input is an object\r\n      if (isURL(input)) {\r\n        input = spreadUrlObject(input);\r\n      }\r\n      else if (isString(input)) {\r\n        input = spreadUrlObject(parseUrl(input));\r\n      }\r\n      else {\r\n        callback = options;\r\n        options = validateUrl(input);\r\n        input = { protocol: protocol };\r\n      }\r\n      if (isFunction(options)) {\r\n        callback = options;\r\n        options = null;\r\n      }\r\n\r\n      // Set defaults\r\n      options = Object.assign({\r\n        maxRedirects: exports.maxRedirects,\r\n        maxBodyLength: exports.maxBodyLength,\r\n      }, input, options);\r\n      options.nativeProtocols = nativeProtocols;\r\n      if (!isString(options.host) && !isString(options.hostname)) {\r\n        options.hostname = \"::1\";\r\n      }\r\n\r\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\r\n      debug(\"options\", options);\r\n      return new RedirectableRequest(options, callback);\r\n    }\r\n\r\n    // Executes a GET request, following redirects\r\n    function get(input, options, callback) {\r\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\r\n      wrappedRequest.end();\r\n      return wrappedRequest;\r\n    }\r\n\r\n    // Expose the properties on the wrapped protocol\r\n    Object.defineProperties(wrappedProtocol, {\r\n      request: { value: request, configurable: true, enumerable: true, writable: true },\r\n      get: { value: get, configurable: true, enumerable: true, writable: true },\r\n    });\r\n  });\r\n  return exports;\r\n}\r\n\r\nfunction noop() { /* empty */ }\r\n\r\nfunction parseUrl(input) {\r\n  var parsed;\r\n  // istanbul ignore else\r\n  if (useNativeURL) {\r\n    parsed = new URL(input);\r\n  }\r\n  else {\r\n    // Ensure the URL is valid and absolute\r\n    parsed = validateUrl(url.parse(input));\r\n    if (!isString(parsed.protocol)) {\r\n      throw new InvalidUrlError({ input });\r\n    }\r\n  }\r\n  return parsed;\r\n}\r\n\r\nfunction resolveUrl(relative, base) {\r\n  // istanbul ignore next\r\n  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));\r\n}\r\n\r\nfunction validateUrl(input) {\r\n  if (/^\\[/.test(input.hostname) && !/^\\[[:0-9a-f]+\\]$/i.test(input.hostname)) {\r\n    throw new InvalidUrlError({ input: input.href || input });\r\n  }\r\n  if (/^\\[/.test(input.host) && !/^\\[[:0-9a-f]+\\](:\\d+)?$/i.test(input.host)) {\r\n    throw new InvalidUrlError({ input: input.href || input });\r\n  }\r\n  return input;\r\n}\r\n\r\nfunction spreadUrlObject(urlObject, target) {\r\n  var spread = target || {};\r\n  for (var key of preservedUrlFields) {\r\n    spread[key] = urlObject[key];\r\n  }\r\n\r\n  // Fix IPv6 hostname\r\n  if (spread.hostname.startsWith(\"[\")) {\r\n    spread.hostname = spread.hostname.slice(1, -1);\r\n  }\r\n  // Ensure port is a number\r\n  if (spread.port !== \"\") {\r\n    spread.port = Number(spread.port);\r\n  }\r\n  // Concatenate path\r\n  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;\r\n\r\n  return spread;\r\n}\r\n\r\nfunction removeMatchingHeaders(regex, headers) {\r\n  var lastValue;\r\n  for (var header in headers) {\r\n    if (regex.test(header)) {\r\n      lastValue = headers[header];\r\n      delete headers[header];\r\n    }\r\n  }\r\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\r\n    undefined : String(lastValue).trim();\r\n}\r\n\r\nfunction createErrorType(code, message, baseClass) {\r\n  // Create constructor\r\n  function CustomError(properties) {\r\n    // istanbul ignore else\r\n    if (isFunction(Error.captureStackTrace)) {\r\n      Error.captureStackTrace(this, this.constructor);\r\n    }\r\n    Object.assign(this, properties || {});\r\n    this.code = code;\r\n    this.message = this.cause ? message + \": \" + this.cause.message : message;\r\n  }\r\n\r\n  // Attach constructor and set default properties\r\n  CustomError.prototype = new (baseClass || Error)();\r\n  Object.defineProperties(CustomError.prototype, {\r\n    constructor: {\r\n      value: CustomError,\r\n      enumerable: false,\r\n    },\r\n    name: {\r\n      value: \"Error [\" + code + \"]\",\r\n      enumerable: false,\r\n    },\r\n  });\r\n  return CustomError;\r\n}\r\n\r\nfunction destroyRequest(request, error) {\r\n  for (var event of events) {\r\n    request.removeListener(event, eventHandlers[event]);\r\n  }\r\n  request.on(\"error\", noop);\r\n  request.destroy(error);\r\n}\r\n\r\nfunction isSubdomain(subdomain, domain) {\r\n  assert(isString(subdomain) && isString(domain));\r\n  var dot = subdomain.length - domain.length - 1;\r\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\r\n}\r\n\r\nfunction isString(value) {\r\n  return typeof value === \"string\" || value instanceof String;\r\n}\r\n\r\nfunction isFunction(value) {\r\n  return typeof value === \"function\";\r\n}\r\n\r\nfunction isBuffer(value) {\r\n  return typeof value === \"object\" && (\"length\" in value);\r\n}\r\n\r\nfunction isURL(value) {\r\n  return URL && value instanceof URL;\r\n}\r\n\r\n// Exports\r\nmodule.exports = wrap({ http: http, https: https });\r\nmodule.exports.wrap = wrap;\r\n","module.exports = require(\"./\").http;\r\n","module.exports = require(\"./\").https;\r\n","var debug;\r\n\r\nmodule.exports = function () {\r\n  if (!debug) {\r\n    try {\r\n      /* eslint global-require: off */\r\n      debug = require(\"debug\")(\"follow-redirects\");\r\n    }\r\n    catch (error) { /* */ }\r\n    if (typeof debug !== \"function\") {\r\n      debug = function () { /* */ };\r\n    }\r\n  }\r\n  debug.apply(null, arguments);\r\n};\r\n"]}