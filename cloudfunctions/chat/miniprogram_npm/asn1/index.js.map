{"version":3,"sources":["index.js","ber/index.js","ber/errors.js","ber/types.js","ber/reader.js","ber/writer.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AHSA;AELA,ADGA,AGTA,ADGA,AENA,ALeA;AELA,ADGA,AGTA,ADGA,AENA,ALeA;AELA,ADGA,AGTA,ADGA,AENA,ALeA;AELA,ADGA,AGTA,ADGA,AENA,ALeA;AELA,ADGA,AGTA,ADGA,AENA,ALeA;ACFA,AGTA,ADGA,AENA,ALeA;ACFA,AGTA,ADGA,AENA;AJaA,AGTA,ADGA,AENA;AJaA,AGTA,ADGA,AENA;AJaA,AGTA,ADGA,AENA;AJaA,AGTA,ADGA,AENA;AJaA,AGTA,ADGA,AENA;AJaA,AGTA,ADGA,AENA;AJaA,AGTA,ADGA,AENA;AJaA,AGTA,ADGA,AENA;AJaA,AGTA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\r\n\r\n// If you have no idea what ASN.1 or BER is, see this:\r\n// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc\r\n\r\nvar Ber = require('./ber/index');\r\n\r\n\r\n\r\n// --- Exported API\r\n\r\nmodule.exports = {\r\n\r\n  Ber: Ber,\r\n\r\n  BerReader: Ber.Reader,\r\n\r\n  BerWriter: Ber.Writer\r\n\r\n};\r\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\r\n\r\nvar errors = require('./errors');\r\nvar types = require('./types');\r\n\r\nvar Reader = require('./reader');\r\nvar Writer = require('./writer');\r\n\r\n\r\n// --- Exports\r\n\r\nmodule.exports = {\r\n\r\n  Reader: Reader,\r\n\r\n  Writer: Writer\r\n\r\n};\r\n\r\nfor (var t in types) {\r\n  if (types.hasOwnProperty(t))\r\n    module.exports[t] = types[t];\r\n}\r\nfor (var e in errors) {\r\n  if (errors.hasOwnProperty(e))\r\n    module.exports[e] = errors[e];\r\n}\r\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\r\n\r\n\r\nmodule.exports = {\r\n\r\n  newInvalidAsn1Error: function (msg) {\r\n    var e = new Error();\r\n    e.name = 'InvalidAsn1Error';\r\n    e.message = msg || '';\r\n    return e;\r\n  }\r\n\r\n};\r\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\r\n\r\n\r\nmodule.exports = {\r\n  EOC: 0,\r\n  Boolean: 1,\r\n  Integer: 2,\r\n  BitString: 3,\r\n  OctetString: 4,\r\n  Null: 5,\r\n  OID: 6,\r\n  ObjectDescriptor: 7,\r\n  External: 8,\r\n  Real: 9, // float\r\n  Enumeration: 10,\r\n  PDV: 11,\r\n  Utf8String: 12,\r\n  RelativeOID: 13,\r\n  Sequence: 16,\r\n  Set: 17,\r\n  NumericString: 18,\r\n  PrintableString: 19,\r\n  T61String: 20,\r\n  VideotexString: 21,\r\n  IA5String: 22,\r\n  UTCTime: 23,\r\n  GeneralizedTime: 24,\r\n  GraphicString: 25,\r\n  VisibleString: 26,\r\n  GeneralString: 28,\r\n  UniversalString: 29,\r\n  CharacterString: 30,\r\n  BMPString: 31,\r\n  Constructor: 32,\r\n  Context: 128\r\n};\r\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\r\n\r\nvar assert = require('assert');\r\nvar Buffer = require('safer-buffer').Buffer;\r\n\r\nvar ASN1 = require('./types');\r\nvar errors = require('./errors');\r\n\r\n\r\n// --- Globals\r\n\r\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\r\n\r\n\r\n\r\n// --- API\r\n\r\nfunction Reader(data) {\r\n  if (!data || !Buffer.isBuffer(data))\r\n    throw new TypeError('data must be a node Buffer');\r\n\r\n  this._buf = data;\r\n  this._size = data.length;\r\n\r\n  // These hold the \"current\" state\r\n  this._len = 0;\r\n  this._offset = 0;\r\n}\r\n\r\nObject.defineProperty(Reader.prototype, 'length', {\r\n  enumerable: true,\r\n  get: function () { return (this._len); }\r\n});\r\n\r\nObject.defineProperty(Reader.prototype, 'offset', {\r\n  enumerable: true,\r\n  get: function () { return (this._offset); }\r\n});\r\n\r\nObject.defineProperty(Reader.prototype, 'remain', {\r\n  get: function () { return (this._size - this._offset); }\r\n});\r\n\r\nObject.defineProperty(Reader.prototype, 'buffer', {\r\n  get: function () { return (this._buf.slice(this._offset)); }\r\n});\r\n\r\n\r\n/**\r\n * Reads a single byte and advances offset; you can pass in `true` to make this\r\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\r\n *\r\n * @param {Boolean} peek true means don't move offset.\r\n * @return {Number} the next byte, null if not enough data.\r\n */\r\nReader.prototype.readByte = function (peek) {\r\n  if (this._size - this._offset < 1)\r\n    return null;\r\n\r\n  var b = this._buf[this._offset] & 0xff;\r\n\r\n  if (!peek)\r\n    this._offset += 1;\r\n\r\n  return b;\r\n};\r\n\r\n\r\nReader.prototype.peek = function () {\r\n  return this.readByte(true);\r\n};\r\n\r\n\r\n/**\r\n * Reads a (potentially) variable length off the BER buffer.  This call is\r\n * not really meant to be called directly, as callers have to manipulate\r\n * the internal buffer afterwards.\r\n *\r\n * As a result of this call, you can call `Reader.length`, until the\r\n * next thing called that does a readLength.\r\n *\r\n * @return {Number} the amount of offset to advance the buffer.\r\n * @throws {InvalidAsn1Error} on bad ASN.1\r\n */\r\nReader.prototype.readLength = function (offset) {\r\n  if (offset === undefined)\r\n    offset = this._offset;\r\n\r\n  if (offset >= this._size)\r\n    return null;\r\n\r\n  var lenB = this._buf[offset++] & 0xff;\r\n  if (lenB === null)\r\n    return null;\r\n\r\n  if ((lenB & 0x80) === 0x80) {\r\n    lenB &= 0x7f;\r\n\r\n    if (lenB === 0)\r\n      throw newInvalidAsn1Error('Indefinite length not supported');\r\n\r\n    if (lenB > 4)\r\n      throw newInvalidAsn1Error('encoding too long');\r\n\r\n    if (this._size - offset < lenB)\r\n      return null;\r\n\r\n    this._len = 0;\r\n    for (var i = 0; i < lenB; i++)\r\n      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\r\n\r\n  } else {\r\n    // Wasn't a variable length\r\n    this._len = lenB;\r\n  }\r\n\r\n  return offset;\r\n};\r\n\r\n\r\n/**\r\n * Parses the next sequence in this BER buffer.\r\n *\r\n * To get the length of the sequence, call `Reader.length`.\r\n *\r\n * @return {Number} the sequence's tag.\r\n */\r\nReader.prototype.readSequence = function (tag) {\r\n  var seq = this.peek();\r\n  if (seq === null)\r\n    return null;\r\n  if (tag !== undefined && tag !== seq)\r\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\r\n                              ': got 0x' + seq.toString(16));\r\n\r\n  var o = this.readLength(this._offset + 1); // stored in `length`\r\n  if (o === null)\r\n    return null;\r\n\r\n  this._offset = o;\r\n  return seq;\r\n};\r\n\r\n\r\nReader.prototype.readInt = function () {\r\n  return this._readTag(ASN1.Integer);\r\n};\r\n\r\n\r\nReader.prototype.readBoolean = function () {\r\n  return (this._readTag(ASN1.Boolean) === 0 ? false : true);\r\n};\r\n\r\n\r\nReader.prototype.readEnumeration = function () {\r\n  return this._readTag(ASN1.Enumeration);\r\n};\r\n\r\n\r\nReader.prototype.readString = function (tag, retbuf) {\r\n  if (!tag)\r\n    tag = ASN1.OctetString;\r\n\r\n  var b = this.peek();\r\n  if (b === null)\r\n    return null;\r\n\r\n  if (b !== tag)\r\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\r\n                              ': got 0x' + b.toString(16));\r\n\r\n  var o = this.readLength(this._offset + 1); // stored in `length`\r\n\r\n  if (o === null)\r\n    return null;\r\n\r\n  if (this.length > this._size - o)\r\n    return null;\r\n\r\n  this._offset = o;\r\n\r\n  if (this.length === 0)\r\n    return retbuf ? Buffer.alloc(0) : '';\r\n\r\n  var str = this._buf.slice(this._offset, this._offset + this.length);\r\n  this._offset += this.length;\r\n\r\n  return retbuf ? str : str.toString('utf8');\r\n};\r\n\r\nReader.prototype.readOID = function (tag) {\r\n  if (!tag)\r\n    tag = ASN1.OID;\r\n\r\n  var b = this.readString(tag, true);\r\n  if (b === null)\r\n    return null;\r\n\r\n  var values = [];\r\n  var value = 0;\r\n\r\n  for (var i = 0; i < b.length; i++) {\r\n    var byte = b[i] & 0xff;\r\n\r\n    value <<= 7;\r\n    value += byte & 0x7f;\r\n    if ((byte & 0x80) === 0) {\r\n      values.push(value);\r\n      value = 0;\r\n    }\r\n  }\r\n\r\n  value = values.shift();\r\n  values.unshift(value % 40);\r\n  values.unshift((value / 40) >> 0);\r\n\r\n  return values.join('.');\r\n};\r\n\r\n\r\nReader.prototype._readTag = function (tag) {\r\n  assert.ok(tag !== undefined);\r\n\r\n  var b = this.peek();\r\n\r\n  if (b === null)\r\n    return null;\r\n\r\n  if (b !== tag)\r\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\r\n                              ': got 0x' + b.toString(16));\r\n\r\n  var o = this.readLength(this._offset + 1); // stored in `length`\r\n  if (o === null)\r\n    return null;\r\n\r\n  if (this.length > 4)\r\n    throw newInvalidAsn1Error('Integer too long: ' + this.length);\r\n\r\n  if (this.length > this._size - o)\r\n    return null;\r\n  this._offset = o;\r\n\r\n  var fb = this._buf[this._offset];\r\n  var value = 0;\r\n\r\n  for (var i = 0; i < this.length; i++) {\r\n    value <<= 8;\r\n    value |= (this._buf[this._offset++] & 0xff);\r\n  }\r\n\r\n  if ((fb & 0x80) === 0x80 && i !== 4)\r\n    value -= (1 << (i * 8));\r\n\r\n  return value >> 0;\r\n};\r\n\r\n\r\n\r\n// --- Exported API\r\n\r\nmodule.exports = Reader;\r\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\r\n\r\nvar assert = require('assert');\r\nvar Buffer = require('safer-buffer').Buffer;\r\nvar ASN1 = require('./types');\r\nvar errors = require('./errors');\r\n\r\n\r\n// --- Globals\r\n\r\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\r\n\r\nvar DEFAULT_OPTS = {\r\n  size: 1024,\r\n  growthFactor: 8\r\n};\r\n\r\n\r\n// --- Helpers\r\n\r\nfunction merge(from, to) {\r\n  assert.ok(from);\r\n  assert.equal(typeof (from), 'object');\r\n  assert.ok(to);\r\n  assert.equal(typeof (to), 'object');\r\n\r\n  var keys = Object.getOwnPropertyNames(from);\r\n  keys.forEach(function (key) {\r\n    if (to[key])\r\n      return;\r\n\r\n    var value = Object.getOwnPropertyDescriptor(from, key);\r\n    Object.defineProperty(to, key, value);\r\n  });\r\n\r\n  return to;\r\n}\r\n\r\n\r\n\r\n// --- API\r\n\r\nfunction Writer(options) {\r\n  options = merge(DEFAULT_OPTS, options || {});\r\n\r\n  this._buf = Buffer.alloc(options.size || 1024);\r\n  this._size = this._buf.length;\r\n  this._offset = 0;\r\n  this._options = options;\r\n\r\n  // A list of offsets in the buffer where we need to insert\r\n  // sequence tag/len pairs.\r\n  this._seq = [];\r\n}\r\n\r\nObject.defineProperty(Writer.prototype, 'buffer', {\r\n  get: function () {\r\n    if (this._seq.length)\r\n      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\r\n\r\n    return (this._buf.slice(0, this._offset));\r\n  }\r\n});\r\n\r\nWriter.prototype.writeByte = function (b) {\r\n  if (typeof (b) !== 'number')\r\n    throw new TypeError('argument must be a Number');\r\n\r\n  this._ensure(1);\r\n  this._buf[this._offset++] = b;\r\n};\r\n\r\n\r\nWriter.prototype.writeInt = function (i, tag) {\r\n  if (typeof (i) !== 'number')\r\n    throw new TypeError('argument must be a Number');\r\n  if (typeof (tag) !== 'number')\r\n    tag = ASN1.Integer;\r\n\r\n  var sz = 4;\r\n\r\n  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&\r\n        (sz > 1)) {\r\n    sz--;\r\n    i <<= 8;\r\n  }\r\n\r\n  if (sz > 4)\r\n    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\r\n\r\n  this._ensure(2 + sz);\r\n  this._buf[this._offset++] = tag;\r\n  this._buf[this._offset++] = sz;\r\n\r\n  while (sz-- > 0) {\r\n    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);\r\n    i <<= 8;\r\n  }\r\n\r\n};\r\n\r\n\r\nWriter.prototype.writeNull = function () {\r\n  this.writeByte(ASN1.Null);\r\n  this.writeByte(0x00);\r\n};\r\n\r\n\r\nWriter.prototype.writeEnumeration = function (i, tag) {\r\n  if (typeof (i) !== 'number')\r\n    throw new TypeError('argument must be a Number');\r\n  if (typeof (tag) !== 'number')\r\n    tag = ASN1.Enumeration;\r\n\r\n  return this.writeInt(i, tag);\r\n};\r\n\r\n\r\nWriter.prototype.writeBoolean = function (b, tag) {\r\n  if (typeof (b) !== 'boolean')\r\n    throw new TypeError('argument must be a Boolean');\r\n  if (typeof (tag) !== 'number')\r\n    tag = ASN1.Boolean;\r\n\r\n  this._ensure(3);\r\n  this._buf[this._offset++] = tag;\r\n  this._buf[this._offset++] = 0x01;\r\n  this._buf[this._offset++] = b ? 0xff : 0x00;\r\n};\r\n\r\n\r\nWriter.prototype.writeString = function (s, tag) {\r\n  if (typeof (s) !== 'string')\r\n    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');\r\n  if (typeof (tag) !== 'number')\r\n    tag = ASN1.OctetString;\r\n\r\n  var len = Buffer.byteLength(s);\r\n  this.writeByte(tag);\r\n  this.writeLength(len);\r\n  if (len) {\r\n    this._ensure(len);\r\n    this._buf.write(s, this._offset);\r\n    this._offset += len;\r\n  }\r\n};\r\n\r\n\r\nWriter.prototype.writeBuffer = function (buf, tag) {\r\n  if (typeof (tag) !== 'number')\r\n    throw new TypeError('tag must be a number');\r\n  if (!Buffer.isBuffer(buf))\r\n    throw new TypeError('argument must be a buffer');\r\n\r\n  this.writeByte(tag);\r\n  this.writeLength(buf.length);\r\n  this._ensure(buf.length);\r\n  buf.copy(this._buf, this._offset, 0, buf.length);\r\n  this._offset += buf.length;\r\n};\r\n\r\n\r\nWriter.prototype.writeStringArray = function (strings) {\r\n  if ((!strings instanceof Array))\r\n    throw new TypeError('argument must be an Array[String]');\r\n\r\n  var self = this;\r\n  strings.forEach(function (s) {\r\n    self.writeString(s);\r\n  });\r\n};\r\n\r\n// This is really to solve DER cases, but whatever for now\r\nWriter.prototype.writeOID = function (s, tag) {\r\n  if (typeof (s) !== 'string')\r\n    throw new TypeError('argument must be a string');\r\n  if (typeof (tag) !== 'number')\r\n    tag = ASN1.OID;\r\n\r\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s))\r\n    throw new Error('argument is not a valid OID string');\r\n\r\n  function encodeOctet(bytes, octet) {\r\n    if (octet < 128) {\r\n        bytes.push(octet);\r\n    } else if (octet < 16384) {\r\n        bytes.push((octet >>> 7) | 0x80);\r\n        bytes.push(octet & 0x7F);\r\n    } else if (octet < 2097152) {\r\n      bytes.push((octet >>> 14) | 0x80);\r\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\r\n      bytes.push(octet & 0x7F);\r\n    } else if (octet < 268435456) {\r\n      bytes.push((octet >>> 21) | 0x80);\r\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\r\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\r\n      bytes.push(octet & 0x7F);\r\n    } else {\r\n      bytes.push(((octet >>> 28) | 0x80) & 0xFF);\r\n      bytes.push(((octet >>> 21) | 0x80) & 0xFF);\r\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\r\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\r\n      bytes.push(octet & 0x7F);\r\n    }\r\n  }\r\n\r\n  var tmp = s.split('.');\r\n  var bytes = [];\r\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\r\n  tmp.slice(2).forEach(function (b) {\r\n    encodeOctet(bytes, parseInt(b, 10));\r\n  });\r\n\r\n  var self = this;\r\n  this._ensure(2 + bytes.length);\r\n  this.writeByte(tag);\r\n  this.writeLength(bytes.length);\r\n  bytes.forEach(function (b) {\r\n    self.writeByte(b);\r\n  });\r\n};\r\n\r\n\r\nWriter.prototype.writeLength = function (len) {\r\n  if (typeof (len) !== 'number')\r\n    throw new TypeError('argument must be a Number');\r\n\r\n  this._ensure(4);\r\n\r\n  if (len <= 0x7f) {\r\n    this._buf[this._offset++] = len;\r\n  } else if (len <= 0xff) {\r\n    this._buf[this._offset++] = 0x81;\r\n    this._buf[this._offset++] = len;\r\n  } else if (len <= 0xffff) {\r\n    this._buf[this._offset++] = 0x82;\r\n    this._buf[this._offset++] = len >> 8;\r\n    this._buf[this._offset++] = len;\r\n  } else if (len <= 0xffffff) {\r\n    this._buf[this._offset++] = 0x83;\r\n    this._buf[this._offset++] = len >> 16;\r\n    this._buf[this._offset++] = len >> 8;\r\n    this._buf[this._offset++] = len;\r\n  } else {\r\n    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\r\n  }\r\n};\r\n\r\nWriter.prototype.startSequence = function (tag) {\r\n  if (typeof (tag) !== 'number')\r\n    tag = ASN1.Sequence | ASN1.Constructor;\r\n\r\n  this.writeByte(tag);\r\n  this._seq.push(this._offset);\r\n  this._ensure(3);\r\n  this._offset += 3;\r\n};\r\n\r\n\r\nWriter.prototype.endSequence = function () {\r\n  var seq = this._seq.pop();\r\n  var start = seq + 3;\r\n  var len = this._offset - start;\r\n\r\n  if (len <= 0x7f) {\r\n    this._shift(start, len, -2);\r\n    this._buf[seq] = len;\r\n  } else if (len <= 0xff) {\r\n    this._shift(start, len, -1);\r\n    this._buf[seq] = 0x81;\r\n    this._buf[seq + 1] = len;\r\n  } else if (len <= 0xffff) {\r\n    this._buf[seq] = 0x82;\r\n    this._buf[seq + 1] = len >> 8;\r\n    this._buf[seq + 2] = len;\r\n  } else if (len <= 0xffffff) {\r\n    this._shift(start, len, 1);\r\n    this._buf[seq] = 0x83;\r\n    this._buf[seq + 1] = len >> 16;\r\n    this._buf[seq + 2] = len >> 8;\r\n    this._buf[seq + 3] = len;\r\n  } else {\r\n    throw newInvalidAsn1Error('Sequence too long');\r\n  }\r\n};\r\n\r\n\r\nWriter.prototype._shift = function (start, len, shift) {\r\n  assert.ok(start !== undefined);\r\n  assert.ok(len !== undefined);\r\n  assert.ok(shift);\r\n\r\n  this._buf.copy(this._buf, start + shift, start, start + len);\r\n  this._offset += shift;\r\n};\r\n\r\nWriter.prototype._ensure = function (len) {\r\n  assert.ok(len);\r\n\r\n  if (this._size - this._offset < len) {\r\n    var sz = this._size * this._options.growthFactor;\r\n    if (sz - this._offset < len)\r\n      sz += len;\r\n\r\n    var buf = Buffer.alloc(sz);\r\n\r\n    this._buf.copy(buf, 0, 0, this._offset);\r\n    this._buf = buf;\r\n    this._size = sz;\r\n  }\r\n};\r\n\r\n\r\n\r\n// --- Exported API\r\n\r\nmodule.exports = Writer;\r\n"]}