{"version":3,"sources":["uri.all.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\r\n(function (global, factory) {\r\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\r\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\r\n\t(factory((global.URI = global.URI || {})));\r\n}(this, (function (exports) { \r\n\r\nfunction merge() {\r\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\r\n        sets[_key] = arguments[_key];\r\n    }\r\n\r\n    if (sets.length > 1) {\r\n        sets[0] = sets[0].slice(0, -1);\r\n        var xl = sets.length - 1;\r\n        for (var x = 1; x < xl; ++x) {\r\n            sets[x] = sets[x].slice(1, -1);\r\n        }\r\n        sets[xl] = sets[xl].slice(1);\r\n        return sets.join('');\r\n    } else {\r\n        return sets[0];\r\n    }\r\n}\r\nfunction subexp(str) {\r\n    return \"(?:\" + str + \")\";\r\n}\r\nfunction typeOf(o) {\r\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\r\n}\r\nfunction toUpperCase(str) {\r\n    return str.toUpperCase();\r\n}\r\nfunction toArray(obj) {\r\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\r\n}\r\nfunction assign(target, source) {\r\n    var obj = target;\r\n    if (source) {\r\n        for (var key in source) {\r\n            obj[key] = source[key];\r\n        }\r\n    }\r\n    return obj;\r\n}\r\n\r\nfunction buildExps(isIRI) {\r\n    var ALPHA$$ = \"[A-Za-z]\",\r\n        CR$ = \"[\\\\x0D]\",\r\n        DIGIT$$ = \"[0-9]\",\r\n        DQUOTE$$ = \"[\\\\x22]\",\r\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\r\n        //case-insensitive\r\n    LF$$ = \"[\\\\x0A]\",\r\n        SP$$ = \"[\\\\x20]\",\r\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\r\n        //expanded\r\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\r\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\r\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\r\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\r\n        //subset, excludes bidi control characters\r\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\r\n        //subset\r\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\r\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\r\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\r\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\r\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\r\n        //relaxed parsing rules\r\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\r\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\r\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\r\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\r\n        //                           6( h16 \":\" ) ls32\r\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\r\n        //                      \"::\" 5( h16 \":\" ) ls32\r\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\r\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\r\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\r\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\r\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\r\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\r\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\r\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\r\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\r\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\r\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\r\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\r\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\r\n        //[ *6( h16 \":\" ) h16 ] \"::\"\r\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\r\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\r\n        //RFC 6874\r\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\r\n        //RFC 6874\r\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\r\n        //RFC 6874, with relaxed parsing rules\r\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\r\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\r\n        //RFC 6874\r\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\r\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\r\n        PORT$ = subexp(DIGIT$$ + \"*\"),\r\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\r\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\r\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\r\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\r\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\r\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\r\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\r\n        //simplified\r\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\r\n        //simplified\r\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\r\n        //simplified\r\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\r\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\r\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\r\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\r\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\r\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\r\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\r\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\r\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\r\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\r\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\r\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\r\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\r\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\r\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\r\n    return {\r\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\r\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\r\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\r\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\r\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\r\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\r\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\r\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\r\n    };\r\n}\r\nvar URI_PROTOCOL = buildExps(false);\r\n\r\nvar IRI_PROTOCOL = buildExps(true);\r\n\r\nvar slicedToArray = function () {\r\n  function sliceIterator(arr, i) {\r\n    var _arr = [];\r\n    var _n = true;\r\n    var _d = false;\r\n    var _e = undefined;\r\n\r\n    try {\r\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\r\n        _arr.push(_s.value);\r\n\r\n        if (i && _arr.length === i) break;\r\n      }\r\n    } catch (err) {\r\n      _d = true;\r\n      _e = err;\r\n    } finally {\r\n      try {\r\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\r\n      } finally {\r\n        if (_d) throw _e;\r\n      }\r\n    }\r\n\r\n    return _arr;\r\n  }\r\n\r\n  return function (arr, i) {\r\n    if (Array.isArray(arr)) {\r\n      return arr;\r\n    } else if (Symbol.iterator in Object(arr)) {\r\n      return sliceIterator(arr, i);\r\n    } else {\r\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\r\n    }\r\n  };\r\n}();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar toConsumableArray = function (arr) {\r\n  if (Array.isArray(arr)) {\r\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\r\n\r\n    return arr2;\r\n  } else {\r\n    return Array.from(arr);\r\n  }\r\n};\r\n\r\n/** Highest positive signed 32-bit float value */\r\n\r\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\r\n\r\n/** Bootstring parameters */\r\nvar base = 36;\r\nvar tMin = 1;\r\nvar tMax = 26;\r\nvar skew = 38;\r\nvar damp = 700;\r\nvar initialBias = 72;\r\nvar initialN = 128; // 0x80\r\nvar delimiter = '-'; // '\\x2D'\r\n\r\n/** Regular expressions */\r\nvar regexPunycode = /^xn--/;\r\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\r\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\r\n\r\n/** Error messages */\r\nvar errors = {\r\n\t'overflow': 'Overflow: input needs wider integers to process',\r\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\r\n\t'invalid-input': 'Invalid input'\r\n};\r\n\r\n/** Convenience shortcuts */\r\nvar baseMinusTMin = base - tMin;\r\nvar floor = Math.floor;\r\nvar stringFromCharCode = String.fromCharCode;\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\n/**\r\n * A generic error utility function.\r\n * @private\r\n * @param {String} type The error type.\r\n * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n */\r\nfunction error$1(type) {\r\n\tthrow new RangeError(errors[type]);\r\n}\r\n\r\n/**\r\n * A generic `Array#map` utility function.\r\n * @private\r\n * @param {Array} array The array to iterate over.\r\n * @param {Function} callback The function that gets called for every array\r\n * item.\r\n * @returns {Array} A new array of values returned by the callback function.\r\n */\r\nfunction map(array, fn) {\r\n\tvar result = [];\r\n\tvar length = array.length;\r\n\twhile (length--) {\r\n\t\tresult[length] = fn(array[length]);\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n * addresses.\r\n * @private\r\n * @param {String} domain The domain name or email address.\r\n * @param {Function} callback The function that gets called for every\r\n * character.\r\n * @returns {Array} A new string of characters returned by the callback\r\n * function.\r\n */\r\nfunction mapDomain(string, fn) {\r\n\tvar parts = string.split('@');\r\n\tvar result = '';\r\n\tif (parts.length > 1) {\r\n\t\t// In email addresses, only the domain name should be punycoded. Leave\r\n\t\t// the local part (i.e. everything up to `@`) intact.\r\n\t\tresult = parts[0] + '@';\r\n\t\tstring = parts[1];\r\n\t}\r\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\r\n\tstring = string.replace(regexSeparators, '\\x2E');\r\n\tvar labels = string.split('.');\r\n\tvar encoded = map(labels, fn).join('.');\r\n\treturn result + encoded;\r\n}\r\n\r\n/**\r\n * Creates an array containing the numeric code points of each Unicode\r\n * character in the string. While JavaScript uses UCS-2 internally,\r\n * this function will convert a pair of surrogate halves (each of which\r\n * UCS-2 exposes as separate characters) into a single code point,\r\n * matching UTF-16.\r\n * @see `punycode.ucs2.encode`\r\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n * @memberOf punycode.ucs2\r\n * @name decode\r\n * @param {String} string The Unicode input string (UCS-2).\r\n * @returns {Array} The new array of code points.\r\n */\r\nfunction ucs2decode(string) {\r\n\tvar output = [];\r\n\tvar counter = 0;\r\n\tvar length = string.length;\r\n\twhile (counter < length) {\r\n\t\tvar value = string.charCodeAt(counter++);\r\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\r\n\t\t\t// It's a high surrogate, and there is a next character.\r\n\t\t\tvar extra = string.charCodeAt(counter++);\r\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\r\n\t\t\t\t// Low surrogate.\r\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\r\n\t\t\t} else {\r\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\r\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\r\n\t\t\t\toutput.push(value);\r\n\t\t\t\tcounter--;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\toutput.push(value);\r\n\t\t}\r\n\t}\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Creates a string based on an array of numeric code points.\r\n * @see `punycode.ucs2.decode`\r\n * @memberOf punycode.ucs2\r\n * @name encode\r\n * @param {Array} codePoints The array of numeric code points.\r\n * @returns {String} The new Unicode string (UCS-2).\r\n */\r\nvar ucs2encode = function ucs2encode(array) {\r\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\r\n};\r\n\r\n/**\r\n * Converts a basic code point into a digit/integer.\r\n * @see `digitToBasic()`\r\n * @private\r\n * @param {Number} codePoint The basic numeric code point value.\r\n * @returns {Number} The numeric value of a basic code point (for use in\r\n * representing integers) in the range `0` to `base - 1`, or `base` if\r\n * the code point does not represent a value.\r\n */\r\nvar basicToDigit = function basicToDigit(codePoint) {\r\n\tif (codePoint - 0x30 < 0x0A) {\r\n\t\treturn codePoint - 0x16;\r\n\t}\r\n\tif (codePoint - 0x41 < 0x1A) {\r\n\t\treturn codePoint - 0x41;\r\n\t}\r\n\tif (codePoint - 0x61 < 0x1A) {\r\n\t\treturn codePoint - 0x61;\r\n\t}\r\n\treturn base;\r\n};\r\n\r\n/**\r\n * Converts a digit/integer into a basic code point.\r\n * @see `basicToDigit()`\r\n * @private\r\n * @param {Number} digit The numeric value of a basic code point.\r\n * @returns {Number} The basic code point whose value (when used for\r\n * representing integers) is `digit`, which needs to be in the range\r\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n * used; else, the lowercase form is used. The behavior is undefined\r\n * if `flag` is non-zero and `digit` has no uppercase form.\r\n */\r\nvar digitToBasic = function digitToBasic(digit, flag) {\r\n\t//  0..25 map to ASCII a..z or A..Z\r\n\t// 26..35 map to ASCII 0..9\r\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n};\r\n\r\n/**\r\n * Bias adaptation function as per section 3.4 of RFC 3492.\r\n * https://tools.ietf.org/html/rfc3492#section-3.4\r\n * @private\r\n */\r\nvar adapt = function adapt(delta, numPoints, firstTime) {\r\n\tvar k = 0;\r\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\r\n\tdelta += floor(delta / numPoints);\r\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\r\n\t\tdelta = floor(delta / baseMinusTMin);\r\n\t}\r\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n};\r\n\r\n/**\r\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n * symbols.\r\n * @memberOf punycode\r\n * @param {String} input The Punycode string of ASCII-only symbols.\r\n * @returns {String} The resulting string of Unicode symbols.\r\n */\r\nvar decode = function decode(input) {\r\n\t// Don't use UCS-2.\r\n\tvar output = [];\r\n\tvar inputLength = input.length;\r\n\tvar i = 0;\r\n\tvar n = initialN;\r\n\tvar bias = initialBias;\r\n\r\n\t// Handle the basic code points: let `basic` be the number of input code\r\n\t// points before the last delimiter, or `0` if there is none, then copy\r\n\t// the first basic code points to the output.\r\n\r\n\tvar basic = input.lastIndexOf(delimiter);\r\n\tif (basic < 0) {\r\n\t\tbasic = 0;\r\n\t}\r\n\r\n\tfor (var j = 0; j < basic; ++j) {\r\n\t\t// if it's not a basic code point\r\n\t\tif (input.charCodeAt(j) >= 0x80) {\r\n\t\t\terror$1('not-basic');\r\n\t\t}\r\n\t\toutput.push(input.charCodeAt(j));\r\n\t}\r\n\r\n\t// Main decoding loop: start just after the last delimiter if any basic code\r\n\t// points were copied; start at the beginning otherwise.\r\n\r\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\r\n\r\n\t\t// `index` is the index of the next character to be consumed.\r\n\t\t// Decode a generalized variable-length integer into `delta`,\r\n\t\t// which gets added to `i`. The overflow checking is easier\r\n\t\t// if we increase `i` as we go, then subtract off its starting\r\n\t\t// value at the end to obtain `delta`.\r\n\t\tvar oldi = i;\r\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\r\n\r\n\t\t\tif (index >= inputLength) {\r\n\t\t\t\terror$1('invalid-input');\r\n\t\t\t}\r\n\r\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\r\n\r\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\r\n\t\t\t\terror$1('overflow');\r\n\t\t\t}\r\n\r\n\t\t\ti += digit * w;\r\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\r\n\r\n\t\t\tif (digit < t) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tvar baseMinusT = base - t;\r\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\r\n\t\t\t\terror$1('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tw *= baseMinusT;\r\n\t\t}\r\n\r\n\t\tvar out = output.length + 1;\r\n\t\tbias = adapt(i - oldi, out, oldi == 0);\r\n\r\n\t\t// `i` was supposed to wrap around from `out` to `0`,\r\n\t\t// incrementing `n` each time, so we'll fix that now:\r\n\t\tif (floor(i / out) > maxInt - n) {\r\n\t\t\terror$1('overflow');\r\n\t\t}\r\n\r\n\t\tn += floor(i / out);\r\n\t\ti %= out;\r\n\r\n\t\t// Insert `n` at position `i` of the output.\r\n\t\toutput.splice(i++, 0, n);\r\n\t}\r\n\r\n\treturn String.fromCodePoint.apply(String, output);\r\n};\r\n\r\n/**\r\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n * Punycode string of ASCII-only symbols.\r\n * @memberOf punycode\r\n * @param {String} input The string of Unicode symbols.\r\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n */\r\nvar encode = function encode(input) {\r\n\tvar output = [];\r\n\r\n\t// Convert the input in UCS-2 to an array of Unicode code points.\r\n\tinput = ucs2decode(input);\r\n\r\n\t// Cache the length.\r\n\tvar inputLength = input.length;\r\n\r\n\t// Initialize the state.\r\n\tvar n = initialN;\r\n\tvar delta = 0;\r\n\tvar bias = initialBias;\r\n\r\n\t// Handle the basic code points.\r\n\tvar _iteratorNormalCompletion = true;\r\n\tvar _didIteratorError = false;\r\n\tvar _iteratorError = undefined;\r\n\r\n\ttry {\r\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\r\n\t\t\tvar _currentValue2 = _step.value;\r\n\r\n\t\t\tif (_currentValue2 < 0x80) {\r\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (err) {\r\n\t\t_didIteratorError = true;\r\n\t\t_iteratorError = err;\r\n\t} finally {\r\n\t\ttry {\r\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\r\n\t\t\t\t_iterator.return();\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tif (_didIteratorError) {\r\n\t\t\t\tthrow _iteratorError;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar basicLength = output.length;\r\n\tvar handledCPCount = basicLength;\r\n\r\n\t// `handledCPCount` is the number of code points that have been handled;\r\n\t// `basicLength` is the number of basic code points.\r\n\r\n\t// Finish the basic string with a delimiter unless it's empty.\r\n\tif (basicLength) {\r\n\t\toutput.push(delimiter);\r\n\t}\r\n\r\n\t// Main encoding loop:\r\n\twhile (handledCPCount < inputLength) {\r\n\r\n\t\t// All non-basic code points < n have been handled already. Find the next\r\n\t\t// larger one:\r\n\t\tvar m = maxInt;\r\n\t\tvar _iteratorNormalCompletion2 = true;\r\n\t\tvar _didIteratorError2 = false;\r\n\t\tvar _iteratorError2 = undefined;\r\n\r\n\t\ttry {\r\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\r\n\t\t\t\tvar currentValue = _step2.value;\r\n\r\n\t\t\t\tif (currentValue >= n && currentValue < m) {\r\n\t\t\t\t\tm = currentValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n\t\t\t// but guard against overflow.\r\n\t\t} catch (err) {\r\n\t\t\t_didIteratorError2 = true;\r\n\t\t\t_iteratorError2 = err;\r\n\t\t} finally {\r\n\t\t\ttry {\r\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\r\n\t\t\t\t\t_iterator2.return();\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (_didIteratorError2) {\r\n\t\t\t\t\tthrow _iteratorError2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\r\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n\t\t\terror$1('overflow');\r\n\t\t}\r\n\r\n\t\tdelta += (m - n) * handledCPCountPlusOne;\r\n\t\tn = m;\r\n\r\n\t\tvar _iteratorNormalCompletion3 = true;\r\n\t\tvar _didIteratorError3 = false;\r\n\t\tvar _iteratorError3 = undefined;\r\n\r\n\t\ttry {\r\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\r\n\t\t\t\tvar _currentValue = _step3.value;\r\n\r\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\r\n\t\t\t\t\terror$1('overflow');\r\n\t\t\t\t}\r\n\t\t\t\tif (_currentValue == n) {\r\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\r\n\t\t\t\t\tvar q = delta;\r\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\r\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\r\n\t\t\t\t\t\tif (q < t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar qMinusT = q - t;\r\n\t\t\t\t\t\tvar baseMinusT = base - t;\r\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\r\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\r\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\r\n\t\t\t\t\tdelta = 0;\r\n\t\t\t\t\t++handledCPCount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\t_didIteratorError3 = true;\r\n\t\t\t_iteratorError3 = err;\r\n\t\t} finally {\r\n\t\t\ttry {\r\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\r\n\t\t\t\t\t_iterator3.return();\r\n\t\t\t\t}\r\n\t\t\t} finally {\r\n\t\t\t\tif (_didIteratorError3) {\r\n\t\t\t\t\tthrow _iteratorError3;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t++delta;\r\n\t\t++n;\r\n\t}\r\n\treturn output.join('');\r\n};\r\n\r\n/**\r\n * Converts a Punycode string representing a domain name or an email address\r\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n * it doesn't matter if you call it on a string that has already been\r\n * converted to Unicode.\r\n * @memberOf punycode\r\n * @param {String} input The Punycoded domain name or email address to\r\n * convert to Unicode.\r\n * @returns {String} The Unicode representation of the given Punycode\r\n * string.\r\n */\r\nvar toUnicode = function toUnicode(input) {\r\n\treturn mapDomain(input, function (string) {\r\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\r\n\t});\r\n};\r\n\r\n/**\r\n * Converts a Unicode string representing a domain name or an email address to\r\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n * i.e. it doesn't matter if you call it with a domain that's already in\r\n * ASCII.\r\n * @memberOf punycode\r\n * @param {String} input The domain name or email address to convert, as a\r\n * Unicode string.\r\n * @returns {String} The Punycode representation of the given domain name or\r\n * email address.\r\n */\r\nvar toASCII = function toASCII(input) {\r\n\treturn mapDomain(input, function (string) {\r\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\r\n\t});\r\n};\r\n\r\n/*--------------------------------------------------------------------------*/\r\n\r\n/** Define the public API */\r\nvar punycode = {\r\n\t/**\r\n  * A string representing the current Punycode.js version number.\r\n  * @memberOf punycode\r\n  * @type String\r\n  */\r\n\t'version': '2.1.0',\r\n\t/**\r\n  * An object of methods to convert from JavaScript's internal character\r\n  * representation (UCS-2) to Unicode code points, and back.\r\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n  * @memberOf punycode\r\n  * @type Object\r\n  */\r\n\t'ucs2': {\r\n\t\t'decode': ucs2decode,\r\n\t\t'encode': ucs2encode\r\n\t},\r\n\t'decode': decode,\r\n\t'encode': encode,\r\n\t'toASCII': toASCII,\r\n\t'toUnicode': toUnicode\r\n};\r\n\r\n/**\r\n * URI.js\r\n *\r\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\r\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\r\n * @see http://github.com/garycourt/uri-js\r\n */\r\n/**\r\n * Copyright 2011 Gary Court. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification, are\r\n * permitted provided that the following conditions are met:\r\n *\r\n *    1. Redistributions of source code must retain the above copyright notice, this list of\r\n *       conditions and the following disclaimer.\r\n *\r\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n *       of conditions and the following disclaimer in the documentation and/or other materials\r\n *       provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * The views and conclusions contained in the software and documentation are those of the\r\n * authors and should not be interpreted as representing official policies, either expressed\r\n * or implied, of Gary Court.\r\n */\r\nvar SCHEMES = {};\r\nfunction pctEncChar(chr) {\r\n    var c = chr.charCodeAt(0);\r\n    var e = void 0;\r\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\r\n    return e;\r\n}\r\nfunction pctDecChars(str) {\r\n    var newStr = \"\";\r\n    var i = 0;\r\n    var il = str.length;\r\n    while (i < il) {\r\n        var c = parseInt(str.substr(i + 1, 2), 16);\r\n        if (c < 128) {\r\n            newStr += String.fromCharCode(c);\r\n            i += 3;\r\n        } else if (c >= 194 && c < 224) {\r\n            if (il - i >= 6) {\r\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\r\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\r\n            } else {\r\n                newStr += str.substr(i, 6);\r\n            }\r\n            i += 6;\r\n        } else if (c >= 224) {\r\n            if (il - i >= 9) {\r\n                var _c = parseInt(str.substr(i + 4, 2), 16);\r\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\r\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\r\n            } else {\r\n                newStr += str.substr(i, 9);\r\n            }\r\n            i += 9;\r\n        } else {\r\n            newStr += str.substr(i, 3);\r\n            i += 3;\r\n        }\r\n    }\r\n    return newStr;\r\n}\r\nfunction _normalizeComponentEncoding(components, protocol) {\r\n    function decodeUnreserved(str) {\r\n        var decStr = pctDecChars(str);\r\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\r\n    }\r\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\r\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n    return components;\r\n}\r\n\r\nfunction _stripLeadingZeros(str) {\r\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\r\n}\r\nfunction _normalizeIPv4(host, protocol) {\r\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\r\n\r\n    var _matches = slicedToArray(matches, 2),\r\n        address = _matches[1];\r\n\r\n    if (address) {\r\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\r\n    } else {\r\n        return host;\r\n    }\r\n}\r\nfunction _normalizeIPv6(host, protocol) {\r\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\r\n\r\n    var _matches2 = slicedToArray(matches, 3),\r\n        address = _matches2[1],\r\n        zone = _matches2[2];\r\n\r\n    if (address) {\r\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\r\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\r\n            last = _address$toLowerCase$2[0],\r\n            first = _address$toLowerCase$2[1];\r\n\r\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\r\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\r\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\r\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\r\n        var lastFieldsStart = lastFields.length - fieldCount;\r\n        var fields = Array(fieldCount);\r\n        for (var x = 0; x < fieldCount; ++x) {\r\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\r\n        }\r\n        if (isLastFieldIPv4Address) {\r\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\r\n        }\r\n        var allZeroFields = fields.reduce(function (acc, field, index) {\r\n            if (!field || field === \"0\") {\r\n                var lastLongest = acc[acc.length - 1];\r\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\r\n                    lastLongest.length++;\r\n                } else {\r\n                    acc.push({ index: index, length: 1 });\r\n                }\r\n            }\r\n            return acc;\r\n        }, []);\r\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\r\n            return b.length - a.length;\r\n        })[0];\r\n        var newHost = void 0;\r\n        if (longestZeroFields && longestZeroFields.length > 1) {\r\n            var newFirst = fields.slice(0, longestZeroFields.index);\r\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\r\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\r\n        } else {\r\n            newHost = fields.join(\":\");\r\n        }\r\n        if (zone) {\r\n            newHost += \"%\" + zone;\r\n        }\r\n        return newHost;\r\n    } else {\r\n        return host;\r\n    }\r\n}\r\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\r\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\r\nfunction parse(uriString) {\r\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n    var components = {};\r\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\r\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\r\n    var matches = uriString.match(URI_PARSE);\r\n    if (matches) {\r\n        if (NO_MATCH_IS_UNDEFINED) {\r\n            //store each component\r\n            components.scheme = matches[1];\r\n            components.userinfo = matches[3];\r\n            components.host = matches[4];\r\n            components.port = parseInt(matches[5], 10);\r\n            components.path = matches[6] || \"\";\r\n            components.query = matches[7];\r\n            components.fragment = matches[8];\r\n            //fix port number\r\n            if (isNaN(components.port)) {\r\n                components.port = matches[5];\r\n            }\r\n        } else {\r\n            //IE FIX for improper RegExp matching\r\n            //store each component\r\n            components.scheme = matches[1] || undefined;\r\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\r\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\r\n            components.port = parseInt(matches[5], 10);\r\n            components.path = matches[6] || \"\";\r\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\r\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\r\n            //fix port number\r\n            if (isNaN(components.port)) {\r\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\r\n            }\r\n        }\r\n        if (components.host) {\r\n            //normalize IP hosts\r\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\r\n        }\r\n        //determine reference type\r\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\r\n            components.reference = \"same-document\";\r\n        } else if (components.scheme === undefined) {\r\n            components.reference = \"relative\";\r\n        } else if (components.fragment === undefined) {\r\n            components.reference = \"absolute\";\r\n        } else {\r\n            components.reference = \"uri\";\r\n        }\r\n        //check for reference errors\r\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\r\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\r\n        }\r\n        //find scheme handler\r\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\r\n        //check if scheme can't handle IRIs\r\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\r\n            //if host component is a domain name\r\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\r\n                //convert Unicode IDN -> ASCII IDN\r\n                try {\r\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\r\n                } catch (e) {\r\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\r\n                }\r\n            }\r\n            //convert IRI -> URI\r\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\r\n        } else {\r\n            //normalize encodings\r\n            _normalizeComponentEncoding(components, protocol);\r\n        }\r\n        //perform scheme specific parsing\r\n        if (schemeHandler && schemeHandler.parse) {\r\n            schemeHandler.parse(components, options);\r\n        }\r\n    } else {\r\n        components.error = components.error || \"URI can not be parsed.\";\r\n    }\r\n    return components;\r\n}\r\n\r\nfunction _recomposeAuthority(components, options) {\r\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\r\n    var uriTokens = [];\r\n    if (components.userinfo !== undefined) {\r\n        uriTokens.push(components.userinfo);\r\n        uriTokens.push(\"@\");\r\n    }\r\n    if (components.host !== undefined) {\r\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\r\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\r\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\r\n        }));\r\n    }\r\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\r\n        uriTokens.push(\":\");\r\n        uriTokens.push(String(components.port));\r\n    }\r\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\r\n}\r\n\r\nvar RDS1 = /^\\.\\.?\\//;\r\nvar RDS2 = /^\\/\\.(\\/|$)/;\r\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\r\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\r\nfunction removeDotSegments(input) {\r\n    var output = [];\r\n    while (input.length) {\r\n        if (input.match(RDS1)) {\r\n            input = input.replace(RDS1, \"\");\r\n        } else if (input.match(RDS2)) {\r\n            input = input.replace(RDS2, \"/\");\r\n        } else if (input.match(RDS3)) {\r\n            input = input.replace(RDS3, \"/\");\r\n            output.pop();\r\n        } else if (input === \".\" || input === \"..\") {\r\n            input = \"\";\r\n        } else {\r\n            var im = input.match(RDS5);\r\n            if (im) {\r\n                var s = im[0];\r\n                input = input.slice(s.length);\r\n                output.push(s);\r\n            } else {\r\n                throw new Error(\"Unexpected dot segment condition\");\r\n            }\r\n        }\r\n    }\r\n    return output.join(\"\");\r\n}\r\n\r\nfunction serialize(components) {\r\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n\r\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\r\n    var uriTokens = [];\r\n    //find scheme handler\r\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\r\n    //perform scheme specific serialization\r\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\r\n    if (components.host) {\r\n        //if host component is an IPv6 address\r\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\r\n        //TODO: normalize IPv6 address as per RFC 5952\r\n\r\n        //if host component is a domain name\r\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\r\n                //convert IDN via punycode\r\n                try {\r\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\r\n                } catch (e) {\r\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\r\n                }\r\n            }\r\n    }\r\n    //normalize encoding\r\n    _normalizeComponentEncoding(components, protocol);\r\n    if (options.reference !== \"suffix\" && components.scheme) {\r\n        uriTokens.push(components.scheme);\r\n        uriTokens.push(\":\");\r\n    }\r\n    var authority = _recomposeAuthority(components, options);\r\n    if (authority !== undefined) {\r\n        if (options.reference !== \"suffix\") {\r\n            uriTokens.push(\"//\");\r\n        }\r\n        uriTokens.push(authority);\r\n        if (components.path && components.path.charAt(0) !== \"/\") {\r\n            uriTokens.push(\"/\");\r\n        }\r\n    }\r\n    if (components.path !== undefined) {\r\n        var s = components.path;\r\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\r\n            s = removeDotSegments(s);\r\n        }\r\n        if (authority === undefined) {\r\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\r\n        }\r\n        uriTokens.push(s);\r\n    }\r\n    if (components.query !== undefined) {\r\n        uriTokens.push(\"?\");\r\n        uriTokens.push(components.query);\r\n    }\r\n    if (components.fragment !== undefined) {\r\n        uriTokens.push(\"#\");\r\n        uriTokens.push(components.fragment);\r\n    }\r\n    return uriTokens.join(\"\"); //merge tokens into a string\r\n}\r\n\r\nfunction resolveComponents(base, relative) {\r\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    var skipNormalization = arguments[3];\r\n\r\n    var target = {};\r\n    if (!skipNormalization) {\r\n        base = parse(serialize(base, options), options); //normalize base components\r\n        relative = parse(serialize(relative, options), options); //normalize relative components\r\n    }\r\n    options = options || {};\r\n    if (!options.tolerant && relative.scheme) {\r\n        target.scheme = relative.scheme;\r\n        //target.authority = relative.authority;\r\n        target.userinfo = relative.userinfo;\r\n        target.host = relative.host;\r\n        target.port = relative.port;\r\n        target.path = removeDotSegments(relative.path || \"\");\r\n        target.query = relative.query;\r\n    } else {\r\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\r\n            //target.authority = relative.authority;\r\n            target.userinfo = relative.userinfo;\r\n            target.host = relative.host;\r\n            target.port = relative.port;\r\n            target.path = removeDotSegments(relative.path || \"\");\r\n            target.query = relative.query;\r\n        } else {\r\n            if (!relative.path) {\r\n                target.path = base.path;\r\n                if (relative.query !== undefined) {\r\n                    target.query = relative.query;\r\n                } else {\r\n                    target.query = base.query;\r\n                }\r\n            } else {\r\n                if (relative.path.charAt(0) === \"/\") {\r\n                    target.path = removeDotSegments(relative.path);\r\n                } else {\r\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\r\n                        target.path = \"/\" + relative.path;\r\n                    } else if (!base.path) {\r\n                        target.path = relative.path;\r\n                    } else {\r\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\r\n                    }\r\n                    target.path = removeDotSegments(target.path);\r\n                }\r\n                target.query = relative.query;\r\n            }\r\n            //target.authority = base.authority;\r\n            target.userinfo = base.userinfo;\r\n            target.host = base.host;\r\n            target.port = base.port;\r\n        }\r\n        target.scheme = base.scheme;\r\n    }\r\n    target.fragment = relative.fragment;\r\n    return target;\r\n}\r\n\r\nfunction resolve(baseURI, relativeURI, options) {\r\n    var schemelessOptions = assign({ scheme: 'null' }, options);\r\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\r\n}\r\n\r\nfunction normalize(uri, options) {\r\n    if (typeof uri === \"string\") {\r\n        uri = serialize(parse(uri, options), options);\r\n    } else if (typeOf(uri) === \"object\") {\r\n        uri = parse(serialize(uri, options), options);\r\n    }\r\n    return uri;\r\n}\r\n\r\nfunction equal(uriA, uriB, options) {\r\n    if (typeof uriA === \"string\") {\r\n        uriA = serialize(parse(uriA, options), options);\r\n    } else if (typeOf(uriA) === \"object\") {\r\n        uriA = serialize(uriA, options);\r\n    }\r\n    if (typeof uriB === \"string\") {\r\n        uriB = serialize(parse(uriB, options), options);\r\n    } else if (typeOf(uriB) === \"object\") {\r\n        uriB = serialize(uriB, options);\r\n    }\r\n    return uriA === uriB;\r\n}\r\n\r\nfunction escapeComponent(str, options) {\r\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\r\n}\r\n\r\nfunction unescapeComponent(str, options) {\r\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\r\n}\r\n\r\nvar handler = {\r\n    scheme: \"http\",\r\n    domainHost: true,\r\n    parse: function parse(components, options) {\r\n        //report missing host\r\n        if (!components.host) {\r\n            components.error = components.error || \"HTTP URIs must have a host.\";\r\n        }\r\n        return components;\r\n    },\r\n    serialize: function serialize(components, options) {\r\n        var secure = String(components.scheme).toLowerCase() === \"https\";\r\n        //normalize the default port\r\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\r\n            components.port = undefined;\r\n        }\r\n        //normalize the empty path\r\n        if (!components.path) {\r\n            components.path = \"/\";\r\n        }\r\n        //NOTE: We do not parse query strings for HTTP URIs\r\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\r\n        //and not the HTTP spec.\r\n        return components;\r\n    }\r\n};\r\n\r\nvar handler$1 = {\r\n    scheme: \"https\",\r\n    domainHost: handler.domainHost,\r\n    parse: handler.parse,\r\n    serialize: handler.serialize\r\n};\r\n\r\nfunction isSecure(wsComponents) {\r\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\r\n}\r\n//RFC 6455\r\nvar handler$2 = {\r\n    scheme: \"ws\",\r\n    domainHost: true,\r\n    parse: function parse(components, options) {\r\n        var wsComponents = components;\r\n        //indicate if the secure flag is set\r\n        wsComponents.secure = isSecure(wsComponents);\r\n        //construct resouce name\r\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\r\n        wsComponents.path = undefined;\r\n        wsComponents.query = undefined;\r\n        return wsComponents;\r\n    },\r\n    serialize: function serialize(wsComponents, options) {\r\n        //normalize the default port\r\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\r\n            wsComponents.port = undefined;\r\n        }\r\n        //ensure scheme matches secure flag\r\n        if (typeof wsComponents.secure === 'boolean') {\r\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\r\n            wsComponents.secure = undefined;\r\n        }\r\n        //reconstruct path from resource name\r\n        if (wsComponents.resourceName) {\r\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\r\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\r\n                path = _wsComponents$resourc2[0],\r\n                query = _wsComponents$resourc2[1];\r\n\r\n            wsComponents.path = path && path !== '/' ? path : undefined;\r\n            wsComponents.query = query;\r\n            wsComponents.resourceName = undefined;\r\n        }\r\n        //forbid fragment component\r\n        wsComponents.fragment = undefined;\r\n        return wsComponents;\r\n    }\r\n};\r\n\r\nvar handler$3 = {\r\n    scheme: \"wss\",\r\n    domainHost: handler$2.domainHost,\r\n    parse: handler$2.parse,\r\n    serialize: handler$2.serialize\r\n};\r\n\r\nvar O = {};\r\nvar isIRI = true;\r\n//RFC 3986\r\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\r\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\r\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\r\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\r\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\r\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\r\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\r\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\r\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\r\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\r\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\r\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\r\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\r\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\r\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\r\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\r\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\r\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\r\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\r\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\r\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\r\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\r\nvar NOT_HFVALUE = NOT_HFNAME;\r\nfunction decodeUnreserved(str) {\r\n    var decStr = pctDecChars(str);\r\n    return !decStr.match(UNRESERVED) ? str : decStr;\r\n}\r\nvar handler$4 = {\r\n    scheme: \"mailto\",\r\n    parse: function parse$$1(components, options) {\r\n        var mailtoComponents = components;\r\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\r\n        mailtoComponents.path = undefined;\r\n        if (mailtoComponents.query) {\r\n            var unknownHeaders = false;\r\n            var headers = {};\r\n            var hfields = mailtoComponents.query.split(\"&\");\r\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\r\n                var hfield = hfields[x].split(\"=\");\r\n                switch (hfield[0]) {\r\n                    case \"to\":\r\n                        var toAddrs = hfield[1].split(\",\");\r\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\r\n                            to.push(toAddrs[_x]);\r\n                        }\r\n                        break;\r\n                    case \"subject\":\r\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\r\n                        break;\r\n                    case \"body\":\r\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\r\n                        break;\r\n                    default:\r\n                        unknownHeaders = true;\r\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\r\n                        break;\r\n                }\r\n            }\r\n            if (unknownHeaders) mailtoComponents.headers = headers;\r\n        }\r\n        mailtoComponents.query = undefined;\r\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\r\n            var addr = to[_x2].split(\"@\");\r\n            addr[0] = unescapeComponent(addr[0]);\r\n            if (!options.unicodeSupport) {\r\n                //convert Unicode IDN -> ASCII IDN\r\n                try {\r\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\r\n                } catch (e) {\r\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\r\n                }\r\n            } else {\r\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\r\n            }\r\n            to[_x2] = addr.join(\"@\");\r\n        }\r\n        return mailtoComponents;\r\n    },\r\n    serialize: function serialize$$1(mailtoComponents, options) {\r\n        var components = mailtoComponents;\r\n        var to = toArray(mailtoComponents.to);\r\n        if (to) {\r\n            for (var x = 0, xl = to.length; x < xl; ++x) {\r\n                var toAddr = String(to[x]);\r\n                var atIdx = toAddr.lastIndexOf(\"@\");\r\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\r\n                var domain = toAddr.slice(atIdx + 1);\r\n                //convert IDN via punycode\r\n                try {\r\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\r\n                } catch (e) {\r\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\r\n                }\r\n                to[x] = localPart + \"@\" + domain;\r\n            }\r\n            components.path = to.join(\",\");\r\n        }\r\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\r\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\r\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\r\n        var fields = [];\r\n        for (var name in headers) {\r\n            if (headers[name] !== O[name]) {\r\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\r\n            }\r\n        }\r\n        if (fields.length) {\r\n            components.query = fields.join(\"&\");\r\n        }\r\n        return components;\r\n    }\r\n};\r\n\r\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\r\n//RFC 2141\r\nvar handler$5 = {\r\n    scheme: \"urn\",\r\n    parse: function parse$$1(components, options) {\r\n        var matches = components.path && components.path.match(URN_PARSE);\r\n        var urnComponents = components;\r\n        if (matches) {\r\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\r\n            var nid = matches[1].toLowerCase();\r\n            var nss = matches[2];\r\n            var urnScheme = scheme + \":\" + (options.nid || nid);\r\n            var schemeHandler = SCHEMES[urnScheme];\r\n            urnComponents.nid = nid;\r\n            urnComponents.nss = nss;\r\n            urnComponents.path = undefined;\r\n            if (schemeHandler) {\r\n                urnComponents = schemeHandler.parse(urnComponents, options);\r\n            }\r\n        } else {\r\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\r\n        }\r\n        return urnComponents;\r\n    },\r\n    serialize: function serialize$$1(urnComponents, options) {\r\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\r\n        var nid = urnComponents.nid;\r\n        var urnScheme = scheme + \":\" + (options.nid || nid);\r\n        var schemeHandler = SCHEMES[urnScheme];\r\n        if (schemeHandler) {\r\n            urnComponents = schemeHandler.serialize(urnComponents, options);\r\n        }\r\n        var uriComponents = urnComponents;\r\n        var nss = urnComponents.nss;\r\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\r\n        return uriComponents;\r\n    }\r\n};\r\n\r\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\r\n//RFC 4122\r\nvar handler$6 = {\r\n    scheme: \"urn:uuid\",\r\n    parse: function parse(urnComponents, options) {\r\n        var uuidComponents = urnComponents;\r\n        uuidComponents.uuid = uuidComponents.nss;\r\n        uuidComponents.nss = undefined;\r\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\r\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\r\n        }\r\n        return uuidComponents;\r\n    },\r\n    serialize: function serialize(uuidComponents, options) {\r\n        var urnComponents = uuidComponents;\r\n        //normalize UUID\r\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\r\n        return urnComponents;\r\n    }\r\n};\r\n\r\nSCHEMES[handler.scheme] = handler;\r\nSCHEMES[handler$1.scheme] = handler$1;\r\nSCHEMES[handler$2.scheme] = handler$2;\r\nSCHEMES[handler$3.scheme] = handler$3;\r\nSCHEMES[handler$4.scheme] = handler$4;\r\nSCHEMES[handler$5.scheme] = handler$5;\r\nSCHEMES[handler$6.scheme] = handler$6;\r\n\r\nexports.SCHEMES = SCHEMES;\r\nexports.pctEncChar = pctEncChar;\r\nexports.pctDecChars = pctDecChars;\r\nexports.parse = parse;\r\nexports.removeDotSegments = removeDotSegments;\r\nexports.serialize = serialize;\r\nexports.resolveComponents = resolveComponents;\r\nexports.resolve = resolve;\r\nexports.normalize = normalize;\r\nexports.equal = equal;\r\nexports.escapeComponent = escapeComponent;\r\nexports.unescapeComponent = unescapeComponent;\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\n})));\r\n//# sourceMappingURL=uri.all.js.map\r\n"]}