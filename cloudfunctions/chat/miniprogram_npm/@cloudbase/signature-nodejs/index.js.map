{"version":3,"sources":["index.js","keyvalue.js","utils.lang.js","signer.js","utils.js","utils.http.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ACHA,AFMA;AFOA,ACHA,AENA,ACHA,AFMA;AFOA,ACHA,AENA,ACHA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA,AFMA;AFOA,ACHA,AENA,AENA,ADGA;AJaA,ACHA,AENA,AENA,ADGA;AJaA,ACHA,AENA,AENA,ADGA;AJaA,ACHA,AENA,AENA,ADGA;AJaA,ACHA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA,ADGA;AHUA,AENA,AENA;AJaA,AENA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./keyvalue\"));\r\n__export(require(\"./signer\"));\r\n__export(require(\"./utils.http\"));\r\n__export(require(\"./utils.lang\"));\r\n__export(require(\"./utils\"));\r\nconst signer_1 = require(\"./signer\");\r\nconst utils_1 = require(\"./utils\");\r\nconst clone = require('clone');\r\nfunction sign(options) {\r\n    const { secretId, secretKey, method, url } = options;\r\n    const signer = new signer_1.Signer({ secretId, secretKey }, 'tcb');\r\n    const headers = clone(options.headers || {});\r\n    const params = clone(options.params || {});\r\n    const timestamp = options.timestamp || utils_1.second() - 1;\r\n    const signatureInfo = signer.tc3sign(method, url, headers, params, timestamp, {\r\n        withSignedParams: options.withSignedParams\r\n    });\r\n    return {\r\n        authorization: signatureInfo.authorization,\r\n        timestamp: signatureInfo.timestamp,\r\n        multipart: signatureInfo.multipart\r\n    };\r\n}\r\nexports.sign = sign;\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils_lang_1 = require(\"./utils.lang\");\r\nclass SortedKeyValue {\r\n    constructor(obj, selectkeys) {\r\n        this._keys = [];\r\n        this._values = [];\r\n        this._pairs = [];\r\n        this._obj = {};\r\n        if (!utils_lang_1.isObject(obj)) {\r\n            return this;\r\n        }\r\n        // https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order\r\n        // https://www.stefanjudis.com/today-i-learned/property-order-is-predictable-in-javascript-objects-since-es2015/\r\n        Object.keys(obj || {}).sort((l, r) => {\r\n            return l.toString().localeCompare(r);\r\n        }).forEach(key => {\r\n            if (!selectkeys || selectkeys.includes(key)) {\r\n                this._keys.push(key);\r\n                this._values.push(obj[key]);\r\n                this._pairs.push([key, obj[key]]);\r\n                this._obj[key.toLowerCase()] = obj[key];\r\n            }\r\n        });\r\n    }\r\n    static kv(obj, selectkeys) {\r\n        return new SortedKeyValue(obj, selectkeys);\r\n    }\r\n    get(key) {\r\n        return this._obj[key];\r\n    }\r\n    keys() {\r\n        return this._keys;\r\n    }\r\n    values() {\r\n        return this._values;\r\n    }\r\n    pairs() {\r\n        return this._pairs;\r\n    }\r\n    toString(kvSeparator = '=', joinSeparator = '&') {\r\n        return this._pairs.map((pair) => pair.join(kvSeparator)).join(joinSeparator);\r\n    }\r\n}\r\nexports.SortedKeyValue = SortedKeyValue;\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction isNumber(v) {\r\n    return v === +v;\r\n}\r\nexports.isNumber = isNumber;\r\nfunction isString(v) {\r\n    return typeof v === 'string';\r\n}\r\nexports.isString = isString;\r\nfunction isObject(v) {\r\n    return v != null && typeof v === 'object' && Array.isArray(v) === false;\r\n}\r\nexports.isObject = isObject;\r\nfunction isPlainObject(v) {\r\n    return isObject(v) && [null, Object.prototype].includes(Object.getPrototypeOf(v));\r\n}\r\nexports.isPlainObject = isPlainObject;\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst crypto = require(\"crypto\");\r\nconst utils_1 = require(\"./utils\");\r\nconst utils_lang_1 = require(\"./utils.lang\");\r\nconst keyvalue_1 = require(\"./keyvalue\");\r\nconst url_1 = require(\"url\");\r\nconst debug = require('util').debuglog('@cloudbase/signature');\r\nconst isStream = require('is-stream');\r\nexports.signedParamsSeparator = ';';\r\nconst HOST_KEY = 'host';\r\nconst CONTENT_TYPE_KEY = 'content-type';\r\nvar MIME;\r\n(function (MIME) {\r\n    MIME[\"MULTIPART_FORM_DATA\"] = \"multipart/form-data\";\r\n    MIME[\"APPLICATION_JSON\"] = \"application/json\";\r\n})(MIME || (MIME = {}));\r\nclass Signer {\r\n    constructor(credential, service, options = {}) {\r\n        this.credential = credential;\r\n        this.service = service;\r\n        this.algorithm = 'TC3-HMAC-SHA256';\r\n        this.options = options;\r\n    }\r\n    static camSafeUrlEncode(str) {\r\n        return encodeURIComponent(str)\r\n            .replace(/!/g, '%21')\r\n            .replace(/'/g, '%27')\r\n            .replace(/\\(/g, '%28')\r\n            .replace(/\\)/g, '%29')\r\n            .replace(/\\*/g, '%2A');\r\n    }\r\n    /**\r\n     * 将一个对象处理成 KeyValue 形式，嵌套的对象将会被处理成字符串，Key转换成小写字母\r\n     * @param {Object}  obj - 待处理的对象\r\n     * @param {Object}  options\r\n     * @param {Boolean} options.enableBuffer\r\n     */\r\n    static formatKeyAndValue(obj, options = {}) {\r\n        if (!utils_lang_1.isPlainObject(obj)) {\r\n            return obj;\r\n        }\r\n        // enableValueToLowerCase：头部字段，要求小写，其他数据不需要小写，所以这里避免转小写\r\n        const { multipart, enableValueToLowerCase = false, selectedKeys, filter } = options;\r\n        const kv = {};\r\n        Object.keys(obj || {}).forEach(key => {\r\n            // NOTE: 客户端类型在服务端可能会丢失\r\n            const lowercaseKey = Signer.camSafeUrlEncode(key.toLowerCase().trim());\r\n            // 过滤 Key，服务端接收到的数据，可能含有未签名的 Key，通常是签名的时候被过滤掉的流，数据量可能会比较大\r\n            // 所以这里提供一个过滤的判断，避免不必要的计算\r\n            // istanbul ignore next\r\n            if (Array.isArray(selectedKeys) && !selectedKeys.includes(lowercaseKey)) {\r\n                return;\r\n            }\r\n            // istanbul ignore next\r\n            if (typeof filter === 'function') {\r\n                if (filter(key, obj[key], options)) {\r\n                    return;\r\n                }\r\n            }\r\n            // istanbul ignore else\r\n            if (key && obj[key] !== undefined) {\r\n                if (lowercaseKey === CONTENT_TYPE_KEY) {\r\n                    // multipart/form-data; boundary=???\r\n                    if (obj[key].startsWith(MIME.MULTIPART_FORM_DATA)) {\r\n                        kv[lowercaseKey] = MIME.MULTIPART_FORM_DATA;\r\n                    }\r\n                    else {\r\n                        kv[lowercaseKey] = obj[key];\r\n                    }\r\n                    return;\r\n                }\r\n                if (isStream(obj[key])) {\r\n                    // 这里如果是个文件流，在发送的时候可以识别\r\n                    // 服务端接收到数据之后传到这里判断不出来的\r\n                    // 所以会进入后边的逻辑\r\n                    return;\r\n                }\r\n                else if (utils_1.isNodeEnv() && Buffer.isBuffer(obj[key])) {\r\n                    if (multipart) {\r\n                        kv[lowercaseKey] = obj[key];\r\n                    }\r\n                    else {\r\n                        kv[lowercaseKey] = enableValueToLowerCase\r\n                            ? utils_1.stringify(obj[key]).trim().toLowerCase()\r\n                            : utils_1.stringify(obj[key]).trim();\r\n                    }\r\n                }\r\n                else {\r\n                    kv[lowercaseKey] = enableValueToLowerCase\r\n                        ? utils_1.stringify(obj[key]).trim().toLowerCase()\r\n                        : utils_1.stringify(obj[key]).trim();\r\n                }\r\n            }\r\n        });\r\n        return kv;\r\n    }\r\n    static calcParamsHash(params, keys = null, options = {}) {\r\n        debug(params, 'calcParamsHash');\r\n        if (utils_lang_1.isString(params)) {\r\n            return utils_1.sha256hash(params);\r\n        }\r\n        // 只关心业务参数，不关心以什么类型的 Content-Type 传递的\r\n        // 所以 application/json multipart/form-data 计算方式是相同的\r\n        keys = keys || keyvalue_1.SortedKeyValue.kv(params).keys();\r\n        const hash = crypto.createHash('sha256');\r\n        for (const key of keys) {\r\n            // istanbul ignore next\r\n            if (!params[key]) {\r\n                continue;\r\n            }\r\n            // istanbul ignore next\r\n            if (isStream(params[key])) {\r\n                continue;\r\n            }\r\n            // string && buffer\r\n            hash.update(`&${key}=`);\r\n            hash.update(params[key]);\r\n            hash.update('\\r\\n');\r\n        }\r\n        return hash.digest(options.encoding || 'hex');\r\n    }\r\n    /**\r\n     * 计算签名信息\r\n     * @param {string} method       - Http Verb：GET/get POST/post 区分大小写\r\n     * @param {string} url          - 地址：http://abc.org/api/v1?a=1&b=2\r\n     * @param {Object} headers      - 需要签名的头部字段\r\n     * @param {string} params       - 请求参数\r\n     * @param {number} [timestamp]  - 签名时间戳\r\n     * @param {object} [options]    - 可选参数\r\n     */\r\n    tc3sign(method, url, headers, params, timestamp, options = {}) {\r\n        timestamp = timestamp || utils_1.second();\r\n        const urlInfo = url_1.parse(url);\r\n        const formatedHeaders = Signer.formatKeyAndValue(headers, {\r\n            enableValueToLowerCase: true\r\n        });\r\n        const headerKV = keyvalue_1.SortedKeyValue.kv(formatedHeaders);\r\n        const signedHeaders = headerKV.keys();\r\n        const canonicalHeaders = headerKV.toString(':', '\\n') + '\\n';\r\n        const { enableHostCheck = true, enableContentTypeCheck = true } = options;\r\n        if (enableHostCheck && headerKV.get(HOST_KEY) !== urlInfo.host) {\r\n            throw new TypeError(`host:${urlInfo.host} in url must be equals to host:${headerKV.get('host')} in headers`);\r\n        }\r\n        if (enableContentTypeCheck && !headerKV.get(CONTENT_TYPE_KEY)) {\r\n            throw new TypeError(`${CONTENT_TYPE_KEY} field must in headers`);\r\n        }\r\n        const multipart = headerKV.get(CONTENT_TYPE_KEY).startsWith(MIME.MULTIPART_FORM_DATA);\r\n        const formatedParams = method.toUpperCase() === 'GET' ? '' : Signer.formatKeyAndValue(params, {\r\n            multipart\r\n        });\r\n        const paramKV = keyvalue_1.SortedKeyValue.kv(formatedParams);\r\n        const signedParams = paramKV.keys();\r\n        const hashedPayload = Signer.calcParamsHash(formatedParams, null);\r\n        const signedUrl = url.replace(/^https?:/, '').split('?')[0];\r\n        const canonicalRequest = `${method}\\n${signedUrl}\\n${urlInfo.query || ''}\\n${canonicalHeaders}\\n${signedHeaders.join(';')}\\n${hashedPayload}`;\r\n        debug(canonicalRequest, 'canonicalRequest\\n\\n');\r\n        const date = utils_1.formateDate(timestamp);\r\n        const service = this.service;\r\n        const algorithm = this.algorithm;\r\n        const credentialScope = `${date}/${service}/tc3_request`;\r\n        const stringToSign = `${algorithm}\\n${timestamp}\\n${credentialScope}\\n${utils_1.sha256hash(canonicalRequest)}`;\r\n        debug(stringToSign, 'stringToSign\\n\\n');\r\n        const secretDate = utils_1.sha256hmac(date, `TC3${this.credential.secretKey}`);\r\n        const secretService = utils_1.sha256hmac(service, secretDate);\r\n        const secretSigning = utils_1.sha256hmac('tc3_request', secretService);\r\n        const signature = utils_1.sha256hmac(stringToSign, secretSigning, 'hex');\r\n        debug(secretDate.toString('hex'), 'secretDate');\r\n        debug(secretService.toString('hex'), 'secretService');\r\n        debug(secretSigning.toString('hex'), 'secretSigning');\r\n        debug(signature, 'signature');\r\n        const { withSignedParams = false } = options;\r\n        return {\r\n            // 需注意该字段长度\r\n            // https://stackoverflow.com/questions/686217/maximum-on-http-header-values\r\n            // https://www.tutorialspoint.com/What-is-the-maximum-size-of-HTTP-header-values\r\n            authorization: `${algorithm} Credential=${this.credential.secretId}/${credentialScope},${withSignedParams ? ` SignedParams=${signedParams.join(';')},` : ''} SignedHeaders=${signedHeaders.join(';')}, Signature=${signature}`,\r\n            signedParams,\r\n            signedHeaders,\r\n            signature,\r\n            timestamp,\r\n            multipart\r\n        };\r\n    }\r\n}\r\nexports.Signer = Signer;\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst crypto = require(\"crypto\");\r\nfunction formateDate(timestamp) {\r\n    return new Date(timestamp * 1000).toISOString().split('T')[0];\r\n}\r\nexports.formateDate = formateDate;\r\nfunction second() {\r\n    // istanbul ignore next\r\n    return Math.floor(new Date().getTime() / 1000);\r\n}\r\nexports.second = second;\r\nfunction stringify(v) {\r\n    return typeof v !== 'string' ? JSON.stringify(v) : v;\r\n}\r\nexports.stringify = stringify;\r\nfunction sha256hash(string, encoding = 'hex') {\r\n    return crypto\r\n        .createHash('sha256')\r\n        .update(string)\r\n        .digest(encoding);\r\n}\r\nexports.sha256hash = sha256hash;\r\nfunction sha256hmac(string, secret = '', encoding) {\r\n    return crypto\r\n        .createHmac('sha256', secret)\r\n        .update(string)\r\n        .digest(encoding);\r\n}\r\nexports.sha256hmac = sha256hmac;\r\nfunction isNodeEnv() {\r\n    return process && process.release && process.release.name === 'node';\r\n}\r\nexports.isNodeEnv = isNodeEnv;\r\n","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils_1 = require(\"./utils\");\r\nconst utils_lang_1 = require(\"./utils.lang\");\r\nconst isStream = require('is-stream');\r\n/**\r\n * 是否能够使用 FormData 发送数据\r\n * @param {any} data - 待发送的数据\r\n */\r\nfunction canUseFormdata(data) {\r\n    let enable = true;\r\n    for (const key in data) {\r\n        const value = data[key];\r\n        if (!isStream(value) && (utils_1.isNodeEnv() && !Buffer.isBuffer(value)) && !utils_lang_1.isString(value) && !utils_lang_1.isNumber(value)) {\r\n            enable = false;\r\n            break;\r\n        }\r\n    }\r\n    return enable;\r\n}\r\nexports.canUseFormdata = canUseFormdata;\r\n/**\r\n * 是否一定要通过 FormData 发送数据\r\n * 如果有 Buffer 和 Stream 必须用 multipart/form-data，如果同时还含有\r\n * @param {any} data - 待发送的数据\r\n */\r\nfunction mustUseFormdata(data) {\r\n    let must = false;\r\n    for (const key in data) {\r\n        const value = data[key];\r\n        if ((utils_1.isNodeEnv() && Buffer.isBuffer(value)) || isStream(value)) {\r\n            must = true;\r\n            break;\r\n        }\r\n    }\r\n    return must;\r\n}\r\nexports.mustUseFormdata = mustUseFormdata;\r\n"]}