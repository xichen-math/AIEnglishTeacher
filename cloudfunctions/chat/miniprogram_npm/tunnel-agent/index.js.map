{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nvar net = require('net')\r\n  , tls = require('tls')\r\n  , http = require('http')\r\n  , https = require('https')\r\n  , events = require('events')\r\n  , assert = require('assert')\r\n  , util = require('util')\r\n  , Buffer = require('safe-buffer').Buffer\r\n  ;\r\n\r\nexports.httpOverHttp = httpOverHttp\r\nexports.httpsOverHttp = httpsOverHttp\r\nexports.httpOverHttps = httpOverHttps\r\nexports.httpsOverHttps = httpsOverHttps\r\n\r\n\r\nfunction httpOverHttp(options) {\r\n  var agent = new TunnelingAgent(options)\r\n  agent.request = http.request\r\n  return agent\r\n}\r\n\r\nfunction httpsOverHttp(options) {\r\n  var agent = new TunnelingAgent(options)\r\n  agent.request = http.request\r\n  agent.createSocket = createSecureSocket\r\n  agent.defaultPort = 443\r\n  return agent\r\n}\r\n\r\nfunction httpOverHttps(options) {\r\n  var agent = new TunnelingAgent(options)\r\n  agent.request = https.request\r\n  return agent\r\n}\r\n\r\nfunction httpsOverHttps(options) {\r\n  var agent = new TunnelingAgent(options)\r\n  agent.request = https.request\r\n  agent.createSocket = createSecureSocket\r\n  agent.defaultPort = 443\r\n  return agent\r\n}\r\n\r\n\r\nfunction TunnelingAgent(options) {\r\n  var self = this\r\n  self.options = options || {}\r\n  self.proxyOptions = self.options.proxy || {}\r\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets\r\n  self.requests = []\r\n  self.sockets = []\r\n\r\n  self.on('free', function onFree(socket, host, port) {\r\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\r\n      var pending = self.requests[i]\r\n      if (pending.host === host && pending.port === port) {\r\n        // Detect the request to connect same origin server,\r\n        // reuse the connection.\r\n        self.requests.splice(i, 1)\r\n        pending.request.onSocket(socket)\r\n        return\r\n      }\r\n    }\r\n    socket.destroy()\r\n    self.removeSocket(socket)\r\n  })\r\n}\r\nutil.inherits(TunnelingAgent, events.EventEmitter)\r\n\r\nTunnelingAgent.prototype.addRequest = function addRequest(req, options) {\r\n  var self = this\r\n\r\n   // Legacy API: addRequest(req, host, port, path)\r\n  if (typeof options === 'string') {\r\n    options = {\r\n      host: options,\r\n      port: arguments[2],\r\n      path: arguments[3]\r\n    };\r\n  }\r\n\r\n  if (self.sockets.length >= this.maxSockets) {\r\n    // We are over limit so we'll add it to the queue.\r\n    self.requests.push({host: options.host, port: options.port, request: req})\r\n    return\r\n  }\r\n\r\n  // If we are under maxSockets create a new one.\r\n  self.createConnection({host: options.host, port: options.port, request: req})\r\n}\r\n\r\nTunnelingAgent.prototype.createConnection = function createConnection(pending) {\r\n  var self = this\r\n\r\n  self.createSocket(pending, function(socket) {\r\n    socket.on('free', onFree)\r\n    socket.on('close', onCloseOrRemove)\r\n    socket.on('agentRemove', onCloseOrRemove)\r\n    pending.request.onSocket(socket)\r\n\r\n    function onFree() {\r\n      self.emit('free', socket, pending.host, pending.port)\r\n    }\r\n\r\n    function onCloseOrRemove(err) {\r\n      self.removeSocket(socket)\r\n      socket.removeListener('free', onFree)\r\n      socket.removeListener('close', onCloseOrRemove)\r\n      socket.removeListener('agentRemove', onCloseOrRemove)\r\n    }\r\n  })\r\n}\r\n\r\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\r\n  var self = this\r\n  var placeholder = {}\r\n  self.sockets.push(placeholder)\r\n\r\n  var connectOptions = mergeOptions({}, self.proxyOptions,\r\n    { method: 'CONNECT'\r\n    , path: options.host + ':' + options.port\r\n    , agent: false\r\n    }\r\n  )\r\n  if (connectOptions.proxyAuth) {\r\n    connectOptions.headers = connectOptions.headers || {}\r\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\r\n        Buffer.from(connectOptions.proxyAuth).toString('base64')\r\n  }\r\n\r\n  debug('making CONNECT request')\r\n  var connectReq = self.request(connectOptions)\r\n  connectReq.useChunkedEncodingByDefault = false // for v0.6\r\n  connectReq.once('response', onResponse) // for v0.6\r\n  connectReq.once('upgrade', onUpgrade)   // for v0.6\r\n  connectReq.once('connect', onConnect)   // for v0.7 or later\r\n  connectReq.once('error', onError)\r\n  connectReq.end()\r\n\r\n  function onResponse(res) {\r\n    // Very hacky. This is necessary to avoid http-parser leaks.\r\n    res.upgrade = true\r\n  }\r\n\r\n  function onUpgrade(res, socket, head) {\r\n    // Hacky.\r\n    process.nextTick(function() {\r\n      onConnect(res, socket, head)\r\n    })\r\n  }\r\n\r\n  function onConnect(res, socket, head) {\r\n    connectReq.removeAllListeners()\r\n    socket.removeAllListeners()\r\n\r\n    if (res.statusCode === 200) {\r\n      assert.equal(head.length, 0)\r\n      debug('tunneling connection has established')\r\n      self.sockets[self.sockets.indexOf(placeholder)] = socket\r\n      cb(socket)\r\n    } else {\r\n      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)\r\n      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)\r\n      error.code = 'ECONNRESET'\r\n      options.request.emit('error', error)\r\n      self.removeSocket(placeholder)\r\n    }\r\n  }\r\n\r\n  function onError(cause) {\r\n    connectReq.removeAllListeners()\r\n\r\n    debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack)\r\n    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)\r\n    error.code = 'ECONNRESET'\r\n    options.request.emit('error', error)\r\n    self.removeSocket(placeholder)\r\n  }\r\n}\r\n\r\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\r\n  var pos = this.sockets.indexOf(socket)\r\n  if (pos === -1) return\r\n\r\n  this.sockets.splice(pos, 1)\r\n\r\n  var pending = this.requests.shift()\r\n  if (pending) {\r\n    // If we have pending requests and a socket gets closed a new one\r\n    // needs to be created to take over in the pool for the one that closed.\r\n    this.createConnection(pending)\r\n  }\r\n}\r\n\r\nfunction createSecureSocket(options, cb) {\r\n  var self = this\r\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\r\n    // 0 is dummy port for v0.6\r\n    var secureSocket = tls.connect(0, mergeOptions({}, self.options,\r\n      { servername: options.host\r\n      , socket: socket\r\n      }\r\n    ))\r\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket\r\n    cb(secureSocket)\r\n  })\r\n}\r\n\r\n\r\nfunction mergeOptions(target) {\r\n  for (var i = 1, len = arguments.length; i < len; ++i) {\r\n    var overrides = arguments[i]\r\n    if (typeof overrides === 'object') {\r\n      var keys = Object.keys(overrides)\r\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\r\n        var k = keys[j]\r\n        if (overrides[k] !== undefined) {\r\n          target[k] = overrides[k]\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return target\r\n}\r\n\r\n\r\nvar debug\r\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\r\n  debug = function() {\r\n    var args = Array.prototype.slice.call(arguments)\r\n    if (typeof args[0] === 'string') {\r\n      args[0] = 'TUNNEL: ' + args[0]\r\n    } else {\r\n      args.unshift('TUNNEL:')\r\n    }\r\n    console.error.apply(console, args)\r\n  }\r\n} else {\r\n  debug = function() {}\r\n}\r\nexports.debug = debug // for test\r\n"]}