{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nvar isNative = /\\.node$/;\r\n\r\nfunction forEach(obj, callback) {\r\n    for ( var key in obj ) {\r\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            continue;\r\n        }\r\n        callback(key);\r\n    }\r\n}\r\n\r\nfunction assign(target, source) {\r\n    forEach(source, function (key) {\r\n        target[key] = source[key];\r\n    });\r\n    return target;\r\n}\r\n\r\nfunction clearCache(requireCache) {\r\n    forEach(requireCache, function (resolvedPath) {\r\n        if (!isNative.test(resolvedPath)) {\r\n            delete requireCache[resolvedPath];\r\n        }\r\n    });\r\n}\r\n\r\nmodule.exports = function (requireCache, callback, callbackForModulesToKeep, module) {\r\n\r\n    var originalCache = assign({}, requireCache);\r\n    clearCache(requireCache);\r\n\r\n    if (callbackForModulesToKeep) {\r\n\r\n        var originalModuleChildren = module.children ? module.children.slice() : false; // Creates a shallow copy of module.children\r\n\r\n        callbackForModulesToKeep();\r\n\r\n        // Lists the cache entries made by callbackForModulesToKeep()\r\n        var modulesToKeep = [];\r\n        forEach(requireCache, function (key) {\r\n            modulesToKeep.push(key);\r\n        });\r\n\r\n        // Discards the modules required in callbackForModulesToKeep()\r\n        clearCache(requireCache);\r\n\r\n        if (module.children) { // Only true for node.js\r\n            module.children = originalModuleChildren; // Removes last references to modules required in callbackForModulesToKeep() -> No memory leak\r\n        }\r\n\r\n        // Takes the cache entries of the original cache in case the modules where required before\r\n        for ( var i = 0; i < modulesToKeep.length; i+=1 ) {\r\n            if (originalCache[modulesToKeep[i]]) {\r\n                requireCache[modulesToKeep[i]] = originalCache[modulesToKeep[i]];\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    var freshModule = callback();\r\n\r\n    var stealthCache = callbackForModulesToKeep ? assign({}, requireCache) : false;\r\n\r\n    clearCache(requireCache);\r\n\r\n    if (callbackForModulesToKeep) {\r\n        // In case modules to keep were required inside the stealthy require for the first time, copy them to the restored cache\r\n        for ( var k = 0; k < modulesToKeep.length; k+=1 ) {\r\n            if (stealthCache[modulesToKeep[k]]) {\r\n                requireCache[modulesToKeep[k]] = stealthCache[modulesToKeep[k]];\r\n            }\r\n        }\r\n    }\r\n\r\n    assign(requireCache, originalCache);\r\n\r\n    return freshModule;\r\n\r\n};\r\n"]}