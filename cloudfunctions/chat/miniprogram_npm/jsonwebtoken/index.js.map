{"version":3,"sources":["index.js","decode.js","verify.js","lib/JsonWebTokenError.js","lib/NotBeforeError.js","lib/TokenExpiredError.js","lib/timespan.js","lib/psSupported.js","sign.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,ACHA,AHSA;ADIA,AENA,ACHA,ACHA,AHSA;ADIA,AENA,ACHA,ACHA,AHSA;ADIA,AENA,ACHA,ACHA,ACHA,AJYA;ADIA,AENA,ACHA,ACHA,ACHA,AJYA;ADIA,AENA,ACHA,ACHA,ACHA,AJYA;ADIA,AENA,ACHA,ACHA,AENA,ADGA,AJYA;ADIA,AENA,ACHA,ACHA,AENA,ADGA,AJYA;ADIA,AENA,ACHA,ACHA,AENA,ADGA,AJYA;ADIA,AGTA,ACHA,AENA,ADGA,AENA,ANkBA;ADIA,AIZA,ACHA,AENA,ANkBA;ADIA,AIZA,ACHA,AENA,ANkBA;ADIA,AIZA,ACHA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;AIXA,AENA,ANkBA;AIXA,AENA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AMjBA,ANkBA;AACA","file":"index.js","sourcesContent":["module.exports = {\r\n  decode: require('./decode'),\r\n  verify: require('./verify'),\r\n  sign: require('./sign'),\r\n  JsonWebTokenError: require('./lib/JsonWebTokenError'),\r\n  NotBeforeError: require('./lib/NotBeforeError'),\r\n  TokenExpiredError: require('./lib/TokenExpiredError'),\r\n};\r\n","var jws = require('jws');\r\n\r\nmodule.exports = function (jwt, options) {\r\n  options = options || {};\r\n  var decoded = jws.decode(jwt, options);\r\n  if (!decoded) { return null; }\r\n  var payload = decoded.payload;\r\n\r\n  //try parse the payload\r\n  if(typeof payload === 'string') {\r\n    try {\r\n      var obj = JSON.parse(payload);\r\n      if(obj !== null && typeof obj === 'object') {\r\n        payload = obj;\r\n      }\r\n    } catch (e) { }\r\n  }\r\n\r\n  //return header if `complete` option is enabled.  header includes claims\r\n  //such as `kid` and `alg` used to select the key within a JWKS needed to\r\n  //verify the signature\r\n  if (options.complete === true) {\r\n    return {\r\n      header: decoded.header,\r\n      payload: payload,\r\n      signature: decoded.signature\r\n    };\r\n  }\r\n  return payload;\r\n};\r\n","var JsonWebTokenError = require('./lib/JsonWebTokenError');\r\nvar NotBeforeError    = require('./lib/NotBeforeError');\r\nvar TokenExpiredError = require('./lib/TokenExpiredError');\r\nvar decode            = require('./decode');\r\nvar timespan          = require('./lib/timespan');\r\nvar PS_SUPPORTED      = require('./lib/psSupported');\r\nvar jws               = require('jws');\r\n\r\nvar PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];\r\nvar RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];\r\nvar HS_ALGS = ['HS256', 'HS384', 'HS512'];\r\n\r\nif (PS_SUPPORTED) {\r\n  PUB_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\r\n  RSA_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\r\n}\r\n\r\nmodule.exports = function (jwtString, secretOrPublicKey, options, callback) {\r\n  if ((typeof options === 'function') && !callback) {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  if (!options) {\r\n    options = {};\r\n  }\r\n\r\n  //clone this object since we are going to mutate it.\r\n  options = Object.assign({}, options);\r\n\r\n  var done;\r\n\r\n  if (callback) {\r\n    done = callback;\r\n  } else {\r\n    done = function(err, data) {\r\n      if (err) throw err;\r\n      return data;\r\n    };\r\n  }\r\n\r\n  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {\r\n    return done(new JsonWebTokenError('clockTimestamp must be a number'));\r\n  }\r\n\r\n  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {\r\n    return done(new JsonWebTokenError('nonce must be a non-empty string'));\r\n  }\r\n\r\n  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);\r\n\r\n  if (!jwtString){\r\n    return done(new JsonWebTokenError('jwt must be provided'));\r\n  }\r\n\r\n  if (typeof jwtString !== 'string') {\r\n    return done(new JsonWebTokenError('jwt must be a string'));\r\n  }\r\n\r\n  var parts = jwtString.split('.');\r\n\r\n  if (parts.length !== 3){\r\n    return done(new JsonWebTokenError('jwt malformed'));\r\n  }\r\n\r\n  var decodedToken;\r\n\r\n  try {\r\n    decodedToken = decode(jwtString, { complete: true });\r\n  } catch(err) {\r\n    return done(err);\r\n  }\r\n\r\n  if (!decodedToken) {\r\n    return done(new JsonWebTokenError('invalid token'));\r\n  }\r\n\r\n  var header = decodedToken.header;\r\n  var getSecret;\r\n\r\n  if(typeof secretOrPublicKey === 'function') {\r\n    if(!callback) {\r\n      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));\r\n    }\r\n\r\n    getSecret = secretOrPublicKey;\r\n  }\r\n  else {\r\n    getSecret = function(header, secretCallback) {\r\n      return secretCallback(null, secretOrPublicKey);\r\n    };\r\n  }\r\n\r\n  return getSecret(header, function(err, secretOrPublicKey) {\r\n    if(err) {\r\n      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));\r\n    }\r\n\r\n    var hasSignature = parts[2].trim() !== '';\r\n\r\n    if (!hasSignature && secretOrPublicKey){\r\n      return done(new JsonWebTokenError('jwt signature is required'));\r\n    }\r\n\r\n    if (hasSignature && !secretOrPublicKey) {\r\n      return done(new JsonWebTokenError('secret or public key must be provided'));\r\n    }\r\n\r\n    if (!hasSignature && !options.algorithms) {\r\n      options.algorithms = ['none'];\r\n    }\r\n\r\n    if (!options.algorithms) {\r\n      options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||\r\n        ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ? PUB_KEY_ALGS :\r\n        ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ? RSA_KEY_ALGS : HS_ALGS;\r\n\r\n    }\r\n\r\n    if (!~options.algorithms.indexOf(decodedToken.header.alg)) {\r\n      return done(new JsonWebTokenError('invalid algorithm'));\r\n    }\r\n\r\n    var valid;\r\n\r\n    try {\r\n      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);\r\n    } catch (e) {\r\n      return done(e);\r\n    }\r\n\r\n    if (!valid) {\r\n      return done(new JsonWebTokenError('invalid signature'));\r\n    }\r\n\r\n    var payload = decodedToken.payload;\r\n\r\n    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {\r\n      if (typeof payload.nbf !== 'number') {\r\n        return done(new JsonWebTokenError('invalid nbf value'));\r\n      }\r\n      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {\r\n        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));\r\n      }\r\n    }\r\n\r\n    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {\r\n      if (typeof payload.exp !== 'number') {\r\n        return done(new JsonWebTokenError('invalid exp value'));\r\n      }\r\n      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {\r\n        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));\r\n      }\r\n    }\r\n\r\n    if (options.audience) {\r\n      var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];\r\n      var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];\r\n\r\n      var match = target.some(function (targetAudience) {\r\n        return audiences.some(function (audience) {\r\n          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;\r\n        });\r\n      });\r\n\r\n      if (!match) {\r\n        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));\r\n      }\r\n    }\r\n\r\n    if (options.issuer) {\r\n      var invalid_issuer =\r\n              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||\r\n              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);\r\n\r\n      if (invalid_issuer) {\r\n        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));\r\n      }\r\n    }\r\n\r\n    if (options.subject) {\r\n      if (payload.sub !== options.subject) {\r\n        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));\r\n      }\r\n    }\r\n\r\n    if (options.jwtid) {\r\n      if (payload.jti !== options.jwtid) {\r\n        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));\r\n      }\r\n    }\r\n\r\n    if (options.nonce) {\r\n      if (payload.nonce !== options.nonce) {\r\n        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));\r\n      }\r\n    }\r\n\r\n    if (options.maxAge) {\r\n      if (typeof payload.iat !== 'number') {\r\n        return done(new JsonWebTokenError('iat required when maxAge is specified'));\r\n      }\r\n\r\n      var maxAgeTimestamp = timespan(options.maxAge, payload.iat);\r\n      if (typeof maxAgeTimestamp === 'undefined') {\r\n        return done(new JsonWebTokenError('\"maxAge\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\r\n      }\r\n      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {\r\n        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));\r\n      }\r\n    }\r\n\r\n    if (options.complete === true) {\r\n      var signature = decodedToken.signature;\r\n\r\n      return done(null, {\r\n        header: header,\r\n        payload: payload,\r\n        signature: signature\r\n      });\r\n    }\r\n\r\n    return done(null, payload);\r\n  });\r\n};\r\n","var JsonWebTokenError = function (message, error) {\r\n  Error.call(this, message);\r\n  if(Error.captureStackTrace) {\r\n    Error.captureStackTrace(this, this.constructor);\r\n  }\r\n  this.name = 'JsonWebTokenError';\r\n  this.message = message;\r\n  if (error) this.inner = error;\r\n};\r\n\r\nJsonWebTokenError.prototype = Object.create(Error.prototype);\r\nJsonWebTokenError.prototype.constructor = JsonWebTokenError;\r\n\r\nmodule.exports = JsonWebTokenError;\r\n","var JsonWebTokenError = require('./JsonWebTokenError');\r\n\r\nvar NotBeforeError = function (message, date) {\r\n  JsonWebTokenError.call(this, message);\r\n  this.name = 'NotBeforeError';\r\n  this.date = date;\r\n};\r\n\r\nNotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);\r\n\r\nNotBeforeError.prototype.constructor = NotBeforeError;\r\n\r\nmodule.exports = NotBeforeError;","var JsonWebTokenError = require('./JsonWebTokenError');\r\n\r\nvar TokenExpiredError = function (message, expiredAt) {\r\n  JsonWebTokenError.call(this, message);\r\n  this.name = 'TokenExpiredError';\r\n  this.expiredAt = expiredAt;\r\n};\r\n\r\nTokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);\r\n\r\nTokenExpiredError.prototype.constructor = TokenExpiredError;\r\n\r\nmodule.exports = TokenExpiredError;","var ms = require('ms');\r\n\r\nmodule.exports = function (time, iat) {\r\n  var timestamp = iat || Math.floor(Date.now() / 1000);\r\n\r\n  if (typeof time === 'string') {\r\n    var milliseconds = ms(time);\r\n    if (typeof milliseconds === 'undefined') {\r\n      return;\r\n    }\r\n    return Math.floor(timestamp + milliseconds / 1000);\r\n  } else if (typeof time === 'number') {\r\n    return timestamp + time;\r\n  } else {\r\n    return;\r\n  }\r\n\r\n};","var semver = require('semver');\r\n\r\nmodule.exports = semver.satisfies(process.version, '^6.12.0 || >=8.0.0');\r\n","var timespan = require('./lib/timespan');\r\nvar PS_SUPPORTED = require('./lib/psSupported');\r\nvar jws = require('jws');\r\nvar includes = require('lodash.includes');\r\nvar isBoolean = require('lodash.isboolean');\r\nvar isInteger = require('lodash.isinteger');\r\nvar isNumber = require('lodash.isnumber');\r\nvar isPlainObject = require('lodash.isplainobject');\r\nvar isString = require('lodash.isstring');\r\nvar once = require('lodash.once');\r\n\r\nvar SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none']\r\nif (PS_SUPPORTED) {\r\n  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');\r\n}\r\n\r\nvar sign_options_schema = {\r\n  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"expiresIn\" should be a number of seconds or string representing a timespan' },\r\n  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '\"notBefore\" should be a number of seconds or string representing a timespan' },\r\n  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '\"audience\" must be a string or array' },\r\n  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '\"algorithm\" must be a valid string enum value' },\r\n  header: { isValid: isPlainObject, message: '\"header\" must be an object' },\r\n  encoding: { isValid: isString, message: '\"encoding\" must be a string' },\r\n  issuer: { isValid: isString, message: '\"issuer\" must be a string' },\r\n  subject: { isValid: isString, message: '\"subject\" must be a string' },\r\n  jwtid: { isValid: isString, message: '\"jwtid\" must be a string' },\r\n  noTimestamp: { isValid: isBoolean, message: '\"noTimestamp\" must be a boolean' },\r\n  keyid: { isValid: isString, message: '\"keyid\" must be a string' },\r\n  mutatePayload: { isValid: isBoolean, message: '\"mutatePayload\" must be a boolean' }\r\n};\r\n\r\nvar registered_claims_schema = {\r\n  iat: { isValid: isNumber, message: '\"iat\" should be a number of seconds' },\r\n  exp: { isValid: isNumber, message: '\"exp\" should be a number of seconds' },\r\n  nbf: { isValid: isNumber, message: '\"nbf\" should be a number of seconds' }\r\n};\r\n\r\nfunction validate(schema, allowUnknown, object, parameterName) {\r\n  if (!isPlainObject(object)) {\r\n    throw new Error('Expected \"' + parameterName + '\" to be a plain object.');\r\n  }\r\n  Object.keys(object)\r\n    .forEach(function(key) {\r\n      var validator = schema[key];\r\n      if (!validator) {\r\n        if (!allowUnknown) {\r\n          throw new Error('\"' + key + '\" is not allowed in \"' + parameterName + '\"');\r\n        }\r\n        return;\r\n      }\r\n      if (!validator.isValid(object[key])) {\r\n        throw new Error(validator.message);\r\n      }\r\n    });\r\n}\r\n\r\nfunction validateOptions(options) {\r\n  return validate(sign_options_schema, false, options, 'options');\r\n}\r\n\r\nfunction validatePayload(payload) {\r\n  return validate(registered_claims_schema, true, payload, 'payload');\r\n}\r\n\r\nvar options_to_payload = {\r\n  'audience': 'aud',\r\n  'issuer': 'iss',\r\n  'subject': 'sub',\r\n  'jwtid': 'jti'\r\n};\r\n\r\nvar options_for_objects = [\r\n  'expiresIn',\r\n  'notBefore',\r\n  'noTimestamp',\r\n  'audience',\r\n  'issuer',\r\n  'subject',\r\n  'jwtid',\r\n];\r\n\r\nmodule.exports = function (payload, secretOrPrivateKey, options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  } else {\r\n    options = options || {};\r\n  }\r\n\r\n  var isObjectPayload = typeof payload === 'object' &&\r\n                        !Buffer.isBuffer(payload);\r\n\r\n  var header = Object.assign({\r\n    alg: options.algorithm || 'HS256',\r\n    typ: isObjectPayload ? 'JWT' : undefined,\r\n    kid: options.keyid\r\n  }, options.header);\r\n\r\n  function failure(err) {\r\n    if (callback) {\r\n      return callback(err);\r\n    }\r\n    throw err;\r\n  }\r\n\r\n  if (!secretOrPrivateKey && options.algorithm !== 'none') {\r\n    return failure(new Error('secretOrPrivateKey must have a value'));\r\n  }\r\n\r\n  if (typeof payload === 'undefined') {\r\n    return failure(new Error('payload is required'));\r\n  } else if (isObjectPayload) {\r\n    try {\r\n      validatePayload(payload);\r\n    }\r\n    catch (error) {\r\n      return failure(error);\r\n    }\r\n    if (!options.mutatePayload) {\r\n      payload = Object.assign({},payload);\r\n    }\r\n  } else {\r\n    var invalid_options = options_for_objects.filter(function (opt) {\r\n      return typeof options[opt] !== 'undefined';\r\n    });\r\n\r\n    if (invalid_options.length > 0) {\r\n      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));\r\n    }\r\n  }\r\n\r\n  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {\r\n    return failure(new Error('Bad \"options.expiresIn\" option the payload already has an \"exp\" property.'));\r\n  }\r\n\r\n  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {\r\n    return failure(new Error('Bad \"options.notBefore\" option the payload already has an \"nbf\" property.'));\r\n  }\r\n\r\n  try {\r\n    validateOptions(options);\r\n  }\r\n  catch (error) {\r\n    return failure(error);\r\n  }\r\n\r\n  var timestamp = payload.iat || Math.floor(Date.now() / 1000);\r\n\r\n  if (options.noTimestamp) {\r\n    delete payload.iat;\r\n  } else if (isObjectPayload) {\r\n    payload.iat = timestamp;\r\n  }\r\n\r\n  if (typeof options.notBefore !== 'undefined') {\r\n    try {\r\n      payload.nbf = timespan(options.notBefore, timestamp);\r\n    }\r\n    catch (err) {\r\n      return failure(err);\r\n    }\r\n    if (typeof payload.nbf === 'undefined') {\r\n      return failure(new Error('\"notBefore\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\r\n    }\r\n  }\r\n\r\n  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {\r\n    try {\r\n      payload.exp = timespan(options.expiresIn, timestamp);\r\n    }\r\n    catch (err) {\r\n      return failure(err);\r\n    }\r\n    if (typeof payload.exp === 'undefined') {\r\n      return failure(new Error('\"expiresIn\" should be a number of seconds or string representing a timespan eg: \"1d\", \"20h\", 60'));\r\n    }\r\n  }\r\n\r\n  Object.keys(options_to_payload).forEach(function (key) {\r\n    var claim = options_to_payload[key];\r\n    if (typeof options[key] !== 'undefined') {\r\n      if (typeof payload[claim] !== 'undefined') {\r\n        return failure(new Error('Bad \"options.' + key + '\" option. The payload already has an \"' + claim + '\" property.'));\r\n      }\r\n      payload[claim] = options[key];\r\n    }\r\n  });\r\n\r\n  var encoding = options.encoding || 'utf8';\r\n\r\n  if (typeof callback === 'function') {\r\n    callback = callback && once(callback);\r\n\r\n    jws.createSign({\r\n      header: header,\r\n      privateKey: secretOrPrivateKey,\r\n      payload: payload,\r\n      encoding: encoding\r\n    }).once('error', callback)\r\n      .once('done', function (signature) {\r\n        callback(null, signature);\r\n      });\r\n  } else {\r\n    return jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});\r\n  }\r\n};\r\n"]}